var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome to the Androguard Docs!","text":""},{"location":"contributing.html","title":"Contributing","text":""},{"location":"contributing.html#setup","title":"Setup","text":"<p>To begin contributing to Androguard:</p> <ol> <li> <p>Clone Androguard: <pre><code>git clone https://github.com/androguard/androguard.git\n</code></pre></p> </li> <li> <p>Install <code>poetry</code>: <pre><code>pip3 install poetry\n</code></pre></p> </li> <li> <p>Install Androguard: <pre><code>poetry install\n</code></pre></p> </li> <li> <p>Verify successful installation by running the unit tests.  From the Androguard root directory: <pre><code>poetry run python -m unittest discover -s tests -p 'test_*.py'\n</code></pre></p> </li> <li> <p>Building docs (optional): <pre><code>cd docs &amp;&amp; pip3 install -r requirements.docs.txt\nmkdocs serve\n</code></pre></p> </li> </ol>"},{"location":"contributing.html#standards","title":"Standards","text":"<ul> <li>Functions and classes should include typing annotations to help navigate and auto-document the code</li> <li>Functions and classes should be documented using sphinx style docstrings.  When referencing other Androguard-internal functions and classes, docstring bodies should use the following syntax to ensure cross-reference link generation.  For example, to generate a cross-reference link to the <code>ClassAnalysis</code> class, use the following bracket annotation that indicates its package:</li> </ul> <pre><code>class REF_TYPE(IntEnum):\n    \"\"\"\n    Stores the opcodes for the type of usage in an XREF.\n\n    Used in [ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis] to store the type of reference to the class.\n    \"\"\"\n</code></pre>"},{"location":"reference/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>androguard<ul> <li>cli<ul> <li>cli</li> <li>main</li> </ul> </li> <li>core<ul> <li>analysis<ul> <li>analysis</li> </ul> </li> <li>androconf</li> <li>api_specific_resources</li> <li>apk</li> <li>axml<ul> <li>types</li> </ul> </li> <li>bytecode</li> <li>dex<ul> <li>dex_types</li> </ul> </li> <li>mutf8</li> <li>resources<ul> <li>public</li> </ul> </li> </ul> </li> <li>decompiler<ul> <li>basic_blocks</li> <li>control_flow</li> <li>dast</li> <li>dataflow</li> <li>decompile</li> <li>decompiler</li> <li>graph</li> <li>instruction</li> <li>node</li> <li>opcode_ins</li> <li>util</li> <li>writer</li> </ul> </li> <li>misc</li> <li>pentest<ul> <li>adb</li> </ul> </li> <li>session</li> <li>ui<ul> <li>data_types</li> <li>filter</li> <li>selection</li> <li>table</li> <li>util</li> <li>widget<ul> <li>details</li> <li>filters</li> <li>frame</li> <li>help</li> <li>toolbar</li> <li>transactions</li> </ul> </li> </ul> </li> <li>util</li> </ul> </li> </ul>"},{"location":"reference/androguard/index.html","title":"androguard","text":""},{"location":"reference/androguard/misc.html","title":"misc","text":""},{"location":"reference/androguard/misc.html#androguard.misc.AnalyzeAPK","title":"<code>AnalyzeAPK(_file, session=None, raw=False)</code>","text":"<p>Analyze an android application and setup all stuff for a more quickly analysis! If session is <code>None</code>, no session is used at all. This is the default behaviour. If you like to continue your work later, it might be a good idea to use a session. A default session can be created by using get_default_session.</p> <p>Parameters:</p> Name Type Description Default <code>_file</code> <code>Union[str, bytes]</code> <p>the filename of the android application or a buffer which represents the application</p> required <code>session</code> <code>Union[Session, None]</code> <p>A session (default: None)</p> <code>None</code> <code>raw</code> <code>bool</code> <p>boolean if raw bytes are supplied instead of a filename</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[APK, list[DEX], Analysis]</code> <p>the <code>androguard.core.apk.APK</code>, list of <code>androguard.core.dex.DEX</code>, and <code>androguard.core.analysis.analysis.Analysis</code> objects</p> Source code in <code>androguard/misc.py</code> <pre><code>def AnalyzeAPK(\n    _file: Union[str, bytes],\n    session: Union[Session, None] = None,\n    raw: bool = False,\n) -&gt; tuple[apk.APK, list[dex.DEX], Analysis]:\n    \"\"\"\n    Analyze an android application and setup all stuff for a more quickly\n    analysis!\n    If session is `None`, no session is used at all. This is the default\n    behaviour.\n    If you like to continue your work later, it might be a good idea to use a\n    session.\n    A default session can be created by using [get_default_session][androguard.misc.get_default_session].\n\n    :param _file: the filename of the android application or a buffer which represents the application\n    :param session: A session (default: None)\n    :param raw: boolean if raw bytes are supplied instead of a filename\n    :returns: the `androguard.core.apk.APK`, list of `androguard.core.dex.DEX`, and `androguard.core.analysis.analysis.Analysis` objects\n    \"\"\"\n    logger.debug(\"AnalyzeAPK\")\n\n    if session:\n        logger.debug(\"Using existing session {}\".format(session))\n        if raw:\n            data = _file\n            filename = hashlib.md5(_file).hexdigest()\n        else:\n            with open(_file, \"rb\") as fd:\n                data = fd.read()\n                filename = _file\n\n        digest = session.add(filename, data)\n        return session.get_objects_apk(filename, digest)\n    else:\n        logger.debug(\"Analysing without session\")\n        a = apk.APK(_file, raw=raw)\n        # FIXME: probably it is not necessary to keep all DEXs, as\n        # they are already part of Analysis. But when using sessions, it works\n        # this way...\n        d = []\n        dx = Analysis()\n        for dex_bytes in a.get_all_dex():\n            df = dex.DEX(dex_bytes, using_api=a.get_target_sdk_version())\n            dx.add(df)\n            d.append(df)\n            df.set_decompiler(decompiler.DecompilerDAD(df, dx))\n\n        dx.create_xref()\n\n        return a, d, dx\n</code></pre>"},{"location":"reference/androguard/misc.html#androguard.misc.AnalyzeDex","title":"<code>AnalyzeDex(filename, session=None, raw=False)</code>","text":"<p>Analyze an android dex file and setup all stuff for a more quickly analysis !</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>the filename of the android dex file or a buffer which represents the dex file</p> required <code>session</code> <code>Session</code> <p>A session (Default <code>None</code>)</p> <code>None</code> <code>raw</code> <code>bool</code> <p>If set, <code>filenam`` will be used as the odex's data (bytes). Defaults to</code>False`</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[str, DEX, Analysis]</code> <p>a tuple of (sha256hash, <code>DEX</code>, <code>Analysis</code>)</p> Source code in <code>androguard/misc.py</code> <pre><code>def AnalyzeDex(\n    filename: str, session: Session = None, raw: bool = False\n) -&gt; tuple[str, dex.DEX, Analysis]:\n    \"\"\"\n    Analyze an android dex file and setup all stuff for a more quickly analysis !\n\n    :param filename: the filename of the android dex file or a buffer which represents the dex file\n    :param session: A session (Default `None`)\n    :param raw: If set, `filenam`` will be used as the odex's data (bytes). Defaults to `False`\n\n    :returns: a tuple of (sha256hash, `DEX`, `Analysis`)\n    \"\"\"\n    logger.debug(\"AnalyzeDex\")\n\n    if not session:\n        session = get_default_session()\n\n    if raw:\n        data = filename\n    else:\n        with open(filename, \"rb\") as fd:\n            data = fd.read()\n\n    return session.addDEX(filename, data)\n</code></pre>"},{"location":"reference/androguard/misc.html#androguard.misc.clean_file_name","title":"<code>clean_file_name(filename, unique=True, replace='_', force_nt=False)</code>","text":"<p>Return a filename version, which has no characters in it which are forbidden. On Windows these are for example &lt;, /, ?, ...</p> <p>The intention of this function is to allow distribution of files to different OSes.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>string to clean</p> required <code>unique</code> <code>bool</code> <p>check if the filename is already taken and append an integer to be unique (default: <code>True</code>)</p> <code>True</code> <code>replace</code> <code>str</code> <p>replacement character. (default: '_')</p> <code>'_'</code> <code>force_nt</code> <code>bool</code> <p>Force shortening of paths like on NT systems (default: <code>False</code>)</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>clean string</p> Source code in <code>androguard/misc.py</code> <pre><code>def clean_file_name(\n    filename: str,\n    unique: bool = True,\n    replace: str = \"_\",\n    force_nt: bool = False,\n) -&gt; str:\n    \"\"\"\n    Return a filename version, which has no characters in it which are forbidden.\n    On Windows these are for example &lt;, /, ?, ...\n\n    The intention of this function is to allow distribution of files to different OSes.\n\n    :param filename: string to clean\n    :param unique: check if the filename is already taken and append an integer to be unique (default: `True`)\n    :param replace: replacement character. (default: '_')\n    :param force_nt: Force shortening of paths like on NT systems (default: `False`)\n    :returns: clean string\n    \"\"\"\n\n    if re.match(r'[&lt;&gt;:\"/\\\\|?* .\\x00-\\x1f]', replace):\n        raise ValueError(\"replacement character is not allowed!\")\n\n    path, fname = os.path.split(filename)\n    # For Windows see: https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx\n    # Other operating systems seems to be more tolerant...\n\n    # Not allowed filenames, attach replace character if necessary\n    if re.match(r'(CON|PRN|AUX|NUL|COM[1-9]|LPT[1-9])', fname):\n        fname += replace\n\n    # reserved characters\n    fname = re.sub(r'[&lt;&gt;:\"/\\\\|?*\\x00-\\x1f]', replace, fname)\n    # Do not end with dot or space\n    fname = re.sub(r'[ .]$', replace, fname)\n\n    # It is a sensible default, to assume that there is a hard 255 char limit per filename\n    # See https://en.wikipedia.org/wiki/Comparison_of_file_systems\n    # If you are using a filesystem with less, you have other problems ;)\n    #\n    # We simply make a hard cut after 255 chars. To leave some space for an extension, which might get added later,\n    # There is room for improvement here, so feel free to implement a better method!\n    PATH_MAX_LENGTH = 230  # give extra space for other stuff...\n    # Check filename length limit, usually a problem on older Windows versions\n    if len(fname) &gt; PATH_MAX_LENGTH:\n        if \".\" in fname:\n            f, ext = fname.rsplit(\".\", 1)\n            fname = \"{}.{}\".format(f[: PATH_MAX_LENGTH - (len(ext) + 1)], ext)\n        else:\n            fname = fname[:PATH_MAX_LENGTH]\n\n    if force_nt or os.name == 'nt':\n        # Special behaviour... On Windows, there is also a problem with the maximum path length in explorer.exe\n        # maximum length is limited to 260 chars, so use 250 to have room for other stuff\n        if len(os.path.abspath(os.path.join(path, fname))) &gt; 250:\n            fname = fname[: 250 - (len(os.path.abspath(path)) + 1)]\n\n    if unique:\n        counter = 0\n        origname = fname\n        while os.path.isfile(os.path.join(path, fname)):\n            if \".\" in fname:\n                # assume extension\n                f, ext = origname.rsplit(\".\", 1)\n                fname = \"{}_{}.{}\".format(f, counter, ext)\n            else:\n                fname = \"{}_{}\".format(origname, counter)\n            counter += 1\n\n    return os.path.join(path, fname)\n</code></pre>"},{"location":"reference/androguard/misc.html#androguard.misc.get_default_session","title":"<code>get_default_session()</code>","text":"<p>Return the default Session from the configuration or create a new one, if the session in the configuration is <code>None</code>.</p> <p>Returns:</p> Type Description <code>Session</code> <p><code>androguard.session.Session</code> object</p> Source code in <code>androguard/misc.py</code> <pre><code>def get_default_session() -&gt; Session:\n    \"\"\"\n    Return the default [Session][androguard.session.Session] from the configuration\n    or create a new one, if the session in the configuration is `None`.\n\n    :returns: `androguard.session.Session` object\n    \"\"\"\n    if androconf.CONF[\"SESSION\"] is None:\n        androconf.CONF[\"SESSION\"] = Session()\n    return androconf.CONF[\"SESSION\"]\n</code></pre>"},{"location":"reference/androguard/session.html","title":"session","text":""},{"location":"reference/androguard/session.html#androguard.session.Session","title":"<code>Session</code>","text":"<p>A Session is able to store in a database, basic information about APK, DEX or ODEX files. Additionally, it offers the possibility to store actions done when using the 'pentest' module.</p> <p>NOTE: an attempt to move from pickling to dataset was started here: https://github.com/androguard/androguard/commit/4dd0dc8c4b55605af863925faf16e8eb35f13e45 but is NOT finished!</p> <p>Should we go back to pickling or proceed further with the dataset ?</p> Source code in <code>androguard/session.py</code> <pre><code>class Session:\n    \"\"\"\n    A Session is able to store in a database, basic information about APK, DEX or ODEX files.\n    Additionally, it offers the possibility to store actions done when using the 'pentest' module.\n\n    NOTE: an attempt to move from pickling to dataset was started here:\n    &lt;https://github.com/androguard/androguard/commit/4dd0dc8c4b55605af863925faf16e8eb35f13e45&gt;\n    but is NOT finished!\n\n    &gt; Should we go back to pickling or proceed further with the dataset ?\n    \"\"\"\n\n    def __init__(\n        self,\n        export_ipython: bool = False,\n        db_url: str = 'sqlite:///androguard.db',\n    ) -&gt; None:\n        \"\"\"\n        Create a new Session object\n\n        :param export_ipython: set to True in order to create attributes for the\n        use in iPython\n        \"\"\"\n        self._setup_objects()\n        self.export_ipython = export_ipython\n\n        self.db = dataset.connect(db_url)\n        logger.info(\"Opening database {}\".format(self.db))\n        self.table_information = self.db[\"information\"]\n        self.table_session = self.db[\"session\"]\n        self.table_pentest = self.db[\"pentest\"]\n        self.table_system = self.db[\"system\"]\n\n        self.session_id = len(self.table_session)\n\n        self.table_session.insert(dict(id=self.session_id))\n        logger.info(\"Creating new session [{}]\".format(self.session_id))\n\n    def save(self, filename: Union[str, None] = None) -&gt; None:\n        \"\"\"\n        Save the current session\n        \"\"\"\n        logger.info(\"Saving the database\")\n        self.db.commit()\n\n    def _setup_objects(self):\n        self.analyzed_files = collections.defaultdict(list)\n        self.analyzed_digest = dict()\n        self.analyzed_apk = dict()\n        self.added_files = []\n\n        # Stores Analysis Objects\n        # needs to be ordered to return the outermost element when searching for\n        # classes\n        self.analyzed_vms = collections.OrderedDict()\n\n        # Dict of digest and DEX/DalvikOdexFormat\n        # Actually not needed, as we have Analysis objects which store the DEX\n        # files as well, but we do not remove it here for legacy reasons\n        self.analyzed_dex = dict()\n\n    def reset(self) -&gt; None:\n        \"\"\"\n        Reset the current session, delete all added files.\n        \"\"\"\n        self._setup_objects()\n\n    def isOpen(self) -&gt; bool:\n        \"\"\"\n        Test if any file was analyzed in this session\n\n        :return: `True` if any file was analyzed, `False` otherwise\n        \"\"\"\n        return len(self.analyzed_digest) &gt; 0\n\n    def show(self) -&gt; None:\n        \"\"\"\n        Print information to stdout about the current session.\n        Gets all APKs, all DEX files and all Analysis objects.\n        \"\"\"\n        print(\"APKs in Session: {}\".format(len(self.analyzed_apk)))\n        for d, a in self.analyzed_apk.items():\n            print(\"\\t{}: {}\".format(d, a))\n\n        print(\"DEXs in Session: {}\".format(len(self.analyzed_dex)))\n        for d, dex in self.analyzed_dex.items():\n            print(\"\\t{}: {}\".format(d, dex))\n\n        print(\"Analysis in Session: {}\".format(len(self.analyzed_vms)))\n        for d, a in self.analyzed_vms.items():\n            print(\"\\t{}: {}\".format(d, a))\n\n    def insert_event(self, call, callee, params, ret):\n        self.table_pentest.insert(\n            dict(\n                session_id=str(self.session_id),\n                call=call,\n                callee=callee,\n                params=params,\n                ret=ret,\n            )\n        )\n\n    def insert_system_event(self, call, callee, information, params):\n        self.table_system.insert(\n            dict(\n                session_id=str(self.session_id),\n                call=call,\n                callee=callee,\n                information=information,\n                params=params,\n            )\n        )\n\n    def addAPK(self, filename: str, data: bytes) -&gt; tuple[str, apk.APK]:\n        \"\"\"\n        Add an APK file to the Session and run analysis on it.\n\n        :param filename: (file)name of APK file\n        :param data: binary data of the APK file\n        :return: a tuple of SHA256 Checksum and APK Object\n        \"\"\"\n        digest = hashlib.sha256(data).hexdigest()\n\n        logger.info(\"add APK {}:{}\".format(filename, digest))\n        self.table_information.insert(\n            dict(\n                session_id=str(self.session_id),\n                filename=filename,\n                digest=digest,\n                type=\"APK\",\n            )\n        )\n\n        newapk = apk.APK(data, True)\n        self.analyzed_apk[digest] = [newapk]\n        self.analyzed_files[filename].append(digest)\n        self.analyzed_digest[digest] = filename\n        self.added_files.append(filename)\n\n        dx = Analysis()\n        self.analyzed_vms[digest] = dx\n\n        for dex in newapk.get_all_dex():\n            # we throw away the output... FIXME?\n            self.addDEX(filename, dex, dx, postpone_xref=True)\n\n        # Postponed\n        dx.create_xref()\n\n        logger.info(\"added APK {}:{}\".format(filename, digest))\n        return digest, newapk\n\n    def addDEX(\n        self,\n        filename: str,\n        data: bytes,\n        dx: Union[Analysis, None] = None,\n        postpone_xref: bool = False,\n    ) -&gt; tuple[str, dex.DEX, Analysis]:\n        \"\"\"\n        Add a DEX file to the Session and run analysis.\n\n        :param filename: the (file)name of the DEX file\n        :param data: binary data of the dex file\n        :param dx: an existing `Analysis` Object (optional)\n        :param postpone_xref: True if no xref shall be created, and will be called manually\n        :return: A tuple of SHA256 Hash, DEX Object and `Analysis` object\n        \"\"\"\n        digest = hashlib.sha256(data).hexdigest()\n        logger.info(\"add DEX:{}\".format(digest))\n\n        self.table_information.insert(\n            dict(\n                session_id=str(self.session_id),\n                filename=filename,\n                digest=digest,\n                type=\"DEX\",\n            )\n        )\n\n        logger.debug(\"Parsing format ...\")\n        d = dex.DEX(data)\n        logger.info(\"added DEX:{}\".format(digest))\n\n        self.analyzed_files[filename].append(digest)\n        self.analyzed_digest[digest] = filename\n\n        self.analyzed_dex[digest] = d\n\n        if dx is None:\n            dx = Analysis()\n\n        dx.add(d)\n        if not postpone_xref:\n            dx.create_xref()\n\n        logger.debug(\"Associated decompiler to the DEX objects\")\n        for d in dx.vms:\n            # TODO: allow different decompiler here!\n            d.set_decompiler(DecompilerDAD(d, dx))\n            d.set_analysis(dx)\n        self.analyzed_vms[digest] = dx\n\n        if self.export_ipython:\n            logger.debug(\"Exporting in ipython\")\n            d.create_python_export()\n\n        return digest, d, dx\n\n    def addODEX(\n        self, filename: str, data: bytes, dx: Union[Analysis, None] = None\n    ) -&gt; tuple[str, dex.ODEX, Analysis]:\n        \"\"\"\n        Add an ODEX file to the session and run the analysis\n\n        :param filename: the ODEX filename\n        :param data: the ODEX bytes\n        :param dx: the `Analysis` object to add the ODEX to\n        :returns: a tuple containing the SHA256 digest, the new `dex.ODEX` object, and the `Analysis` it is contained within.\n        \"\"\"\n        digest = hashlib.sha256(data).hexdigest()\n        logger.info(\"add ODEX:%s\" % digest)\n\n        self.table_information.insert(\n            dict(\n                session_id=str(self.session_id),\n                filename=filename,\n                digest=digest,\n                type=\"ODEX\",\n            )\n        )\n\n        d = dex.ODEX(data)\n        logger.debug(\"added ODEX:%s\" % digest)\n\n        self.analyzed_files[filename].append(digest)\n        self.analyzed_digest[digest] = filename\n\n        self.analyzed_dex[digest] = d\n\n        if self.export_ipython:\n            d.create_python_export()\n\n        if dx is None:\n            dx = Analysis()\n\n        dx.add(d)\n        dx.create_xref()\n\n        for d in dx.vms:\n            # TODO: allow different decompiler here!\n            d.set_decompiler(DecompilerDAD(d, dx))\n            d.set_vmanalysis(dx)\n\n        self.analyzed_vms[digest] = dx\n\n        return digest, d, dx\n\n    def add(\n        self,\n        filename: str,\n        raw_data: Union[bytes, None] = None,\n        dx: Union[Analysis, None] = None,\n    ) -&gt; Union[str, None]:\n        \"\"\"\n        Generic method to add a file to the session.\n\n        This is the main method to use when adding files to a Session!\n\n        If an APK file is supplied, all DEX files are analyzed too.\n        For DEX and ODEX files, only this file is analyzed (what else should be\n        analyzed).\n\n        Returns the SHA256 of the analyzed file.\n\n        :param filename: filename to load\n        :param raw_data: bytes of the file, or None to load the file from filename\n        :param dx: An already exiting `androguard.core.analysis.analysis.Analysis` object\n        :return: the sha256 of the file or None on failure\n        \"\"\"\n        if not raw_data:\n            logger.debug(\"Loading file from '{}'\".format(filename))\n            with open(filename, \"rb\") as fp:\n                raw_data = fp.read()\n\n        ret = androconf.is_android_raw(raw_data)\n        logger.debug(\"Found filetype: '{}'\".format(ret))\n        if not ret:\n            return None\n\n        if ret == \"APK\":\n            digest, _ = self.addAPK(filename, raw_data)\n        elif ret == \"DEX\":\n            digest, _, _ = self.addDEX(filename, raw_data, dx)\n        elif ret == \"DEY\":\n            digest, _, _ = self.addODEX(filename, raw_data, dx)\n        else:\n            return None\n\n        return digest\n\n    def get_classes(\n        self,\n    ) -&gt; Iterator[tuple[int, str, str, list[dex.ClassDefItem]]]:\n        \"\"\"\n        Returns all Java Classes from the DEX objects as an array of DEX files.\n\n        :returns: an iterator where each element is a tuple containing the index of the `Analysis` object, the filename containing the class (ODEX, DEX), the SHA256 digest of the `Analysis` object, and a list of `CalssDefItem`\n        \"\"\"\n        for idx, digest in enumerate(self.analyzed_vms):\n            dx = self.analyzed_vms[digest]\n            for vm in dx.vms:\n                filename = self.analyzed_digest[digest]\n                yield idx, filename, digest, vm.get_classes()\n\n    def get_analysis(self, current_class: dex.ClassDefItem) -&gt; Analysis:\n        \"\"\"\n        Returns the [Analysis][androguard.core.analysis.analysis.Analysis] object\n        which contains the `current_class`.\n\n        :param current_class: The class to search for\n        :returns: the `androguard.core.analysis.analysis.Analysis` object\n        \"\"\"\n        for digest in self.analyzed_vms:\n            dx = self.analyzed_vms[digest]\n            if dx.is_class_present(current_class.get_name()):\n                return dx\n        return None\n\n    def get_format(self, current_class: dex.ClassDefItem) -&gt; dex.DEX:\n        \"\"\"\n        Returns the [DEX][androguard.core.dex.DEX] of a\n        given [ClassDefItem][androguard.core.dex.ClassDefItem].\n\n        :param current_class: A ClassDefItem\n        \"\"\"\n        return current_class.CM.vm\n\n    def get_filename_by_class(\n        self, current_class: dex.ClassDefItem\n    ) -&gt; Union[str, None]:\n        \"\"\"\n        Returns the filename of the DEX file where the class is in.\n\n        Returns the first filename this class was present.\n        For example, if you analyzed an APK, this should return the filename of\n        the APK and not of the DEX file.\n\n        :param current_class: `ClassDefItem`\n        :returns: `None` if class was not found or the filename\n        \"\"\"\n        for digest, dx in self.analyzed_vms.items():\n            if dx.is_class_present(current_class.get_name()):\n                return self.analyzed_digest[digest]\n        return None\n\n    def get_digest_by_class(\n        self, current_class: dex.ClassDefItem\n    ) -&gt; Union[str, None]:\n        \"\"\"\n        Return the SHA256 hash of the object containing the [ClassDefItem][androguard.core.dex.ClassDefItem]\n\n        Returns the first digest this class was present.\n        For example, if you analyzed an APK, this should return the digest of\n        the APK and not of the DEX file.\n        \"\"\"\n        for digest, dx in self.analyzed_vms.items():\n            if dx.is_class_present(current_class.get_name()):\n                return digest\n        return None\n\n    def get_strings(\n        self,\n    ) -&gt; Iterator[tuple[str, str, dict[str, StringAnalysis]]]:\n        \"\"\"\n        Yields all [StringAnalysis][androguard.core.analysis.analysis.StringAnalysis] for all unique [Analysis][androguard.core.analysis.analysis.Analysis] objects\n\n        :returns: an iterator of `StringAnalysis` objects\n        \"\"\"\n        seen = []\n        for digest, dx in self.analyzed_vms.items():\n            if dx in seen:\n                continue\n            seen.append(dx)\n            yield digest, self.analyzed_digest[\n                digest\n            ], dx.get_strings_analysis()\n\n    def get_nb_strings(self) -&gt; int:\n        \"\"\"\n        Return the total number of strings in all [Analysis][androguard.core.analysis.analysis.Analysis] objects\n\n        :returns: the number of strings\n        \"\"\"\n        nb = 0\n        seen = []\n        for digest, dx in self.analyzed_vms.items():\n            if dx in seen:\n                continue\n            seen.append(dx)\n            nb += len(dx.get_strings_analysis())\n        return nb\n\n    def get_all_apks(self) -&gt; Iterator[tuple[str, apk.APK]]:\n        \"\"\"\n        Yields a list of tuples of SHA256 hash of the APK and [APK][androguard.core.apk.APK] objects\n        of all analyzed APKs in the Session.\n\n        :returns: an iterator where each element is a tuple of sha256 of the APK, and the `APK` object\n        \"\"\"\n        for digest, a in self.analyzed_apk.items():\n            yield digest, a\n\n    def get_objects_apk(\n        self,\n        filename: Union[str, None] = None,\n        digest: Union[str, None] = None,\n    ) -&gt; Iterator[tuple[apk.APK, list[dex.DEX], Analysis]]:\n        \"\"\"\n        Returns [APK][androguard.core.apk.APK], list of [DEX][androguard.core.dex.DEX], and [Analysis][androguard.core.analysis.analysis.Analysis] of a specified APK.\n\n        You must specify either `filename` or `digest`.\n        It is possible to use both, but in this case only `digest` is used.\n\n        Example:\n\n            &gt;&gt;&gt; s = Session()\n            &gt;&gt;&gt; digest = s.add(\"some.apk\")\n            &gt;&gt;&gt; a, d, dx = s.get_objects_apk(digest=digest)\n\n        Example:\n\n            &gt;&gt;&gt; s = Session()\n            &gt;&gt;&gt; filename = \"some.apk\"\n            &gt;&gt;&gt; digest = s.add(filename)\n            &gt;&gt;&gt; a, d, dx = s.get_objects_apk(filename=filename)\n\n        :param filename: the filename of the APK file, only used of digest is `None`\n        :param digest: the sha256 hash, as returned by `add` for the APK\n        :returns: a tuple of (APK, [DEX], Analysis)\n        \"\"\"\n        if not filename and not digest:\n            raise ValueError(\"Must give at least filename or digest!\")\n\n        if digest is None:\n            digests = self.analyzed_files.get(filename)\n            # Negate to reduce tree\n            if not digests:\n                return None, None, None\n            digest = digests[0]\n\n        a = self.analyzed_apk[digest][0]\n        dx = self.analyzed_vms[digest]\n        return a, dx.vms, dx\n\n    def get_objects_dex(self) -&gt; Iterator[tuple[str, dex.DEX, Analysis]]:\n        \"\"\"\n        Yields all [DEX][androguard.core.dex.DEX] objects including their [Analysis][androguard.core.analysis.analysis.Analysis] objects\n\n        :returns: tuple of (sha256, DEX, Analysis)\n        \"\"\"\n        # TODO: there is no variant like get_objects_apk\n        for digest, d in self.analyzed_dex.items():\n            yield digest, d, self.analyzed_vms[digest]\n</code></pre>"},{"location":"reference/androguard/session.html#androguard.session.Session.__init__","title":"<code>__init__(export_ipython=False, db_url='sqlite:///androguard.db')</code>","text":"<p>Create a new Session object</p> <p>Parameters:</p> Name Type Description Default <code>export_ipython</code> <code>bool</code> <p>set to True in order to create attributes for the use in iPython</p> <code>False</code> Source code in <code>androguard/session.py</code> <pre><code>def __init__(\n    self,\n    export_ipython: bool = False,\n    db_url: str = 'sqlite:///androguard.db',\n) -&gt; None:\n    \"\"\"\n    Create a new Session object\n\n    :param export_ipython: set to True in order to create attributes for the\n    use in iPython\n    \"\"\"\n    self._setup_objects()\n    self.export_ipython = export_ipython\n\n    self.db = dataset.connect(db_url)\n    logger.info(\"Opening database {}\".format(self.db))\n    self.table_information = self.db[\"information\"]\n    self.table_session = self.db[\"session\"]\n    self.table_pentest = self.db[\"pentest\"]\n    self.table_system = self.db[\"system\"]\n\n    self.session_id = len(self.table_session)\n\n    self.table_session.insert(dict(id=self.session_id))\n    logger.info(\"Creating new session [{}]\".format(self.session_id))\n</code></pre>"},{"location":"reference/androguard/session.html#androguard.session.Session.add","title":"<code>add(filename, raw_data=None, dx=None)</code>","text":"<p>Generic method to add a file to the session.</p> <p>This is the main method to use when adding files to a Session!</p> <p>If an APK file is supplied, all DEX files are analyzed too. For DEX and ODEX files, only this file is analyzed (what else should be analyzed).</p> <p>Returns the SHA256 of the analyzed file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>filename to load</p> required <code>raw_data</code> <code>Union[bytes, None]</code> <p>bytes of the file, or None to load the file from filename</p> <code>None</code> <code>dx</code> <code>Union[Analysis, None]</code> <p>An already exiting <code>androguard.core.analysis.analysis.Analysis</code> object</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[str, None]</code> <p>the sha256 of the file or None on failure</p> Source code in <code>androguard/session.py</code> <pre><code>def add(\n    self,\n    filename: str,\n    raw_data: Union[bytes, None] = None,\n    dx: Union[Analysis, None] = None,\n) -&gt; Union[str, None]:\n    \"\"\"\n    Generic method to add a file to the session.\n\n    This is the main method to use when adding files to a Session!\n\n    If an APK file is supplied, all DEX files are analyzed too.\n    For DEX and ODEX files, only this file is analyzed (what else should be\n    analyzed).\n\n    Returns the SHA256 of the analyzed file.\n\n    :param filename: filename to load\n    :param raw_data: bytes of the file, or None to load the file from filename\n    :param dx: An already exiting `androguard.core.analysis.analysis.Analysis` object\n    :return: the sha256 of the file or None on failure\n    \"\"\"\n    if not raw_data:\n        logger.debug(\"Loading file from '{}'\".format(filename))\n        with open(filename, \"rb\") as fp:\n            raw_data = fp.read()\n\n    ret = androconf.is_android_raw(raw_data)\n    logger.debug(\"Found filetype: '{}'\".format(ret))\n    if not ret:\n        return None\n\n    if ret == \"APK\":\n        digest, _ = self.addAPK(filename, raw_data)\n    elif ret == \"DEX\":\n        digest, _, _ = self.addDEX(filename, raw_data, dx)\n    elif ret == \"DEY\":\n        digest, _, _ = self.addODEX(filename, raw_data, dx)\n    else:\n        return None\n\n    return digest\n</code></pre>"},{"location":"reference/androguard/session.html#androguard.session.Session.addAPK","title":"<code>addAPK(filename, data)</code>","text":"<p>Add an APK file to the Session and run analysis on it.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>(file)name of APK file</p> required <code>data</code> <code>bytes</code> <p>binary data of the APK file</p> required <p>Returns:</p> Type Description <code>tuple[str, APK]</code> <p>a tuple of SHA256 Checksum and APK Object</p> Source code in <code>androguard/session.py</code> <pre><code>def addAPK(self, filename: str, data: bytes) -&gt; tuple[str, apk.APK]:\n    \"\"\"\n    Add an APK file to the Session and run analysis on it.\n\n    :param filename: (file)name of APK file\n    :param data: binary data of the APK file\n    :return: a tuple of SHA256 Checksum and APK Object\n    \"\"\"\n    digest = hashlib.sha256(data).hexdigest()\n\n    logger.info(\"add APK {}:{}\".format(filename, digest))\n    self.table_information.insert(\n        dict(\n            session_id=str(self.session_id),\n            filename=filename,\n            digest=digest,\n            type=\"APK\",\n        )\n    )\n\n    newapk = apk.APK(data, True)\n    self.analyzed_apk[digest] = [newapk]\n    self.analyzed_files[filename].append(digest)\n    self.analyzed_digest[digest] = filename\n    self.added_files.append(filename)\n\n    dx = Analysis()\n    self.analyzed_vms[digest] = dx\n\n    for dex in newapk.get_all_dex():\n        # we throw away the output... FIXME?\n        self.addDEX(filename, dex, dx, postpone_xref=True)\n\n    # Postponed\n    dx.create_xref()\n\n    logger.info(\"added APK {}:{}\".format(filename, digest))\n    return digest, newapk\n</code></pre>"},{"location":"reference/androguard/session.html#androguard.session.Session.addDEX","title":"<code>addDEX(filename, data, dx=None, postpone_xref=False)</code>","text":"<p>Add a DEX file to the Session and run analysis.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>the (file)name of the DEX file</p> required <code>data</code> <code>bytes</code> <p>binary data of the dex file</p> required <code>dx</code> <code>Union[Analysis, None]</code> <p>an existing <code>Analysis</code> Object (optional)</p> <code>None</code> <code>postpone_xref</code> <code>bool</code> <p>True if no xref shall be created, and will be called manually</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[str, DEX, Analysis]</code> <p>A tuple of SHA256 Hash, DEX Object and <code>Analysis</code> object</p> Source code in <code>androguard/session.py</code> <pre><code>def addDEX(\n    self,\n    filename: str,\n    data: bytes,\n    dx: Union[Analysis, None] = None,\n    postpone_xref: bool = False,\n) -&gt; tuple[str, dex.DEX, Analysis]:\n    \"\"\"\n    Add a DEX file to the Session and run analysis.\n\n    :param filename: the (file)name of the DEX file\n    :param data: binary data of the dex file\n    :param dx: an existing `Analysis` Object (optional)\n    :param postpone_xref: True if no xref shall be created, and will be called manually\n    :return: A tuple of SHA256 Hash, DEX Object and `Analysis` object\n    \"\"\"\n    digest = hashlib.sha256(data).hexdigest()\n    logger.info(\"add DEX:{}\".format(digest))\n\n    self.table_information.insert(\n        dict(\n            session_id=str(self.session_id),\n            filename=filename,\n            digest=digest,\n            type=\"DEX\",\n        )\n    )\n\n    logger.debug(\"Parsing format ...\")\n    d = dex.DEX(data)\n    logger.info(\"added DEX:{}\".format(digest))\n\n    self.analyzed_files[filename].append(digest)\n    self.analyzed_digest[digest] = filename\n\n    self.analyzed_dex[digest] = d\n\n    if dx is None:\n        dx = Analysis()\n\n    dx.add(d)\n    if not postpone_xref:\n        dx.create_xref()\n\n    logger.debug(\"Associated decompiler to the DEX objects\")\n    for d in dx.vms:\n        # TODO: allow different decompiler here!\n        d.set_decompiler(DecompilerDAD(d, dx))\n        d.set_analysis(dx)\n    self.analyzed_vms[digest] = dx\n\n    if self.export_ipython:\n        logger.debug(\"Exporting in ipython\")\n        d.create_python_export()\n\n    return digest, d, dx\n</code></pre>"},{"location":"reference/androguard/session.html#androguard.session.Session.addODEX","title":"<code>addODEX(filename, data, dx=None)</code>","text":"<p>Add an ODEX file to the session and run the analysis</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>the ODEX filename</p> required <code>data</code> <code>bytes</code> <p>the ODEX bytes</p> required <code>dx</code> <code>Union[Analysis, None]</code> <p>the <code>Analysis</code> object to add the ODEX to</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, ODEX, Analysis]</code> <p>a tuple containing the SHA256 digest, the new <code>dex.ODEX</code> object, and the <code>Analysis</code> it is contained within.</p> Source code in <code>androguard/session.py</code> <pre><code>def addODEX(\n    self, filename: str, data: bytes, dx: Union[Analysis, None] = None\n) -&gt; tuple[str, dex.ODEX, Analysis]:\n    \"\"\"\n    Add an ODEX file to the session and run the analysis\n\n    :param filename: the ODEX filename\n    :param data: the ODEX bytes\n    :param dx: the `Analysis` object to add the ODEX to\n    :returns: a tuple containing the SHA256 digest, the new `dex.ODEX` object, and the `Analysis` it is contained within.\n    \"\"\"\n    digest = hashlib.sha256(data).hexdigest()\n    logger.info(\"add ODEX:%s\" % digest)\n\n    self.table_information.insert(\n        dict(\n            session_id=str(self.session_id),\n            filename=filename,\n            digest=digest,\n            type=\"ODEX\",\n        )\n    )\n\n    d = dex.ODEX(data)\n    logger.debug(\"added ODEX:%s\" % digest)\n\n    self.analyzed_files[filename].append(digest)\n    self.analyzed_digest[digest] = filename\n\n    self.analyzed_dex[digest] = d\n\n    if self.export_ipython:\n        d.create_python_export()\n\n    if dx is None:\n        dx = Analysis()\n\n    dx.add(d)\n    dx.create_xref()\n\n    for d in dx.vms:\n        # TODO: allow different decompiler here!\n        d.set_decompiler(DecompilerDAD(d, dx))\n        d.set_vmanalysis(dx)\n\n    self.analyzed_vms[digest] = dx\n\n    return digest, d, dx\n</code></pre>"},{"location":"reference/androguard/session.html#androguard.session.Session.get_all_apks","title":"<code>get_all_apks()</code>","text":"<p>Yields a list of tuples of SHA256 hash of the APK and APK objects of all analyzed APKs in the Session.</p> <p>Returns:</p> Type Description <code>Iterator[tuple[str, APK]]</code> <p>an iterator where each element is a tuple of sha256 of the APK, and the <code>APK</code> object</p> Source code in <code>androguard/session.py</code> <pre><code>def get_all_apks(self) -&gt; Iterator[tuple[str, apk.APK]]:\n    \"\"\"\n    Yields a list of tuples of SHA256 hash of the APK and [APK][androguard.core.apk.APK] objects\n    of all analyzed APKs in the Session.\n\n    :returns: an iterator where each element is a tuple of sha256 of the APK, and the `APK` object\n    \"\"\"\n    for digest, a in self.analyzed_apk.items():\n        yield digest, a\n</code></pre>"},{"location":"reference/androguard/session.html#androguard.session.Session.get_analysis","title":"<code>get_analysis(current_class)</code>","text":"<p>Returns the Analysis object which contains the <code>current_class</code>.</p> <p>Parameters:</p> Name Type Description Default <code>current_class</code> <code>ClassDefItem</code> <p>The class to search for</p> required <p>Returns:</p> Type Description <code>Analysis</code> <p>the <code>androguard.core.analysis.analysis.Analysis</code> object</p> Source code in <code>androguard/session.py</code> <pre><code>def get_analysis(self, current_class: dex.ClassDefItem) -&gt; Analysis:\n    \"\"\"\n    Returns the [Analysis][androguard.core.analysis.analysis.Analysis] object\n    which contains the `current_class`.\n\n    :param current_class: The class to search for\n    :returns: the `androguard.core.analysis.analysis.Analysis` object\n    \"\"\"\n    for digest in self.analyzed_vms:\n        dx = self.analyzed_vms[digest]\n        if dx.is_class_present(current_class.get_name()):\n            return dx\n    return None\n</code></pre>"},{"location":"reference/androguard/session.html#androguard.session.Session.get_classes","title":"<code>get_classes()</code>","text":"<p>Returns all Java Classes from the DEX objects as an array of DEX files.</p> <p>Returns:</p> Type Description <code>Iterator[tuple[int, str, str, list[ClassDefItem]]]</code> <p>an iterator where each element is a tuple containing the index of the <code>Analysis</code> object, the filename containing the class (ODEX, DEX), the SHA256 digest of the <code>Analysis</code> object, and a list of <code>CalssDefItem</code></p> Source code in <code>androguard/session.py</code> <pre><code>def get_classes(\n    self,\n) -&gt; Iterator[tuple[int, str, str, list[dex.ClassDefItem]]]:\n    \"\"\"\n    Returns all Java Classes from the DEX objects as an array of DEX files.\n\n    :returns: an iterator where each element is a tuple containing the index of the `Analysis` object, the filename containing the class (ODEX, DEX), the SHA256 digest of the `Analysis` object, and a list of `CalssDefItem`\n    \"\"\"\n    for idx, digest in enumerate(self.analyzed_vms):\n        dx = self.analyzed_vms[digest]\n        for vm in dx.vms:\n            filename = self.analyzed_digest[digest]\n            yield idx, filename, digest, vm.get_classes()\n</code></pre>"},{"location":"reference/androguard/session.html#androguard.session.Session.get_digest_by_class","title":"<code>get_digest_by_class(current_class)</code>","text":"<p>Return the SHA256 hash of the object containing the ClassDefItem</p> <p>Returns the first digest this class was present. For example, if you analyzed an APK, this should return the digest of the APK and not of the DEX file.</p> Source code in <code>androguard/session.py</code> <pre><code>def get_digest_by_class(\n    self, current_class: dex.ClassDefItem\n) -&gt; Union[str, None]:\n    \"\"\"\n    Return the SHA256 hash of the object containing the [ClassDefItem][androguard.core.dex.ClassDefItem]\n\n    Returns the first digest this class was present.\n    For example, if you analyzed an APK, this should return the digest of\n    the APK and not of the DEX file.\n    \"\"\"\n    for digest, dx in self.analyzed_vms.items():\n        if dx.is_class_present(current_class.get_name()):\n            return digest\n    return None\n</code></pre>"},{"location":"reference/androguard/session.html#androguard.session.Session.get_filename_by_class","title":"<code>get_filename_by_class(current_class)</code>","text":"<p>Returns the filename of the DEX file where the class is in.</p> <p>Returns the first filename this class was present. For example, if you analyzed an APK, this should return the filename of the APK and not of the DEX file.</p> <p>Parameters:</p> Name Type Description Default <code>current_class</code> <code>ClassDefItem</code> <p><code>ClassDefItem</code></p> required <p>Returns:</p> Type Description <code>Union[str, None]</code> <p><code>None</code> if class was not found or the filename</p> Source code in <code>androguard/session.py</code> <pre><code>def get_filename_by_class(\n    self, current_class: dex.ClassDefItem\n) -&gt; Union[str, None]:\n    \"\"\"\n    Returns the filename of the DEX file where the class is in.\n\n    Returns the first filename this class was present.\n    For example, if you analyzed an APK, this should return the filename of\n    the APK and not of the DEX file.\n\n    :param current_class: `ClassDefItem`\n    :returns: `None` if class was not found or the filename\n    \"\"\"\n    for digest, dx in self.analyzed_vms.items():\n        if dx.is_class_present(current_class.get_name()):\n            return self.analyzed_digest[digest]\n    return None\n</code></pre>"},{"location":"reference/androguard/session.html#androguard.session.Session.get_format","title":"<code>get_format(current_class)</code>","text":"<p>Returns the DEX of a given ClassDefItem.</p> <p>Parameters:</p> Name Type Description Default <code>current_class</code> <code>ClassDefItem</code> <p>A ClassDefItem</p> required Source code in <code>androguard/session.py</code> <pre><code>def get_format(self, current_class: dex.ClassDefItem) -&gt; dex.DEX:\n    \"\"\"\n    Returns the [DEX][androguard.core.dex.DEX] of a\n    given [ClassDefItem][androguard.core.dex.ClassDefItem].\n\n    :param current_class: A ClassDefItem\n    \"\"\"\n    return current_class.CM.vm\n</code></pre>"},{"location":"reference/androguard/session.html#androguard.session.Session.get_nb_strings","title":"<code>get_nb_strings()</code>","text":"<p>Return the total number of strings in all Analysis objects</p> <p>Returns:</p> Type Description <code>int</code> <p>the number of strings</p> Source code in <code>androguard/session.py</code> <pre><code>def get_nb_strings(self) -&gt; int:\n    \"\"\"\n    Return the total number of strings in all [Analysis][androguard.core.analysis.analysis.Analysis] objects\n\n    :returns: the number of strings\n    \"\"\"\n    nb = 0\n    seen = []\n    for digest, dx in self.analyzed_vms.items():\n        if dx in seen:\n            continue\n        seen.append(dx)\n        nb += len(dx.get_strings_analysis())\n    return nb\n</code></pre>"},{"location":"reference/androguard/session.html#androguard.session.Session.get_objects_apk","title":"<code>get_objects_apk(filename=None, digest=None)</code>","text":"<p>Returns APK, list of DEX, and Analysis of a specified APK.</p> <p>You must specify either <code>filename</code> or <code>digest</code>. It is possible to use both, but in this case only <code>digest</code> is used.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; s = Session()\n&gt;&gt;&gt; digest = s.add(\"some.apk\")\n&gt;&gt;&gt; a, d, dx = s.get_objects_apk(digest=digest)\n</code></pre> <p>Example:</p> <pre><code>&gt;&gt;&gt; s = Session()\n&gt;&gt;&gt; filename = \"some.apk\"\n&gt;&gt;&gt; digest = s.add(filename)\n&gt;&gt;&gt; a, d, dx = s.get_objects_apk(filename=filename)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Union[str, None]</code> <p>the filename of the APK file, only used of digest is <code>None</code></p> <code>None</code> <code>digest</code> <code>Union[str, None]</code> <p>the sha256 hash, as returned by <code>add</code> for the APK</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[tuple[APK, list[DEX], Analysis]]</code> <p>a tuple of (APK, [DEX], Analysis)</p> Source code in <code>androguard/session.py</code> <pre><code>def get_objects_apk(\n    self,\n    filename: Union[str, None] = None,\n    digest: Union[str, None] = None,\n) -&gt; Iterator[tuple[apk.APK, list[dex.DEX], Analysis]]:\n    \"\"\"\n    Returns [APK][androguard.core.apk.APK], list of [DEX][androguard.core.dex.DEX], and [Analysis][androguard.core.analysis.analysis.Analysis] of a specified APK.\n\n    You must specify either `filename` or `digest`.\n    It is possible to use both, but in this case only `digest` is used.\n\n    Example:\n\n        &gt;&gt;&gt; s = Session()\n        &gt;&gt;&gt; digest = s.add(\"some.apk\")\n        &gt;&gt;&gt; a, d, dx = s.get_objects_apk(digest=digest)\n\n    Example:\n\n        &gt;&gt;&gt; s = Session()\n        &gt;&gt;&gt; filename = \"some.apk\"\n        &gt;&gt;&gt; digest = s.add(filename)\n        &gt;&gt;&gt; a, d, dx = s.get_objects_apk(filename=filename)\n\n    :param filename: the filename of the APK file, only used of digest is `None`\n    :param digest: the sha256 hash, as returned by `add` for the APK\n    :returns: a tuple of (APK, [DEX], Analysis)\n    \"\"\"\n    if not filename and not digest:\n        raise ValueError(\"Must give at least filename or digest!\")\n\n    if digest is None:\n        digests = self.analyzed_files.get(filename)\n        # Negate to reduce tree\n        if not digests:\n            return None, None, None\n        digest = digests[0]\n\n    a = self.analyzed_apk[digest][0]\n    dx = self.analyzed_vms[digest]\n    return a, dx.vms, dx\n</code></pre>"},{"location":"reference/androguard/session.html#androguard.session.Session.get_objects_dex","title":"<code>get_objects_dex()</code>","text":"<p>Yields all DEX objects including their Analysis objects</p> <p>Returns:</p> Type Description <code>Iterator[tuple[str, DEX, Analysis]]</code> <p>tuple of (sha256, DEX, Analysis)</p> Source code in <code>androguard/session.py</code> <pre><code>def get_objects_dex(self) -&gt; Iterator[tuple[str, dex.DEX, Analysis]]:\n    \"\"\"\n    Yields all [DEX][androguard.core.dex.DEX] objects including their [Analysis][androguard.core.analysis.analysis.Analysis] objects\n\n    :returns: tuple of (sha256, DEX, Analysis)\n    \"\"\"\n    # TODO: there is no variant like get_objects_apk\n    for digest, d in self.analyzed_dex.items():\n        yield digest, d, self.analyzed_vms[digest]\n</code></pre>"},{"location":"reference/androguard/session.html#androguard.session.Session.get_strings","title":"<code>get_strings()</code>","text":"<p>Yields all StringAnalysis for all unique Analysis objects</p> <p>Returns:</p> Type Description <code>Iterator[tuple[str, str, dict[str, StringAnalysis]]]</code> <p>an iterator of <code>StringAnalysis</code> objects</p> Source code in <code>androguard/session.py</code> <pre><code>def get_strings(\n    self,\n) -&gt; Iterator[tuple[str, str, dict[str, StringAnalysis]]]:\n    \"\"\"\n    Yields all [StringAnalysis][androguard.core.analysis.analysis.StringAnalysis] for all unique [Analysis][androguard.core.analysis.analysis.Analysis] objects\n\n    :returns: an iterator of `StringAnalysis` objects\n    \"\"\"\n    seen = []\n    for digest, dx in self.analyzed_vms.items():\n        if dx in seen:\n            continue\n        seen.append(dx)\n        yield digest, self.analyzed_digest[\n            digest\n        ], dx.get_strings_analysis()\n</code></pre>"},{"location":"reference/androguard/session.html#androguard.session.Session.isOpen","title":"<code>isOpen()</code>","text":"<p>Test if any file was analyzed in this session</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if any file was analyzed, <code>False</code> otherwise</p> Source code in <code>androguard/session.py</code> <pre><code>def isOpen(self) -&gt; bool:\n    \"\"\"\n    Test if any file was analyzed in this session\n\n    :return: `True` if any file was analyzed, `False` otherwise\n    \"\"\"\n    return len(self.analyzed_digest) &gt; 0\n</code></pre>"},{"location":"reference/androguard/session.html#androguard.session.Session.reset","title":"<code>reset()</code>","text":"<p>Reset the current session, delete all added files.</p> Source code in <code>androguard/session.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Reset the current session, delete all added files.\n    \"\"\"\n    self._setup_objects()\n</code></pre>"},{"location":"reference/androguard/session.html#androguard.session.Session.save","title":"<code>save(filename=None)</code>","text":"<p>Save the current session</p> Source code in <code>androguard/session.py</code> <pre><code>def save(self, filename: Union[str, None] = None) -&gt; None:\n    \"\"\"\n    Save the current session\n    \"\"\"\n    logger.info(\"Saving the database\")\n    self.db.commit()\n</code></pre>"},{"location":"reference/androguard/session.html#androguard.session.Session.show","title":"<code>show()</code>","text":"<p>Print information to stdout about the current session. Gets all APKs, all DEX files and all Analysis objects.</p> Source code in <code>androguard/session.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"\n    Print information to stdout about the current session.\n    Gets all APKs, all DEX files and all Analysis objects.\n    \"\"\"\n    print(\"APKs in Session: {}\".format(len(self.analyzed_apk)))\n    for d, a in self.analyzed_apk.items():\n        print(\"\\t{}: {}\".format(d, a))\n\n    print(\"DEXs in Session: {}\".format(len(self.analyzed_dex)))\n    for d, dex in self.analyzed_dex.items():\n        print(\"\\t{}: {}\".format(d, dex))\n\n    print(\"Analysis in Session: {}\".format(len(self.analyzed_vms)))\n    for d, a in self.analyzed_vms.items():\n        print(\"\\t{}: {}\".format(d, a))\n</code></pre>"},{"location":"reference/androguard/util.html","title":"util","text":""},{"location":"reference/androguard/util.html#androguard.util.calculate_fingerprint","title":"<code>calculate_fingerprint(key_object)</code>","text":"<p>Calculates a SHA-256 fingerprint of the public key based on its components.</p> <p>Parameters:</p> Name Type Description Default <code>key_object</code> <p>A keys.PublicKeyInfo object containing the parsed public key</p> required <p>Returns:</p> Type Description <p>The fingerprint of the public key as a byte string</p> Source code in <code>androguard/util.py</code> <pre><code>def calculate_fingerprint(key_object):\n    \"\"\"\n    Calculates a SHA-256 fingerprint of the public key based on its components.\n\n    :param key_object: A keys.PublicKeyInfo object containing the parsed public key\n    :return: The fingerprint of the public key as a byte string\n    \"\"\"\n\n    to_hash = None\n\n    # RSA Public Key\n    if key_object.algorithm == 'rsa':\n        key = key_object['public_key'].parsed\n        # Prepare string with modulus and public exponent\n        to_hash = '%d:%d' % (\n            key['modulus'].native,\n            key['public_exponent'].native,\n        )\n\n    # DSA Public Key\n    elif key_object.algorithm == 'dsa':\n        key = key_object['public_key'].parsed\n        params = key_object['algorithm']['parameters']\n        # Prepare string with p, q, g, and public key\n        to_hash = '%d:%d:%d:%d' % (\n            params['p'].native,\n            params['q'].native,\n            params['g'].native,\n            key.native,\n        )\n\n    # EC Public Key\n    elif key_object.algorithm == 'ec':\n        public_key = key_object['public_key'].native\n        # Prepare byte string with curve name and public key\n        to_hash = '%s:' % key_object.curve[1]\n        to_hash = to_hash.encode('utf-8') + public_key\n\n    # Ensure to_hash is encoded as bytes if it's a string\n    if isinstance(to_hash, str):\n        to_hash = to_hash.encode('utf-8')\n\n    # Return the SHA-256 hash of the formatted key data\n    return hashlib.sha256(to_hash).digest()\n</code></pre>"},{"location":"reference/androguard/util.html#androguard.util.get_certificate_name_string","title":"<code>get_certificate_name_string(name, short=False, delimiter=', ')</code>","text":"<p>Format the Name type of a X509 Certificate in a human readable form.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Union[dict, Name]</code> <p>Name object to return the DN from</p> required <code>short</code> <code>bool</code> <p>Use short form (default: False)</p> <code>False</code> <code>delimiter</code> <code>str</code> <p>Delimiter string or character between two parts (default: ', ')</p> <code>', '</code> <p>Returns:</p> Type Description <code>str</code> <p>the name string</p> Source code in <code>androguard/util.py</code> <pre><code>def get_certificate_name_string(\n    name: Union[dict, Name], short: bool = False, delimiter: str = ', '\n) -&gt; str:\n    \"\"\"\n    Format the Name type of a X509 Certificate in a human readable form.\n\n    :param name: Name object to return the DN from\n    :param short: Use short form (default: False)\n    :param delimiter: Delimiter string or character between two parts (default: ', ')\n\n    :returns: the name string\n    \"\"\"\n    if isinstance(name, Name):  # asn1crypto.x509.Name):\n        name = name.native\n\n    # For the shortform, we have a lookup table\n    # See RFC4514 for more details\n    _ = {\n        'business_category': (\"businessCategory\", \"businessCategory\"),\n        'serial_number': (\"serialNumber\", \"serialNumber\"),\n        'country_name': (\"C\", \"countryName\"),\n        'postal_code': (\"postalCode\", \"postalCode\"),\n        'state_or_province_name': (\"ST\", \"stateOrProvinceName\"),\n        'locality_name': (\"L\", \"localityName\"),\n        'street_address': (\"street\", \"streetAddress\"),\n        'organization_name': (\"O\", \"organizationName\"),\n        'organizational_unit_name': (\"OU\", \"organizationalUnitName\"),\n        'title': (\"title\", \"title\"),\n        'common_name': (\"CN\", \"commonName\"),\n        'initials': (\"initials\", \"initials\"),\n        'generation_qualifier': (\"generationQualifier\", \"generationQualifier\"),\n        'surname': (\"SN\", \"surname\"),\n        'given_name': (\"GN\", \"givenName\"),\n        'name': (\"name\", \"name\"),\n        'pseudonym': (\"pseudonym\", \"pseudonym\"),\n        'dn_qualifier': (\"dnQualifier\", \"dnQualifier\"),\n        'telephone_number': (\"telephoneNumber\", \"telephoneNumber\"),\n        'email_address': (\"E\", \"emailAddress\"),\n        'domain_component': (\"DC\", \"domainComponent\"),\n        'name_distinguisher': (\"nameDistinguisher\", \"nameDistinguisher\"),\n        'organization_identifier': (\n            \"organizationIdentifier\",\n            \"organizationIdentifier\",\n        ),\n    }\n    return delimiter.join(\n        [\n            \"{}={}\".format(\n                _.get(attr, (attr, attr))[0 if short else 1], name[attr]\n            )\n            for attr in name\n        ]\n    )\n</code></pre>"},{"location":"reference/androguard/util.html#androguard.util.readFile","title":"<code>readFile(filename, binary=True)</code>","text":"<p>Open and read a file</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>filename to open and read</p> required <code>binary</code> <code>bool</code> <p><code>True</code> if the file should be read as binary</p> <code>True</code> <p>Returns:</p> Type Description <code>bytes</code> <p>bytes if binary is <code>True</code>, str otherwise</p> Source code in <code>androguard/util.py</code> <pre><code>def readFile(filename: str, binary: bool = True) -&gt; bytes:\n    \"\"\"\n    Open and read a file\n    :param filename: filename to open and read\n    :param binary: `True` if the file should be read as binary\n    :return: bytes if binary is `True`, str otherwise\n    \"\"\"\n    with open(filename, 'rb' if binary else 'r') as f:\n        return f.read()\n</code></pre>"},{"location":"reference/androguard/util.html#androguard.util.set_log","title":"<code>set_log(level)</code>","text":"<p>Sets the log for loguru based on the level being passed. The possible string values are:</p> <ul> <li><code>TRACE</code></li> <li><code>DEBUG</code></li> <li><code>INFO</code></li> <li><code>SUCCESS</code></li> <li><code>WARNING</code></li> <li><code>ERROR</code></li> <li><code>CRITICAL</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>str</code> <p>the log level string</p> required Source code in <code>androguard/util.py</code> <pre><code>def set_log(level:str) -&gt; None:\n    \"\"\"\n    Sets the log for loguru based on the level being passed.\n    The possible string values are:\n\n    * `TRACE`\n    * `DEBUG`\n    * `INFO`\n    * `SUCCESS`\n    * `WARNING`\n    * `ERROR`\n    * `CRITICAL`\n\n    :param level: the log level string\n    \"\"\"\n    logger.remove(0)\n    my_filter = MyFilter(level)\n    logger.add(sys.stderr, filter=my_filter, level=0)\n</code></pre>"},{"location":"reference/androguard/cli/index.html","title":"cli","text":""},{"location":"reference/androguard/cli/cli.html","title":"cli","text":"<p>Androguard is a full Python tool to reverse Android Applications.</p>"},{"location":"reference/androguard/cli/cli.html#androguard.cli.cli.analyze","title":"<code>analyze(session, apk)</code>","text":"<p>Open a IPython Shell and start reverse engineering.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>str</code> <p>session file to restore</p> required <code>apk</code> <code>str</code> <p>apk filename to analyze, if session not set</p> required Source code in <code>androguard/cli/cli.py</code> <pre><code>@entry_point.command()\n@click.option(\n    '--session',\n    help='Previously saved session to load instead of a file',\n    type=click.Path(exists=True),\n)\n@click.argument(\n    'apk',\n    default=None,\n    required=False,\n    type=click.Path(exists=True, dir_okay=False, file_okay=True),\n)\ndef analyze(session: str, apk: str):\n    \"\"\"Open a IPython Shell and start reverse engineering.\n\n    :param session: session file to restore\n    :param apk: apk filename to analyze, if session not set\n    \"\"\"\n    androlyze_main(session, apk)\n</code></pre>"},{"location":"reference/androguard/cli/cli.html#androguard.cli.cli.apkid","title":"<code>apkid(apks)</code>","text":"<p>Prints the packageName/versionCode/versionName per APK as JSON.</p> <p>Parameters:</p> Name Type Description Default <code>apks</code> <code>list[str]</code> <p>list of apk filepaths</p> required Source code in <code>androguard/cli/cli.py</code> <pre><code>@entry_point.command()\n@click.argument(\n    'apks',\n    nargs=-1,\n    type=click.Path(exists=True, file_okay=True, dir_okay=False),\n)\ndef apkid(apks: list[str]):\n    \"\"\"Prints the packageName/versionCode/versionName per APK as JSON.\n\n    :param apks: list of apk filepaths\n    \"\"\"\n    from androguard.core.apk import get_apkid\n\n    logger.debug(\"APKID\")\n\n    results = dict()\n    for apk in apks:\n        results[apk] = get_apkid(apk)\n    print(json.dumps(results, indent=2))\n</code></pre>"},{"location":"reference/androguard/cli/cli.html#androguard.cli.cli.arsc","title":"<code>arsc(input_, file_, output, package, locale, type_, id_, list_packages, list_locales, list_types)</code>","text":"<p>Decode resources.arsc either directly from a given file or from an APK.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; androguard arsc app.apk\n</code></pre> Source code in <code>androguard/cli/cli.py</code> <pre><code>@entry_point.command()\n@click.option(\n    '--input',\n    '-i',\n    'input_',\n    type=click.Path(exists=True),\n    help='resources.arsc or APK to parse (legacy option)',\n)\n@click.argument(\n    'file_',\n    required=False,\n)\n@click.option(\n    '--output',\n    '-o',\n    # required=True,  #  not required due to --list-types\n    help='filename to save the decoded resources to',\n)\n@click.option(\n    '--package',\n    '-p',\n    help='Show only resources for the given package name '\n    '(default: the first package name found)',\n)\n@click.option(\n    '--locale',\n    '-l',\n    help='Show only resources for the given locale (default: \\'\\\\x00\\\\x00\\')',\n)\n@click.option(\n    '--type',\n    '-t',\n    'type_',\n    help='Show only resources of the given type (default: public)',\n)\n@click.option(\n    '--id',\n    'id_',\n    help=\"Resolve the given ID for the given locale and package. Provide the hex ID!\",\n)\n@click.option(\n    '--list-packages',\n    is_flag=True,\n    default=False,\n    help='List all package names and exit',\n)\n@click.option(\n    '--list-locales',\n    is_flag=True,\n    default=False,\n    help='List all package names and exit',\n)\n@click.option(\n    '--list-types',\n    is_flag=True,\n    default=False,\n    help='List all types and exit',\n)\ndef arsc(\n    input_,\n    file_,\n    output,\n    package,\n    locale,\n    type_,\n    id_,\n    list_packages,\n    list_locales,\n    list_types,\n):\n    \"\"\"\n    Decode resources.arsc either directly from a given file or from an APK.\n\n    Example:\n\n        &gt;&gt;&gt; androguard arsc app.apk\n    \"\"\"\n\n    from androguard.core import androconf, apk, axml\n\n    if file_ and input_:\n        logger.info(\n            \"Can not give --input and positional argument! Please use only one of them!\"\n        )\n        sys.exit(1)\n\n    if not input_ and not file_:\n        logger.info(\"Give one file to decode!\")\n        sys.exit(1)\n\n    if input_:\n        fname = input_\n    else:\n        fname = file_\n\n    ret_type = androconf.is_android(fname)\n    if ret_type == \"APK\":\n        a = apk.APK(fname)\n        arscobj = a.get_android_resources()\n        if not arscobj:\n            logger.error(\"The APK does not contain a resources file!\")\n            sys.exit(0)\n    elif ret_type == \"ARSC\":\n        with open(fname, 'rb') as fp:\n            arscobj = axml.ARSCParser(fp.read())\n            if not arscobj:\n                logger.error(\"The resources file seems to be invalid!\")\n                sys.exit(1)\n    else:\n        logger.error(\"Unknown file type!\")\n        sys.exit(1)\n\n    if id_:\n        # Strip the @, if any\n        if id_[0] == \"@\":\n            id_ = id_[1:]\n        try:\n            i_id = int(id_, 16)\n        except ValueError:\n            print(\n                \"ID '{}' could not be parsed! have you supplied the correct hex ID?\".format(\n                    id_\n                )\n            )\n            sys.exit(1)\n\n        name = arscobj.get_resource_xml_name(i_id)\n        if not name:\n            print(\"Specified resource was not found!\")\n            sys.exit(1)\n\n        print(\"@{:08x} resolves to '{}'\".format(i_id, name))\n        print()\n\n        # All the information is in the config.\n        # we simply need to get the actual value of the entry\n        for config, entry in arscobj.get_resolved_res_configs(i_id):\n            print(\n                \"{} = '{}'\".format(\n                    (\n                        config.get_qualifier()\n                        if not config.is_default()\n                        else \"&lt;default&gt;\"\n                    ),\n                    entry,\n                )\n            )\n\n        sys.exit(0)\n\n    if list_packages:\n        print(\"\\n\".join(arscobj.get_packages_names()))\n        sys.exit(0)\n\n    if list_locales:\n        for p in arscobj.get_packages_names():\n            print(\"In Package:\", p)\n            print(\n                \"\\n\".join(\n                    map(\n                        lambda x: (\n                            \"  \\\\x00\\\\x00\"\n                            if x == \"\\x00\\x00\"\n                            else \"  {}\".format(x)\n                        ),\n                        sorted(arscobj.get_locales(p)),\n                    )\n                )\n            )\n        sys.exit(0)\n\n    if list_types:\n        for p in arscobj.get_packages_names():\n            print(\"In Package:\", p)\n            for locale in sorted(arscobj.get_locales(p)):\n                print(\n                    \"  In Locale: {}\".format(\n                        \"\\\\x00\\\\x00\" if locale == \"\\x00\\x00\" else locale\n                    )\n                )\n                print(\n                    \"\\n\".join(\n                        map(\n                            \"    {}\".format,\n                            sorted(arscobj.get_types(p, locale)),\n                        )\n                    )\n                )\n        sys.exit(0)\n\n    androarsc_main(\n        arscobj, outp=output, package=package, typ=type_, locale=locale\n    )\n</code></pre>"},{"location":"reference/androguard/cli/cli.html#androguard.cli.cli.axml","title":"<code>axml(input_, output, file_, resource)</code>","text":"<p>Parse the AndroidManifest.xml.</p> <p>Parsing is either direct or from a given APK and prints in XML format or saves to file.</p> <p>This tool can also be used to process any AXML encoded file, for example from the layout directory.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; androguard axml AndroidManifest.xml\n</code></pre> Source code in <code>androguard/cli/cli.py</code> <pre><code>@entry_point.command()\n@click.option(\n    '--input',\n    '-i',\n    'input_',\n    type=click.Path(exists=True, file_okay=True, dir_okay=False),\n    help='AndroidManifest.xml or APK to parse (legacy option)',\n)\n@click.option(\n    '--output',\n    '-o',\n    help='filename to save the decoded AndroidManifest.xml to, default stdout',\n)\n@click.option(\n    \"--resource\",\n    \"-r\",\n    help=\"Resource (any binary XML file) inside the APK to parse instead of AndroidManifest.xml\",\n)\n@click.argument(\n    'file_',\n    required=False,\n    type=click.Path(exists=True, file_okay=True, dir_okay=False),\n)\ndef axml(input_, output, file_, resource):\n    \"\"\"\n    Parse the AndroidManifest.xml.\n\n    Parsing is either direct or from a given APK and prints in XML format or\n    saves to file.\n\n    This tool can also be used to process any AXML encoded file, for example\n    from the layout directory.\n\n    Example:\n\n        &gt;&gt;&gt; androguard axml AndroidManifest.xml\n    \"\"\"\n    if file_ is not None and input_ is not None:\n        print(\n            \"Can not give --input and positional argument! \"\n            \"Please use only one of them!\"\n        )\n        sys.exit(1)\n\n    if file_ is None and input_ is None:\n        print(\"Give one file to decode!\")\n        sys.exit(1)\n\n    if file_ is not None:\n        androaxml_main(file_, output, resource)\n    elif input_ is not None:\n        androaxml_main(input_, output, resource)\n</code></pre>"},{"location":"reference/androguard/cli/cli.html#androguard.cli.cli.cg","title":"<code>cg(file_, output, output_type, show, classname, methodname, descriptor, accessflag, no_isolated)</code>","text":"<p>Create a call graph based on the data of Analysis and export it into a graph format.</p> Source code in <code>androguard/cli/cli.py</code> <pre><code>@entry_point.command()\n@click.argument(\n    'file_',\n    type=click.Path(exists=True, dir_okay=False, file_okay=True),\n    required=True,\n)\n@click.option(\n    '--output',\n    '-o',\n    default='callgraph.gml',\n    help='Filename of the output graph file',\n)\n@click.option(\n    '--output-type',\n    type=click.Choice(list(write_methods.keys()), case_sensitive=False),\n    default='gml',\n    help='Type of the graph to output ',\n)\n@click.option(\n    '--show',\n    '-s',\n    default=False,\n    is_flag=True,\n    help='instead of saving the graph file, render it with matplotlib',\n)\n@click.option(\n    '--classname',\n    default='.*',\n    help='Regex to filter by classname',\n)\n@click.option(\n    '--methodname',\n    default='.*',\n    help='Regex to filter by methodname',\n)\n@click.option(\n    '--descriptor',\n    default='.*',\n    help='Regex to filter by descriptor',\n)\n@click.option(\n    '--accessflag',\n    default='.*',\n    help='Regex to filter by accessflag',\n)\n@click.option(\n    '--no-isolated',\n    default=False,\n    is_flag=True,\n    help='Do not store methods which has no xrefs',\n)\ndef cg(\n    file_,\n    output,\n    output_type,\n    show,\n    classname,\n    methodname,\n    descriptor,\n    accessflag,\n    no_isolated,\n):\n    \"\"\"\n    Create a call graph based on the data of Analysis and export it into a graph format.\n    \"\"\"\n    import matplotlib.pyplot as plt\n\n    from androguard.core.analysis.analysis import ExternalMethod\n    from androguard.core.bytecode import FormatClassToJava\n    from androguard.misc import AnalyzeAPK\n\n    a, d, dx = AnalyzeAPK(file_)\n\n    entry_points = map(\n        FormatClassToJava,\n        a.get_activities()\n        + a.get_providers()\n        + a.get_services()\n        + a.get_receivers(),\n    )\n    entry_points = list(entry_points)\n\n    callgraph = dx.get_call_graph(\n        classname,\n        methodname,\n        descriptor,\n        accessflag,\n        no_isolated,\n        entry_points,\n    )\n\n    if show:\n        try:\n            import PyQt5\n        except ImportError:\n            print(\n                \"PyQt5 is not installed. In most OS you can install it by running 'pip install PyQt5'.\\n\"\n            )\n            exit()\n        pos = nx.spring_layout(callgraph)\n        internal = []\n        external = []\n\n        for n in callgraph:\n            if isinstance(n, ExternalMethod):\n                external.append(n)\n            else:\n                internal.append(n)\n\n        nx.draw_networkx_nodes(\n            callgraph, pos=pos, node_color='r', nodelist=internal\n        )\n\n        nx.draw_networkx_nodes(\n            callgraph, pos=pos, node_color='b', nodelist=external\n        )\n\n        nx.draw_networkx_edges(callgraph, pos, width=0.5, arrows=True)\n\n        nx.draw_networkx_labels(\n            callgraph,\n            pos=pos,\n            font_size=6,\n            labels={\n                n: f\"{n.get_class_name()} {n.name} {n.descriptor}\"\n                for n in callgraph.nodes\n            },\n        )\n\n        plt.draw()\n        plt.show()\n\n    else:\n        output_type_lower = output_type.lower()\n        if output_type_lower not in write_methods:\n            print(\n                f\"Could not find a method to export files to {output_type_lower}!\"\n            )\n            sys.exit(1)\n\n        write_methods[output_type_lower](callgraph, output)\n</code></pre>"},{"location":"reference/androguard/cli/cli.html#androguard.cli.cli.decompile","title":"<code>decompile(input_, file_, output, format_, jar, limit, decompiler)</code>","text":"<p>Decompile an APK and create Control Flow Graphs.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; androguard resources.arsc\n</code></pre> Source code in <code>androguard/cli/cli.py</code> <pre><code>@entry_point.command()\n@click.option(\n    '--input',\n    '-i',\n    'input_',\n    type=click.Path(exists=True, dir_okay=False, file_okay=True),\n    help='APK to parse (legacy option)',\n)\n@click.argument(\n    'file_',\n    type=click.Path(exists=True, dir_okay=False, file_okay=True),\n    required=False,\n)\n@click.option(\n    '--output',\n    '-o',\n    required=True,\n    help='output directory. If the output folder already exsist, '\n    'it will be overwritten!',\n)\n@click.option(\n    '--format',\n    '-f',\n    'format_',\n    help='Additionally write control flow graphs for each method, specify '\n    'the format for example png, jpg, raw (write dot file), ...',\n    type=click.Choice(['png', 'jpg', 'raw']),\n)\n@click.option(\n    '--jar',\n    '-j',\n    is_flag=True,\n    default=False,\n    help='Use DEX2JAR to create a JAR file',\n)\n@click.option(\n    '--limit',\n    '-l',\n    help='Limit to certain methods only by regex (default: \\'.*\\')',\n)\n@click.option(\n    '--decompiler',\n    '-d',\n    help='Use a different decompiler (default: DAD)',\n)\ndef decompile(input_, file_, output, format_, jar, limit, decompiler):\n    \"\"\"\n    Decompile an APK and create Control Flow Graphs.\n\n    Example:\n\n        &gt;&gt;&gt; androguard resources.arsc\n    \"\"\"\n    from androguard import session\n\n    if file_ and input_:\n        print(\n            \"Can not give --input and positional argument! \"\n            \"Please use only one of them!\",\n            file=sys.stderr,\n        )\n        sys.exit(1)\n\n    if not input_ and not file_:\n        print(\"Give one file to decode!\", file=sys.stderr)\n        sys.exit(1)\n\n    if input_:\n        fname = input_\n    else:\n        fname = file_\n\n    s = session.Session()\n    with open(fname, \"rb\") as fd:\n        s.add(fname, fd.read())\n    export_apps_to_format(fname, s, output, limit, jar, decompiler, format_)\n</code></pre>"},{"location":"reference/androguard/cli/cli.html#androguard.cli.cli.disassemble","title":"<code>disassemble(offset, size, dex)</code>","text":"<p>Disassemble Dalvik Code with size SIZE starting from an offset</p> Source code in <code>androguard/cli/cli.py</code> <pre><code>@entry_point.command()\n@click.option(\n    \"-o\",\n    \"--offset\",\n    default=0,\n    type=int,\n    help=\"Offset to start dissassembly inside the file\",\n)\n@click.option(\n    \"-s\",\n    \"--size\",\n    default=0,\n    type=int,\n    help=\"Number of bytes from offset to disassemble, 0 for whole file\",\n)\n@click.argument(\n    \"DEX\",\n    type=click.Path(exists=True, dir_okay=False, file_okay=True),\n)\ndef disassemble(offset, size, dex):\n    \"\"\"\n    Disassemble Dalvik Code with size SIZE starting from an offset\n    \"\"\"\n    androdis_main(offset, size, dex)\n</code></pre>"},{"location":"reference/androguard/cli/cli.html#androguard.cli.cli.dtrace","title":"<code>dtrace(package_name, modules)</code>","text":"<p>Start dynamically an installed APK on the phone and start to trace all interesting methods from the modules list</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; androguard dtrace package_name -m \"ipc/*\"  -m \"webviews/*\" -m \"modules/**\"\n</code></pre> Source code in <code>androguard/cli/cli.py</code> <pre><code>@entry_point.command()\n@click.argument(\n    'package_name',\n    default=None,\n    required=False,\n)\n@click.option(\n    \"-m\",\n    \"--modules\",\n    multiple=True,\n    default=[],\n    help=\"A list of modules to load in frida\",\n)\ndef dtrace(package_name, modules):\n    \"\"\"\n    Start dynamically an installed APK on the phone and start to trace all interesting methods from the modules list\n\n    Example:\n\n        &gt;&gt;&gt; androguard dtrace package_name -m \"ipc/*\"  -m \"webviews/*\" -m \"modules/**\"\n    \"\"\"\n    androtrace_main(package_name, modules, True)\n</code></pre>"},{"location":"reference/androguard/cli/cli.html#androguard.cli.cli.dump","title":"<code>dump(package_name, modules)</code>","text":"<p>Start and dump dynamically an installed APK on the phone</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; androguard dump package_name\n</code></pre> Source code in <code>androguard/cli/cli.py</code> <pre><code>@entry_point.command()\n@click.argument(\n    'package_name',\n    default=None,\n    required=False,\n)\n@click.option(\n    \"-m\",\n    \"--modules\",\n    multiple=True,\n    default=[\"androguard/pentest/modules/helpers/dump/dexdump.js\"],\n    help=\"A list of modules to load in frida\",\n)\ndef dump(package_name, modules):\n    \"\"\"\n    Start and dump dynamically an installed APK on the phone\n\n    Example:\n\n        &gt;&gt;&gt; androguard dump package_name\n    \"\"\"\n    androdump_main(package_name, modules)\n</code></pre>"},{"location":"reference/androguard/cli/cli.html#androguard.cli.cli.sign","title":"<code>sign(hash_, print_all_hashes, show, apk)</code>","text":"<p>Return the fingerprint(s) of all certificates inside an APK.</p> Source code in <code>androguard/cli/cli.py</code> <pre><code>@entry_point.command()\n@click.option(\n    '--hash',\n    'hash_',\n    type=click.Choice(['md5', 'sha1', 'sha256', 'sha512']),\n    default='sha1',\n    show_default=True,\n    help='Fingerprint Hash algorithm',\n)\n@click.option(\n    '--all',\n    '-a',\n    'print_all_hashes',\n    is_flag=True,\n    default=False,\n    show_default=True,\n    help='Print all supported hashes',\n)\n@click.option(\n    '--show',\n    '-s',\n    is_flag=True,\n    default=False,\n    show_default=True,\n    help='Additionally of printing the fingerprints, show more '\n    'certificate information',\n)\n@click.argument(\n    'apk',\n    nargs=-1,\n    type=click.Path(exists=True, dir_okay=False, file_okay=True),\n)\ndef sign(hash_, print_all_hashes, show, apk):\n    \"\"\"Return the fingerprint(s) of all certificates inside an APK.\"\"\"\n    androsign_main(apk, hash_, print_all_hashes, show)\n</code></pre>"},{"location":"reference/androguard/cli/cli.html#androguard.cli.cli.trace","title":"<code>trace(apk, modules, enable_ui)</code>","text":"<p>Push an APK on the phone and start to trace all interesting methods from the modules list</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; androguard trace test.APK -m \"ipc/*\"  -m \"webviews/*\" -m \"modules/**\"\n&gt;&gt;&gt; androguard trace test.APK -m \"ipc/*\"  -m \"webviews/*\" -m \"modules/**\" --enable-ui\n</code></pre> Source code in <code>androguard/cli/cli.py</code> <pre><code>@entry_point.command()\n@click.argument(\n    'apk',\n    default=None,\n    required=False,\n    type=click.Path(exists=True, dir_okay=False, file_okay=True),\n)\n@click.option(\n    \"-m\",\n    \"--modules\",\n    multiple=True,\n    default=[],\n    help=\"A list of modules to load in frida\",\n)\n@click.option(\n    '--enable-ui',\n    is_flag=True,\n    default=False,\n    help='Enable UI',\n)\ndef trace(apk, modules, enable_ui):\n    \"\"\"\n    Push an APK on the phone and start to trace all interesting methods from the modules list\n\n    Example:\n\n        &gt;&gt;&gt; androguard trace test.APK -m \"ipc/*\"  -m \"webviews/*\" -m \"modules/**\"\n        &gt;&gt;&gt; androguard trace test.APK -m \"ipc/*\"  -m \"webviews/*\" -m \"modules/**\" --enable-ui\n    \"\"\"\n    androtrace_main(apk, modules, False, enable_ui)\n</code></pre>"},{"location":"reference/androguard/cli/main.html","title":"main","text":""},{"location":"reference/androguard/cli/main.html#androguard.cli.main.androlyze_main","title":"<code>androlyze_main(session, filename)</code>","text":"<p>Start an interactive shell</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Session</code> <p>Session file to load</p> required <code>filename</code> <code>str</code> <p>File to analyze, can be APK or DEX (or ODEX)</p> required Source code in <code>androguard/cli/main.py</code> <pre><code>def androlyze_main(session: Session, filename: str) -&gt; None:\n    \"\"\"\n    Start an interactive shell\n\n    :param session: Session file to load\n    :param filename: File to analyze, can be APK or DEX (or ODEX)\n    \"\"\"\n    import atexit\n\n    import colorama\n    from colorama import Fore\n    from IPython.terminal.embed import embed\n    from traitlets.config import Config\n\n    from androguard.core.androconf import ANDROGUARD_VERSION, CONF\n    from androguard.session import Session\n\n    colorama.init()\n\n    if session:\n        logger.info(\"TODO: Restoring session '{}'...\".format(session))\n        # s = CONF['SESSION'] = Load(session)\n        # logger.info(\"Successfully restored {}\".format(s))\n        # TODO actually restore the session a, d, dx etc...\n    else:\n        s = CONF[\"SESSION\"] = Session(export_ipython=True)\n\n    if filename:\n        (\"Loading apk {}...\".format(os.path.basename(filename)))\n        logger.info(\"Please be patient, this might take a while.\")\n\n        filetype = androconf.is_android(filename)\n\n        logger.info(\"Found the provided file is of type '{}'\".format(filetype))\n\n        if filetype not in ['DEX', 'DEY', 'APK']:\n            logger.error(\n                Fore.RED\n                + \"This file type is not supported by androlyze for auto loading right now!\"\n                + Fore.RESET,\n                file=sys.stderr,\n            )\n            logger.error(\"But your file is still available:\")\n            logger.error(\"&gt;&gt;&gt; filename\")\n            logger.error(repr(filename))\n            print()\n\n        else:\n            with open(filename, \"rb\") as fp:\n                raw = fp.read()\n\n            h = s.add(filename, raw)\n            logger.info(\"Added file to session: SHA256::{}\".format(h))\n\n            if filetype == 'APK':\n                logger.info(\"Loaded APK file...\")\n                a, d, dx = s.get_objects_apk(digest=h)\n\n                print(\"&gt;&gt;&gt; filename\")\n                print(filename)\n                print(\"&gt;&gt;&gt; a\")\n                print(a)\n                print(\"&gt;&gt;&gt; d\")\n                print(d)\n                print(\"&gt;&gt;&gt; dx\")\n                print(dx)\n                print()\n            elif filetype in ['DEX', 'DEY']:\n                logger.info(\"Loaded DEX file...\")\n                for h_, d, dx in s.get_objects_dex():\n                    if h == h_:\n                        break\n                print(\"&gt;&gt;&gt; d\")\n                print(d)\n                print(\"&gt;&gt;&gt; dx\")\n                print(dx)\n                print()\n\n    def shutdown_hook() -&gt; None:\n        \"\"\"Save the session on exit, if wanted\"\"\"\n        if not s.isOpen():\n            return\n\n        try:\n            res = input(\"Do you want to save the session? (y/[n])?\").lower()\n        except (EOFError, KeyboardInterrupt):\n            pass\n        else:\n            if res == \"y\":\n                # TODO: if we already started from a session, probably we want to save it under the same name...\n                # TODO: be able to take any filename you want\n                fname = s.save()\n                print(\"Saved Session to file: '{}'\".format(fname))\n\n    cfg = Config()\n    _version_string = \"Androguard version {}\".format(ANDROGUARD_VERSION)\n    ipshell = embed(config=cfg, banner1=\"{} started\".format(_version_string))\n    atexit.register(shutdown_hook)\n    ipshell()\n</code></pre>"},{"location":"reference/androguard/core/index.html","title":"core","text":""},{"location":"reference/androguard/core/androconf.html","title":"androconf","text":""},{"location":"reference/androguard/core/androconf.html#androguard.core.androconf.Configuration","title":"<code>Configuration</code>","text":"Source code in <code>androguard/core/androconf.py</code> <pre><code>class Configuration:\n    instance = None\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        A Wrapper for the CONF object\n        This creates a singleton, which has the same attributes everywhere.\n        \"\"\"\n        if not Configuration.instance:\n            Configuration.instance = default_conf\n\n    def __getattr__(self, item):\n        return getattr(self.instance, item)\n\n    def __getitem__(self, item):\n        return self.instance[item]\n\n    def __setitem__(self, key, value):\n        self.instance[key] = value\n\n    def __str__(self):\n        return str(self.instance)\n\n    def __repr__(self):\n        return repr(self.instance)\n</code></pre>"},{"location":"reference/androguard/core/androconf.html#androguard.core.androconf.Configuration.__init__","title":"<code>__init__()</code>","text":"<p>A Wrapper for the CONF object This creates a singleton, which has the same attributes everywhere.</p> Source code in <code>androguard/core/androconf.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    A Wrapper for the CONF object\n    This creates a singleton, which has the same attributes everywhere.\n    \"\"\"\n    if not Configuration.instance:\n        Configuration.instance = default_conf\n</code></pre>"},{"location":"reference/androguard/core/androconf.html#androguard.core.androconf.InvalidResourceError","title":"<code>InvalidResourceError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Invalid Resource Erorr is thrown by load_api_specific_resource_module</p> Source code in <code>androguard/core/androconf.py</code> <pre><code>class InvalidResourceError(Exception):\n    \"\"\"\n    Invalid Resource Erorr is thrown by [load_api_specific_resource_module][androguard.core.androconf.load_api_specific_resource_module]\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/androguard/core/androconf.html#androguard.core.androconf.color_range","title":"<code>color_range(startcolor, goalcolor, steps)</code>","text":"<p>wrapper for interpolate_tuple that accepts colors as html (<code>#CCCCC</code> and such)</p> <p>Parameters:</p> Name Type Description Default <code>startcolor</code> <code>tuple[int, int, int]</code> <p>the start RGB color tuple</p> required <code>goalcolor</code> <code>tuple[int, int, int]</code> <p>the goal RGB color tuple</p> required <code>steps</code> <code>int</code> <p>amount of steps</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>the interpolated RGB tuple</p> Source code in <code>androguard/core/androconf.py</code> <pre><code>def color_range(\n    startcolor: tuple[int, int, int],\n    goalcolor: tuple[int, int, int],\n    steps: int,\n) -&gt; list[str]:\n    \"\"\"\n    wrapper for interpolate_tuple that accepts colors as html (`#CCCCC` and such)\n\n    :param startcolor: the start RGB color tuple\n    :param goalcolor: the goal RGB color tuple\n    :param steps: amount of steps\n    :returns: the interpolated RGB tuple\n    \"\"\"\n    start_tuple = make_color_tuple(startcolor)\n    goal_tuple = make_color_tuple(goalcolor)\n\n    return interpolate_tuple(start_tuple, goal_tuple, steps)\n</code></pre>"},{"location":"reference/androguard/core/androconf.html#androguard.core.androconf.interpolate_tuple","title":"<code>interpolate_tuple(startcolor, goalcolor, steps)</code>","text":"<p>Take two RGB color sets and mix them over a specified number of steps.  Return the list</p> Source code in <code>androguard/core/androconf.py</code> <pre><code>def interpolate_tuple(\n    startcolor: tuple[int, int, int],\n    goalcolor: tuple[int, int, int],\n    steps: int,\n) -&gt; list[str]:\n    \"\"\"\n    Take two RGB color sets and mix them over a specified number of steps.  Return the list\n    \"\"\"\n    # white\n\n    R = startcolor[0]\n    G = startcolor[1]\n    B = startcolor[2]\n\n    targetR = goalcolor[0]\n    targetG = goalcolor[1]\n    targetB = goalcolor[2]\n\n    DiffR = targetR - R\n    DiffG = targetG - G\n    DiffB = targetB - B\n\n    buffer = []\n\n    for i in range(0, steps + 1):\n        iR = R + (DiffR * i // steps)\n        iG = G + (DiffG * i // steps)\n        iB = B + (DiffB * i // steps)\n\n        hR = str.replace(hex(iR), \"0x\", \"\")\n        hG = str.replace(hex(iG), \"0x\", \"\")\n        hB = str.replace(hex(iB), \"0x\", \"\")\n\n        if len(hR) == 1:\n            hR = \"0\" + hR\n        if len(hB) == 1:\n            hB = \"0\" + hB\n\n        if len(hG) == 1:\n            hG = \"0\" + hG\n\n        color = str.upper(\"#\" + hR + hG + hB)\n        buffer.append(color)\n\n    return buffer\n</code></pre>"},{"location":"reference/androguard/core/androconf.html#androguard.core.androconf.is_android","title":"<code>is_android(filename)</code>","text":"<p>Return the type of the file</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>the filename</p> required <p>Returns:</p> Type Description <code>str</code> <p>\"APK\", \"DEX\", None</p> Source code in <code>androguard/core/androconf.py</code> <pre><code>def is_android(filename: str) -&gt; str:\n    \"\"\"\n    Return the type of the file\n\n    :param filename: the filename\n    :returns: \"APK\", \"DEX\", None\n    \"\"\"\n    if not filename:\n        return None\n\n    with open(filename, \"rb\") as fd:\n        f_bytes = fd.read()\n        return is_android_raw(f_bytes)\n</code></pre>"},{"location":"reference/androguard/core/androconf.html#androguard.core.androconf.is_android_raw","title":"<code>is_android_raw(raw)</code>","text":"<p>Returns a string that describes the type of file, for common Android specific formats</p> <p>Parameters:</p> Name Type Description Default <code>raw</code> <code>bytes</code> <p>the file bytes to check</p> required <p>Returns:</p> Type Description <code>str</code> <p>the type of file</p> Source code in <code>androguard/core/androconf.py</code> <pre><code>def is_android_raw(raw: bytes) -&gt; str:\n    \"\"\"\n    Returns a string that describes the type of file, for common Android\n    specific formats\n\n    :param raw: the file bytes to check\n    :returns: the type of file\n    \"\"\"\n    val = None\n\n    # We do not check for META-INF/MANIFEST.MF,\n    # as you also want to analyze unsigned APKs...\n    # AndroidManifest.xml should be in every APK.\n    # classes.dex and resources.arsc are not required!\n    # if raw[0:2] == b\"PK\" and b'META-INF/MANIFEST.MF' in raw:\n    # TODO this check might be still invalid. A ZIP file with stored APK inside would match as well.\n    # probably it would be better to rewrite this and add more sanity checks.\n    if raw[0:2] == b\"PK\" and b'AndroidManifest.xml' in raw:\n        val = \"APK\"\n        # check out\n    elif raw[0:3] == b\"dex\":\n        val = \"DEX\"\n    elif raw[0:3] == b\"dey\":\n        val = \"DEY\"\n    elif raw[0:4] == b\"\\x03\\x00\\x08\\x00\" or raw[0:4] == b\"\\x00\\x00\\x08\\x00\":\n        val = \"AXML\"\n    elif raw[0:4] == b\"\\x02\\x00\\x0C\\x00\":\n        val = \"ARSC\"\n\n    return val\n</code></pre>"},{"location":"reference/androguard/core/androconf.html#androguard.core.androconf.is_ascii_problem","title":"<code>is_ascii_problem(s)</code>","text":"<p>Test if a string contains other chars than ASCII</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>a string to test</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if string contains other chars than ASCII, <code>False</code> otherwise</p> Source code in <code>androguard/core/androconf.py</code> <pre><code>def is_ascii_problem(s: str) -&gt; bool:\n    \"\"\"\n    Test if a string contains other chars than ASCII\n\n    :param s: a string to test\n    :returns: `True` if string contains other chars than ASCII, `False` otherwise\n    \"\"\"\n    try:\n        # As MUTF8Strings are actually bytes, we can simply check if they are ASCII or not\n        s.decode(\"ascii\")\n        return False\n    except (UnicodeEncodeError, UnicodeDecodeError):\n        return True\n</code></pre>"},{"location":"reference/androguard/core/androconf.html#androguard.core.androconf.load_api_specific_resource_module","title":"<code>load_api_specific_resource_module(resource_name, api=None)</code>","text":"<p>Load the module from the JSON files and return a dict, which might be empty if the resource could not be loaded.</p> <p>If no api version is given, the default one from the CONF dict is used.</p> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>Name of the resource to load</p> required <code>api</code> <code>Union[str, int, None]</code> <p>API version</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>dict</p> <p>Raises:</p> Type Description <code>InvalidResourceError</code> <p>if resource not found</p> Source code in <code>androguard/core/androconf.py</code> <pre><code>def load_api_specific_resource_module(\n    resource_name: str, api: Union[str, int, None] = None\n) -&gt; dict:\n    \"\"\"\n    Load the module from the JSON files and return a dict, which might be empty\n    if the resource could not be loaded.\n\n    If no api version is given, the default one from the CONF dict is used.\n\n    :param resource_name: Name of the resource to load\n    :param api: API version\n    :raises InvalidResourceError: if resource not found\n    :returns: dict\n    \"\"\"\n    loader = dict(\n        aosp_permissions=load_permissions,\n        api_permission_mappings=load_permission_mappings,\n    )\n\n    if resource_name not in loader:\n        raise InvalidResourceError(\n            \"Invalid Resource '{}', not in [{}]\".format(\n                resource_name, \", \".join(loader.keys())\n            )\n        )\n\n    if not api:\n        api = CONF[\"DEFAULT_API\"]\n\n    ret = loader[resource_name](api)\n\n    if ret == {}:\n        # No API mapping found, return default\n        logger.warning(\n            \"API mapping for API level {} was not found! \"\n            \"Returning default, which is API level {}\".format(\n                api, CONF['DEFAULT_API']\n            )\n        )\n        ret = loader[resource_name](CONF['DEFAULT_API'])\n\n    return ret\n</code></pre>"},{"location":"reference/androguard/core/androconf.html#androguard.core.androconf.make_color_tuple","title":"<code>make_color_tuple(color)</code>","text":"<p>turn something like <code>#000000</code> into <code>0,0,0</code> or <code>#FFFFFF</code> into <code>255,255,255</code></p> Source code in <code>androguard/core/androconf.py</code> <pre><code>def make_color_tuple(color: str) -&gt; tuple[int, int, int]:\n    \"\"\"\n    turn something like `#000000` into `0,0,0`\n    or `#FFFFFF` into `255,255,255`\n    \"\"\"\n    R = color[1:3]\n    G = color[3:5]\n    B = color[5:7]\n\n    R = int(R, 16)\n    G = int(G, 16)\n    B = int(B, 16)\n\n    return R, G, B\n</code></pre>"},{"location":"reference/androguard/core/androconf.html#androguard.core.androconf.rrmdir","title":"<code>rrmdir(directory)</code>","text":"<p>Recursively delete a directory</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>directory to remove</p> required Source code in <code>androguard/core/androconf.py</code> <pre><code>def rrmdir(directory: str) -&gt; None:\n    \"\"\"\n    Recursively delete a directory\n\n    :param directory: directory to remove\n    \"\"\"\n    for root, dirs, files in os.walk(directory, topdown=False):\n        for name in files:\n            os.remove(os.path.join(root, name))\n        for name in dirs:\n            os.rmdir(os.path.join(root, name))\n    os.rmdir(directory)\n</code></pre>"},{"location":"reference/androguard/core/bytecode.html","title":"bytecode","text":""},{"location":"reference/androguard/core/bytecode.html#androguard.core.bytecode.FormatClassToJava","title":"<code>FormatClassToJava(i)</code>","text":"<p>Transform a java class name into the typed variant found in DEX files.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; FormatClassToJava('java.lang.Object')\n'Ljava/lang/Object;'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>str</code> <p>the input class name</p> required <p>Returns:</p> Type Description <code>str</code> <p>the formatted string</p> Source code in <code>androguard/core/bytecode.py</code> <pre><code>def FormatClassToJava(i: str) -&gt; str:\n    \"\"\"\n    Transform a java class name into the typed variant found in DEX files.\n\n    Example:\n\n        &gt;&gt;&gt; FormatClassToJava('java.lang.Object')\n        'Ljava/lang/Object;'\n\n    :param i: the input class name\n    :returns: the formatted string\n    \"\"\"\n    return \"L\" + i.replace(\".\", \"/\") + \";\"\n</code></pre>"},{"location":"reference/androguard/core/bytecode.html#androguard.core.bytecode.FormatClassToPython","title":"<code>FormatClassToPython(i)</code>","text":"<p>Transform a typed class name into a form which can be used as a python attribute</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; FormatClassToPython('Lfoo/bar/foo/Barfoo$InnerClass;')\n'Lfoo_bar_foo_Barfoo_InnerClass'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>str</code> <p>classname to transform</p> required <p>Returns:</p> Type Description <code>str</code> <p>the formatted string</p> Source code in <code>androguard/core/bytecode.py</code> <pre><code>def FormatClassToPython(i: str) -&gt; str:\n    \"\"\"\n    Transform a typed class name into a form which can be used as a python\n    attribute\n\n    Example:\n\n        &gt;&gt;&gt; FormatClassToPython('Lfoo/bar/foo/Barfoo$InnerClass;')\n        'Lfoo_bar_foo_Barfoo_InnerClass'\n\n    :param i: classname to transform\n    :returns: the formatted string\n    \"\"\"\n    i = i[:-1]\n    i = i.replace(\"/\", \"_\")\n    i = i.replace(\"$\", \"_\")\n\n    return i\n</code></pre>"},{"location":"reference/androguard/core/bytecode.html#androguard.core.bytecode.FormatDescriptorToPython","title":"<code>FormatDescriptorToPython(i)</code>","text":"<p>Format a descriptor into a form which can be used as a python attribute</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; FormatDescriptorToPython('(Ljava/lang/Long; Ljava/lang/Long; Z Z)V')\n'Ljava_lang_LongLjava_lang_LongZZV\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>str</code> <p>name to transform</p> required <p>Returns:</p> Type Description <code>str</code> <p>the formatted descriptor string</p> Source code in <code>androguard/core/bytecode.py</code> <pre><code>def FormatDescriptorToPython(i: str) -&gt; str:\n    \"\"\"\n    Format a descriptor into a form which can be used as a python attribute\n\n    Example:\n\n        &gt;&gt;&gt; FormatDescriptorToPython('(Ljava/lang/Long; Ljava/lang/Long; Z Z)V')\n        'Ljava_lang_LongLjava_lang_LongZZV\n\n    :param i: name to transform\n    :returns: the formatted descriptor string\n    \"\"\"\n\n    i = i.replace(\"/\", \"_\")\n    i = i.replace(\";\", \"\")\n    i = i.replace(\"[\", \"\")\n    i = i.replace(\"(\", \"\")\n    i = i.replace(\")\", \"\")\n    i = i.replace(\" \", \"\")\n    i = i.replace(\"$\", \"\")\n\n    return i\n</code></pre>"},{"location":"reference/androguard/core/bytecode.html#androguard.core.bytecode.FormatNameToPython","title":"<code>FormatNameToPython(i)</code>","text":"<p>Transform a (method) name into a form which can be used as a python attribute</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; FormatNameToPython('&lt;clinit&gt;')\n'clinit'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>str</code> <p>name to transform</p> required <p>Returns:</p> Type Description <code>str</code> <p>the transformed name</p> Source code in <code>androguard/core/bytecode.py</code> <pre><code>def FormatNameToPython(i: str) -&gt; str:\n    \"\"\"\n    Transform a (method) name into a form which can be used as a python\n    attribute\n\n    Example:\n\n        &gt;&gt;&gt; FormatNameToPython('&lt;clinit&gt;')\n        'clinit'\n\n    :param i: name to transform\n    :returns: the transformed name\n    \"\"\"\n\n    i = i.replace(\"&lt;\", \"\")\n    i = i.replace(\"&gt;\", \"\")\n    i = i.replace(\"$\", \"_\")\n\n    return i\n</code></pre>"},{"location":"reference/androguard/core/bytecode.html#androguard.core.bytecode.get_package_class_name","title":"<code>get_package_class_name(name)</code>","text":"<p>Return package and class name in a java variant from a typed variant name.</p> <p>If no package could be found, the package is an empty string.</p> <p>If the name is an array type, the array is discarded.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; get_package_class_name('Ljava/lang/Object;')\n('java.lang', 'Object')\n&gt;&gt;&gt; get_package_class_name('[[Ljava/lang/Object;')\n('java.lang', 'Object')\n&gt;&gt;&gt; get_package_class_name('LSomeClass;')\n('', 'SomeClass')\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name</p> required <p>Returns:</p> Type Description <code>tuple[str, str]</code> <p>the formatted package class name</p> Source code in <code>androguard/core/bytecode.py</code> <pre><code>def get_package_class_name(name: str) -&gt; tuple[str, str]:\n    \"\"\"\n    Return package and class name in a java variant from a typed variant name.\n\n    If no package could be found, the package is an empty string.\n\n    If the name is an array type, the array is discarded.\n\n    Example:\n\n        &gt;&gt;&gt; get_package_class_name('Ljava/lang/Object;')\n        ('java.lang', 'Object')\n        &gt;&gt;&gt; get_package_class_name('[[Ljava/lang/Object;')\n        ('java.lang', 'Object')\n        &gt;&gt;&gt; get_package_class_name('LSomeClass;')\n        ('', 'SomeClass')\n\n    :param name: the name\n    :returns: the formatted package class name\n    \"\"\"\n    # name is MUTF8, so make sure we get the string variant\n    name = str(name)\n    if name[-1] != ';':\n        raise ValueError(\n            \"The name '{}' does not look like a typed name!\".format(name)\n        )\n\n    # discard array types, there might be many...\n    name = name.lstrip('[')\n\n    if name[0] != 'L':\n        raise ValueError(\n            \"The name '{}' does not look like a typed name!\".format(name)\n        )\n\n    name = name[1:-1]\n    if '/' not in name:\n        return '', name\n\n    package, clsname = name.rsplit('/', 1)\n    package = package.replace('/', '.')\n\n    return package, clsname\n</code></pre>"},{"location":"reference/androguard/core/bytecode.html#androguard.core.bytecode.method2dot","title":"<code>method2dot(mx, colors=None)</code>","text":"<p>Export analysis method to dot format.</p> <p>A control flow graph is created by using the concept of BasicBlocks. Each BasicBlock is a sequence of opcode without any jumps or branch.</p> <p>Parameters:</p> Name Type Description Default <code>mx</code> <code>MethodAnalysis</code> <p><code>androguard.core.analysis.analysis.MethodAnalysis</code></p> required <code>colors</code> <code>Union[dict[str, str], None]</code> <p>dict of colors to use, if colors is <code>None</code> the default colors are used</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>a string which contains the dot graph</p> Source code in <code>androguard/core/bytecode.py</code> <pre><code>def method2dot(\n    mx: MethodAnalysis, colors: Union[dict[str, str], None] = None\n) -&gt; str:\n    \"\"\"\n    Export analysis method to dot format.\n\n    A control flow graph is created by using the concept of BasicBlocks.\n    Each BasicBlock is a sequence of opcode without any jumps or branch.\n\n    :param mx: `androguard.core.analysis.analysis.MethodAnalysis`\n    :param colors: dict of colors to use, if colors is `None` the default colors are used\n\n    :returns: a string which contains the dot graph\n    \"\"\"\n\n    font_face = \"monospace\"\n\n    if not colors:\n        colors = {\n            \"true_branch\": \"green\",\n            \"false_branch\": \"red\",\n            \"default_branch\": \"purple\",\n            \"jump_branch\": \"blue\",\n            \"bg_idx\": \"lightgray\",\n            \"idx\": \"blue\",\n            \"bg_start_idx\": \"yellow\",\n            \"bg_instruction\": \"lightgray\",\n            \"instruction_name\": \"black\",\n            \"instructions_operands\": \"yellow\",\n            \"raw\": \"red\",\n            \"string\": \"red\",\n            \"literal\": \"green\",\n            \"offset\": \"#4000FF\",\n            \"method\": \"#DF3A01\",\n            \"field\": \"#088A08\",\n            \"type\": \"#0000FF\",\n            \"registers_range\": (\"#999933\", \"#6666FF\"),\n        }\n\n    node_tpl = \"\"\"\n    struct_%s [label=&lt;\n        &lt;TABLE BORDER=\"0\" CELLBORDER=\"0\" CELLSPACING=\"3\"&gt;\n            %s\n        &lt;/TABLE&gt;\n    &gt;];\n    \"\"\"\n    label_tpl = \"\"\"\n    &lt;TR&gt;\n        &lt;TD ALIGN=\"LEFT\" BGCOLOR=\"%s\"&gt;\n            &lt;FONT FACE=\"{font_face}\" color=\"%s\"&gt;%04x&lt;/FONT&gt;\n        &lt;/TD&gt;\n        &lt;TD ALIGN=\"LEFT\" BGCOLOR=\"%s\"&gt;\n            &lt;FONT FACE=\"{font_face}\" color=\"%s\"&gt;%s&lt;/FONT&gt; %s\n        &lt;/TD&gt;\n    &lt;/TR&gt;\n    \"\"\".format(\n        font_face=font_face\n    )\n\n    link_tpl = '&lt;TR&gt;&lt;TD PORT=\"{}\"&gt;&lt;/TD&gt;&lt;/TR&gt;\\n'\n\n    edges_html = \"\"\n    blocks_html = \"\"\n\n    method = mx.get_method()\n\n    # This is used as a seed to create unique hashes for the nodes\n    sha256 = hashlib.sha256(\n        (\n            mx.get_method().get_class_name()\n            + mx.get_method().get_name()\n            + mx.get_method().get_descriptor()\n        ).encode(\"utf-8\")\n    ).hexdigest()\n\n    # Collect all used Registers and create colors\n    if method.get_code() and method.get_code().get_registers_size() != 0:\n        registers = {\n            i: c\n            for i, c in enumerate(\n                color_range(\n                    colors[\"registers_range\"][0],\n                    colors[\"registers_range\"][1],\n                    method.get_code().get_registers_size(),\n                )\n            )\n        }\n    else:\n        registers = dict()\n\n    new_links = []\n\n    # Go through all basic blocks and create the CFG\n    for basic_block in mx.basic_blocks:\n        ins_idx = basic_block.start\n        block_id = hashlib.md5(\n            (sha256 + basic_block.get_name()).encode(\"utf-8\")\n        ).hexdigest()\n\n        content = link_tpl.format('header')\n\n        for instruction in basic_block.get_instructions():\n            if instruction.get_op_value() in (0x2B, 0x2C):\n                new_links.append(\n                    (\n                        basic_block,\n                        ins_idx,\n                        instruction.get_ref_off() * 2 + ins_idx,\n                    )\n                )\n            elif instruction.get_op_value() == 0x26:\n                new_links.append(\n                    (\n                        basic_block,\n                        ins_idx,\n                        instruction.get_ref_off() * 2 + ins_idx,\n                    )\n                )\n\n            operands = instruction.get_operands(ins_idx)\n            output = \", \".join(\n                _get_operand_html(i, registers, colors) for i in operands\n            )\n\n            bg_idx = colors[\"bg_idx\"]\n            if ins_idx == 0 and \"bg_start_idx\" in colors:\n                bg_idx = colors[\"bg_start_idx\"]\n\n            content += label_tpl % (\n                bg_idx,\n                colors[\"idx\"],\n                ins_idx,\n                colors[\"bg_instruction\"],\n                colors[\"instruction_name\"],\n                instruction.get_name(),\n                output,\n            )\n\n            ins_idx += instruction.get_length()\n\n        # all blocks from one method parsed\n        # updating dot HTML content\n        content += link_tpl.format('tail')\n        blocks_html += node_tpl % (block_id, content)\n\n        # Block edges color treatment (conditional branchs colors)\n        val = colors[\"true_branch\"]\n        if len(basic_block.childs) &gt; 1:\n            val = colors[\"false_branch\"]\n        elif len(basic_block.childs) == 1:\n            val = colors[\"jump_branch\"]\n\n        values = None\n        # The last instruction is important and still set from the loop\n        # FIXME: what if there is no instruction in the basic block?\n        if (\n            instruction.get_op_value() in (0x2B, 0x2C)\n            and len(basic_block.childs) &gt; 1\n        ):\n            val = colors[\"default_branch\"]\n            values = [\"default\"]\n            values.extend(\n                basic_block.get_special_ins(\n                    ins_idx - instruction.get_length()\n                ).get_values()\n            )\n\n        # updating dot edges\n        for DVMBasicMethodBlockChild in basic_block.childs:\n            label_edge = \"\"\n\n            if values:\n                label_edge = values.pop(0)\n\n            child_id = hashlib.md5(\n                (sha256 + DVMBasicMethodBlockChild[-1].get_name()).encode(\n                    \"utf-8\"\n                )\n            ).hexdigest()\n            edges_html += \"struct_{}:tail -&gt; struct_{}:header  [color=\\\"{}\\\", label=\\\"{}\\\"];\\n\".format(\n                block_id, child_id, val, label_edge\n            )\n\n            # color switch\n            if val == colors[\"false_branch\"]:\n                val = colors[\"true_branch\"]\n            elif val == colors[\"default_branch\"]:\n                val = colors[\"true_branch\"]\n\n        exception_analysis = basic_block.get_exception_analysis()\n        if exception_analysis:\n            for exception_elem in exception_analysis.exceptions:\n                exception_block = exception_elem[-1]\n                if exception_block:\n                    exception_id = hashlib.md5(\n                        (sha256 + exception_block.get_name()).encode(\"utf-8\")\n                    ).hexdigest()\n                    edges_html += \"struct_{}:tail -&gt; struct_{}:header  [color=\\\"{}\\\", label=\\\"{}\\\"];\\n\".format(\n                        block_id, exception_id, \"black\", exception_elem[0]\n                    )\n\n    for link in new_links:\n        basic_block = link[0]\n        DVMBasicMethodBlockChild = mx.basic_blocks.get_basic_block(link[2])\n\n        if DVMBasicMethodBlockChild:\n            block_id = hashlib.md5(\n                (sha256 + basic_block.get_name()).encode(\"utf-8\")\n            ).hexdigest()\n            child_id = hashlib.md5(\n                (sha256 + DVMBasicMethodBlockChild.get_name()).encode(\"utf-8\")\n            ).hexdigest()\n\n            edges_html += \"struct_{}:tail -&gt; struct_{}:header  [color=\\\"{}\\\", label=\\\"data(0x{:x}) to @0x{:x}\\\", style=\\\"dashed\\\"];\\n\".format(\n                block_id, child_id, \"yellow\", link[1], link[2]\n            )\n\n    method_label = (\n        method.get_class_name()\n        + \".\"\n        + method.get_name()\n        + \"-&gt;\"\n        + method.get_descriptor()\n    )\n\n    method_information = method.get_information()\n    if method_information:\n        method_label += \"\\\\nLocal registers v{} ... v{}\".format(\n            *method_information[\"registers\"]\n        )\n        if \"params\" in method_information:\n            for register, rtype in method_information[\"params\"]:\n                method_label += \"\\\\nparam v%d = %s\" % (register, rtype)\n        method_label += \"\\\\nreturn = %s\" % (method_information[\"return\"])\n\n    return {'name': method_label, 'nodes': blocks_html, 'edges': edges_html}\n</code></pre>"},{"location":"reference/androguard/core/bytecode.html#androguard.core.bytecode.method2format","title":"<code>method2format(output, _format='png', mx=None, raw=None)</code>","text":"<p>Export method structure as a graph to a specific file format using dot from the graphviz package. The result is written to the file specified via <code>output</code>.</p> <p>There are two possibilites to give input for this method:</p> <p>1) use <code>raw</code> argument and pass a dictionary containing the keys <code>name</code>, <code>nodes</code> and <code>edges</code>. This can be created using method2dot.</p> <p>2) give a MethodAnalysis.</p> <p>This function requires pydot!</p> <p>There is a special format <code>raw</code> which saves the dot buffer before it is handled by pydot.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>output filename</p> required <code>_format</code> <code>str</code> <p>format type (png, jpg ...). Can use all formats which are understood by pydot.</p> <code>'png'</code> <code>mx</code> <code>Union[MethodAnalysis, None]</code> <p>specify the <code>MethodAnalysis</code> object</p> <code>None</code> <code>raw</code> <code>Union[str, None]</code> <p>use directly a dot raw buffer if None</p> <code>None</code> Source code in <code>androguard/core/bytecode.py</code> <pre><code>def method2format(\n    output: str,\n    _format: str = \"png\",\n    mx: Union[MethodAnalysis, None] = None,\n    raw: Union[str, None] = None,\n):\n    \"\"\"\n    Export method structure as a graph to a specific file format using dot from the graphviz package.\n    The result is written to the file specified via `output`.\n\n    There are two possibilites to give input for this method:\n\n    1) use `raw` argument and pass a dictionary containing the keys\n    `name`, `nodes` and `edges`. This can be created using [method2dot][androguard.core.bytecode.method2dot].\n\n\n    2) give a [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis].\n\n    This function requires pydot!\n\n    There is a special format `raw` which saves the dot buffer before it\n    is handled by pydot.\n\n    :param output: output filename\n    :param _format: format type (png, jpg ...). Can use all formats which are understood by pydot.\n    :param mx: specify the `MethodAnalysis` object\n    :param raw: use directly a dot raw buffer if None\n    \"\"\"\n    # pydot is optional, it's only needed for png, jpg formats\n    import pydot\n\n    if raw:\n        data = raw\n    else:\n        data = method2dot(mx)\n\n    buff = \"\"\"\n    digraph {{\n        graph [rankdir=TB]\n        node [shape=plaintext]\n\n        subgraph cluster_{clustername}\n        {{\n            label=\"{classname}\"\n            {nodes}\n        }}\n\n        {edges}\n    }}\n    \"\"\".format(\n        clustername=hashlib.md5(output.encode(\"UTF-8\")).hexdigest(),\n        classname=data['name'],\n        nodes=data['nodes'],\n        edges=data['edges'],\n    )\n\n    # NOTE: In certain cases the graph_from_dot_data function might fail.\n    # There is a bug in the code that certain html strings are interpreted as comment\n    # and therefore the dot buffer which is passed to graphviz is invalid.\n    # We can not really do anything here to prevent this (except for heavily\n    # escaping and replacing all characters).\n    # We hope, that this issue get's fixed in pydot, so we do not need to patch\n    # stuff here.\n    # In order to be able to debug the problems better, we will write the dot\n    # data here if the format `raw` is requested, instead of creating the graph\n    # and then writing the dot data.\n    # If you have problems with certain data, export it as dot and then run\n    # graphviz manually to see if the problem persists.\n    if _format == \"raw\":\n        with open(output, \"w\") as fp:\n            fp.write(buff)\n    else:\n        d = pydot.graph_from_dot_data(buff)\n        if len(d) &gt; 1:\n            # Not sure what to do in this case?!\n            logger.warning(\n                \"The graph generated for '{}' has too many subgraphs! \"\n                \"Only plotting the first one.\".format(output)\n            )\n        for g in d:\n            try:\n                getattr(g, \"write_\" + _format.lower())(output)\n                break\n            except FileNotFoundError:\n                logger.error(\n                    \"Could not write graph image, ensure graphviz is installed!\"\n                )\n                raise\n</code></pre>"},{"location":"reference/androguard/core/bytecode.html#androguard.core.bytecode.method2jpg","title":"<code>method2jpg(output, mx, raw=None)</code>","text":"<p>Export method to a jpg file format</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>output filename</p> required <code>mx</code> <code>MethodAnalysis</code> <p>specify the <code>MethodAnalysis</code> object</p> required <code>raw</code> <code>Union[str, None]</code> <p>use directly a dot raw buffer (optional)</p> <code>None</code> Source code in <code>androguard/core/bytecode.py</code> <pre><code>def method2jpg(\n    output: str, mx: MethodAnalysis, raw: Union[str, None] = None\n) -&gt; None:\n    \"\"\"\n    Export method to a jpg file format\n\n    :param output: output filename\n    :param mx: specify the `MethodAnalysis` object\n    :param raw: use directly a dot raw buffer (optional)\n    \"\"\"\n    buff = raw\n    if not raw:\n        buff = method2dot(mx)\n\n    method2format(output, \"jpg\", mx, buff)\n</code></pre>"},{"location":"reference/androguard/core/bytecode.html#androguard.core.bytecode.method2json","title":"<code>method2json(mx, directed_graph=False)</code>","text":"<p>Create directed or undirected graph in the json format.</p> <p>Parameters:</p> Name Type Description Default <code>mx</code> <code>MethodAnalysis</code> <p><code>androguard.core.analysis.analysis.MethodAnalysis</code></p> required <code>directed_graph</code> <code>bool</code> <p><code>True</code> if a directed graph should be created (default: <code>False</code>)</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>json str</p> Source code in <code>androguard/core/bytecode.py</code> <pre><code>def method2json(mx: MethodAnalysis, directed_graph: bool = False) -&gt; str:\n    \"\"\"\n    Create directed or undirected graph in the json format.\n\n    :param mx: `androguard.core.analysis.analysis.MethodAnalysis`\n    :param directed_graph: `True` if a directed graph should be created (default: `False`)\n    :returns: json str\n    \"\"\"\n    if directed_graph:\n        return method2json_direct(mx)\n    return method2json_undirect(mx)\n</code></pre>"},{"location":"reference/androguard/core/bytecode.html#androguard.core.bytecode.method2json_direct","title":"<code>method2json_direct(mx)</code>","text":"<p>Create a directed graph in the json format</p> <p>Parameters:</p> Name Type Description Default <code>mx</code> <code>MethodAnalysis</code> <p><code>androguard.core.analysis.analysis.MethodAnalysis</code></p> required <p>Returns:</p> Type Description <code>str</code> <p>the method json string</p> Source code in <code>androguard/core/bytecode.py</code> <pre><code>def method2json_direct(mx: MethodAnalysis) -&gt; str:\n    \"\"\"\n    Create a directed graph in the json format\n\n    :param mx: `androguard.core.analysis.analysis.MethodAnalysis`\n    :returns: the method json string\n    \"\"\"\n    d = {}\n    reports = []\n    d[\"reports\"] = reports\n\n    hooks = {}\n\n    l = []\n    for DVMBasicMethodBlock in mx.basic_blocks.gets():\n        for index, DVMBasicMethodBlockChild in enumerate(\n            DVMBasicMethodBlock.childs\n        ):\n            if (\n                DVMBasicMethodBlock.get_name()\n                == DVMBasicMethodBlockChild[-1].get_name()\n            ):\n\n                preblock = TmpBlock(DVMBasicMethodBlock.get_name() + \"-pre\")\n\n                cnblock = {\n                    \"BasicBlockId\": DVMBasicMethodBlock.get_name() + \"-pre\",\n                    \"start\": DVMBasicMethodBlock.start,\n                    \"notes\": [],\n                    \"Edge\": [DVMBasicMethodBlock.get_name()],\n                    \"registers\": 0,\n                    \"instructions\": [],\n                    \"info_bb\": 0,\n                }\n\n                l.append(cnblock)\n\n                for parent in DVMBasicMethodBlock.fathers:\n                    hooks[parent[-1].get_name()] = []\n                    hooks[parent[-1].get_name()].append(preblock)\n\n                    for idx, child in enumerate(parent[-1].childs):\n                        if (\n                            child[-1].get_name()\n                            == DVMBasicMethodBlock.get_name()\n                        ):\n                            hooks[parent[-1].get_name()].append(child[-1])\n\n    for DVMBasicMethodBlock in mx.basic_blocks.gets():\n        cblock = {\n            \"BasicBlockId\": DVMBasicMethodBlock.get_name(),\n            \"start\": DVMBasicMethodBlock.start,\n            \"notes\": DVMBasicMethodBlock.get_notes(),\n            \"registers\": mx.get_method().get_code().get_registers_size(),\n            \"instructions\": [],\n        }\n\n        ins_idx = DVMBasicMethodBlock.start\n        last_instru = None\n        for (\n            DVMBasicMethodBlockInstruction\n        ) in DVMBasicMethodBlock.get_instructions():\n            c_ins = {\n                \"idx\": ins_idx,\n                \"name\": DVMBasicMethodBlockInstruction.get_name(),\n                \"operands\": DVMBasicMethodBlockInstruction.get_operands(\n                    ins_idx\n                ),\n            }\n\n            cblock[\"instructions\"].append(c_ins)\n\n            if (\n                DVMBasicMethodBlockInstruction.get_op_value() == 0x2B\n                or DVMBasicMethodBlockInstruction.get_op_value() == 0x2C\n            ):\n                values = DVMBasicMethodBlock.get_special_ins(ins_idx)\n                cblock[\"info_next\"] = values.get_values()\n\n            ins_idx += DVMBasicMethodBlockInstruction.get_length()\n            last_instru = DVMBasicMethodBlockInstruction\n\n        cblock[\"info_bb\"] = 0\n        if DVMBasicMethodBlock.childs:\n            if len(DVMBasicMethodBlock.childs) &gt; 1:\n                cblock[\"info_bb\"] = 1\n\n            if (\n                last_instru.get_op_value() == 0x2B\n                or last_instru.get_op_value() == 0x2C\n            ):\n                cblock[\"info_bb\"] = 2\n\n        cblock[\"Edge\"] = []\n        for DVMBasicMethodBlockChild in DVMBasicMethodBlock.childs:\n            ok = False\n            if DVMBasicMethodBlock.get_name() in hooks:\n                if (\n                    DVMBasicMethodBlockChild[-1]\n                    in hooks[DVMBasicMethodBlock.get_name()]\n                ):\n                    ok = True\n                    cblock[\"Edge\"].append(\n                        hooks[DVMBasicMethodBlock.get_name()][0].get_name()\n                    )\n\n            if not ok:\n                cblock[\"Edge\"].append(DVMBasicMethodBlockChild[-1].get_name())\n\n        exception_analysis = DVMBasicMethodBlock.get_exception_analysis()\n        if exception_analysis:\n            cblock[\"Exceptions\"] = exception_analysis.get()\n\n        reports.append(cblock)\n\n    reports.extend(l)\n\n    return json.dumps(d)\n</code></pre>"},{"location":"reference/androguard/core/bytecode.html#androguard.core.bytecode.method2json_undirect","title":"<code>method2json_undirect(mx)</code>","text":"<p>Create an undirected graph in the json format</p> <p>Parameters:</p> Name Type Description Default <code>mx</code> <code>MethodAnalysis</code> <p><code>androguard.core.analysis.analysis.MethodAnalysis</code></p> required <p>Returns:</p> Type Description <code>str</code> <p>json str</p> Source code in <code>androguard/core/bytecode.py</code> <pre><code>def method2json_undirect(mx: MethodAnalysis) -&gt; str:\n    \"\"\"\n    Create an undirected graph in the json format\n\n    :param mx: `androguard.core.analysis.analysis.MethodAnalysis`\n    :return: json str\n    \"\"\"\n    d = {}\n    reports = []\n    d[\"reports\"] = reports\n\n    for DVMBasicMethodBlock in mx.basic_blocks.gets():\n        cblock = {\n            \"BasicBlockId\": DVMBasicMethodBlock.get_name(),\n            \"registers\": mx.get_method().get_code().get_registers_size(),\n            \"instructions\": [],\n        }\n\n        ins_idx = DVMBasicMethodBlock.start\n        for (\n            DVMBasicMethodBlockInstruction\n        ) in DVMBasicMethodBlock.get_instructions():\n            c_ins = {\n                \"idx\": ins_idx,\n                \"name\": DVMBasicMethodBlockInstruction.get_name(),\n                \"operands\": DVMBasicMethodBlockInstruction.get_operands(\n                    ins_idx\n                ),\n            }\n\n            cblock[\"instructions\"].append(c_ins)\n            ins_idx += DVMBasicMethodBlockInstruction.get_length()\n\n        cblock[\"Edge\"] = []\n        for DVMBasicMethodBlockChild in DVMBasicMethodBlock.childs:\n            cblock[\"Edge\"].append(DVMBasicMethodBlockChild[-1].get_name())\n\n        reports.append(cblock)\n\n    return json.dumps(d)\n</code></pre>"},{"location":"reference/androguard/core/bytecode.html#androguard.core.bytecode.method2png","title":"<code>method2png(output, mx, raw=None)</code>","text":"<p>Export method to a png file format</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>output filename</p> required <code>mx</code> <code>MethodAnalysis</code> <p>specify the <code>MethodAnalysis</code> object</p> required <code>raw</code> <code>Union[str, None]</code> <p>use directly a dot raw buffer</p> <code>None</code> Source code in <code>androguard/core/bytecode.py</code> <pre><code>def method2png(\n    output: str, mx: MethodAnalysis, raw: Union[str, None] = None\n) -&gt; None:\n    \"\"\"\n    Export method to a png file format\n\n    :param output: output filename\n    :param mx: specify the `MethodAnalysis` object\n    :param raw: use directly a dot raw buffer\n    \"\"\"\n    buff = raw\n    if not raw:\n        buff = method2dot(mx)\n\n    method2format(output, \"png\", mx, buff)\n</code></pre>"},{"location":"reference/androguard/core/bytecode.html#androguard.core.bytecode.object_to_bytes","title":"<code>object_to_bytes(obj)</code>","text":"<p>Convert a object to a bytearray or call <code>get_raw()</code> of the object if no useful type was found.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Union[str, bool, int, bytearray]</code> <p>the object to convert</p> required <p>Returns:</p> Type Description <code>bytearray</code> <p>the bytes</p> Source code in <code>androguard/core/bytecode.py</code> <pre><code>def object_to_bytes(obj: Union[str, bool, int, bytearray]) -&gt; bytearray:\n    \"\"\"\n    Convert a object to a bytearray or call `get_raw()` of the object\n    if no useful type was found.\n\n    :param obj: the object to convert\n    :returns: the bytes\n    \"\"\"\n    if isinstance(obj, str):\n        return bytearray(obj, \"UTF-8\")\n    if isinstance(obj, bool):\n        return bytearray()\n    if isinstance(obj, int):\n        return pack(\"&lt;L\", obj)\n    if obj is None:\n        return bytearray()\n    if isinstance(obj, bytearray):\n        return obj\n\n    return obj.get_raw()\n</code></pre>"},{"location":"reference/androguard/core/bytecode.html#androguard.core.bytecode.vm2json","title":"<code>vm2json(vm)</code>","text":"<p>Get a JSON representation of a DEX file</p> <p>Parameters:</p> Name Type Description Default <code>vm</code> <code>DEX</code> <p><code>androguard.core.dex.DEX</code> object</p> required <p>Returns:</p> Type Description <code>str</code> <p>str</p> Source code in <code>androguard/core/bytecode.py</code> <pre><code>def vm2json(vm: DEX) -&gt; str:\n    \"\"\"\n    Get a JSON representation of a DEX file\n\n    :param vm: `androguard.core.dex.DEX` object\n    :returns: str\n    \"\"\"\n    d = {\"name\": \"root\", \"children\": []}\n\n    for _class in vm.get_classes():\n        c_class = {\"name\": _class.get_name(), \"children\": []}\n\n        for method in _class.get_methods():\n            c_method = {\"name\": method.get_name(), \"children\": []}\n\n            c_class[\"children\"].append(c_method)\n\n        d[\"children\"].append(c_class)\n\n    return json.dumps(d)\n</code></pre>"},{"location":"reference/androguard/core/analysis/index.html","title":"analysis","text":""},{"location":"reference/androguard/core/analysis/analysis.html","title":"analysis","text":""},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis","title":"<code>Analysis</code>","text":"<p>Analysis Object</p> <p>The Analysis contains a lot of information about (multiple) DEX objects Features are for example XREFs between Classes, Methods, Fields and Strings. Yet another part is the creation of BasicBlocks, which is important in the usage of the Androguard Decompiler.</p> <p>Multiple DEX Objects can be added using the function add.</p> <p>XREFs are created for:</p> <ul> <li> <p>classes (ClassAnalysis)</p> </li> <li> <p>methods (MethodAnalysis)</p> </li> <li> <p>strings (StringAnalysis)</p> </li> <li> <p>fields (FieldAnalysis)</p> </li> </ul> <p>The Analysis should be the only object you are using next to the APK. It encapsulates all the Dalvik related functions into a single place, while you have still the ability to use the functions from DEX and the related classes.</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>class Analysis:\n    \"\"\"\n    Analysis Object\n\n    The Analysis contains a lot of information about (multiple) DEX objects\n    Features are for example XREFs between Classes, Methods, Fields and Strings.\n    Yet another part is the creation of BasicBlocks, which is important in the usage of\n    the Androguard Decompiler.\n\n    Multiple DEX Objects can be added using the function [add][androguard.core.analysis.analysis.Analysis.add].\n\n    XREFs are created for:\n\n    * classes ([ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis])\n\n    * methods ([MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis])\n\n    * strings ([StringAnalysis][androguard.core.analysis.analysis.StringAnalysis])\n\n    * fields ([FieldAnalysis][androguard.core.analysis.analysis.FieldAnalysis])\n\n    The Analysis should be the only object you are using next to the [APK][androguard.core.apk.APK].\n    It encapsulates all the Dalvik related functions into a single place, while you have still the ability to use\n    the functions from [DEX][androguard.core.dex.DEX] and the related classes.\n\n    \"\"\"\n\n    def __init__(self, vm: Union[dex.DEX, None] = None) -&gt; None:\n        \"\"\"Initialize a new [Analysis][androguard.core.analysis.analysis.Analysis] object\n\n        :param vm: inital DEX object (default None)\n        \"\"\"\n        # Contains DEX objects\n        self.vms = []\n        # A dict of {classname: ClassAnalysis}, populated on add(vm)\n        self.classes = dict()\n        # A dict of {string: StringAnalysis}, populated on add(vm) and create_xref()\n        self.strings = dict()\n        # A dict of {EncodedMethod: MethodAnalysis}, populated on add(vm)\n        self.methods = dict()\n\n        # Used to quickly look up methods\n        self.__method_hashes = dict()\n\n        if vm:\n            self.add(vm)\n\n        self.__created_xrefs = False\n\n    @property\n    def fields(self) -&gt; Iterator[FieldAnalysis]:\n        \"\"\"Returns [FieldAnalysis][androguard.core.analysis.analysis.FieldAnalysis] generator of this `Analysis`\n\n        :returns: iterator of `FieldAnalysis` objects\n        \"\"\"\n        return self.get_fields()\n\n    def add(self, vm: dex.DEX) -&gt; None:\n        \"\"\"\n        Add a DEX to this Analysis.\n\n        :param vm: `dex.DEX` to add to this Analysis\n        \"\"\"\n\n        self.vms.append(vm)\n\n        logger.info(\"Adding DEX file version {}\".format(vm.version))\n\n        # TODO: This step can easily be multithreaded, as there is no dependency between the objects at this stage\n        tic = time.time()\n        for i, current_class in enumerate(vm.get_classes()):\n            # seed ClassAnalysis objects into classes attribute and add as new class\n            self.classes[current_class.get_name()] = ClassAnalysis(\n                current_class\n            )\n            new_class = self.classes[current_class.get_name()]\n\n            # Fix up the hidden api annotations (Android 10)\n            hidden_api = vm.get_hidden_api()\n            if hidden_api:\n                rf, df = hidden_api.get_flags(i)\n                new_class.set_restriction_flag(rf)\n                new_class.set_domain_flag(df)\n\n            # seed MethodAnalysis objects into methods attribute and add to new class analysis\n            for method in current_class.get_methods():\n                self.methods[method] = MethodAnalysis(vm, method)\n                new_class.add_method(self.methods[method])\n\n                # Store for faster lookup during create_xrefs\n                m_hash = (\n                    current_class.get_name(),\n                    method.get_name(),\n                    str(method.get_descriptor()),\n                )\n                self.__method_hashes[m_hash] = self.methods[method]\n\n            # seed FieldAnalysis objects into to new class analysis\n            # since we access methods through a class property,\n            # which returns what's within a ClassAnalysis\n            # we don't have to track it internally in this class\n            for field in current_class.get_fields():\n                new_class.add_field(FieldAnalysis(field))\n\n        # seed StringAnalysis objects into strings attribute - connect alter using xrefs\n        for string_value in vm.get_strings():\n            self.strings[string_value] = StringAnalysis(string_value)\n\n        logger.info(\n            \"Added DEX in the analysis took : {:0d}min {:02d}s\".format(\n                *divmod(int(time.time() - tic), 60)\n            )\n        )\n\n    def create_xref(self) -&gt; None:\n        \"\"\"\n        Create Class, Method, String and Field crossreferences\n        for all classes in the Analysis.\n\n        If you are using multiple DEX files, this function must\n        be called when all DEX files are added.\n        If you call the function after every DEX file, it will only work\n        for the first time.\n        \"\"\"\n        if self.__created_xrefs:\n            # TODO on concurrent runs, we probably need to clean up first,\n            # or check that we do not write garbage.\n            logger.error(\n                \"You have requested to run create_xref() twice! \"\n                \"This will not work and cause problems! This function will exit right now. \"\n                \"If you want to add multiple DEX files, use add() several times and then run create_xref() once.\"\n            )\n            return\n\n        self.__created_xrefs = True\n        logger.debug(\"Creating Crossreferences (XREF)\")\n        tic = time.time()\n\n        # TODO multiprocessing\n        # One reason why multiprocessing is hard to implement is the creation of\n        # the external classes and methods. This must be synchronized, which is now possible as we have a single method!\n        for vm in self.vms:\n            for current_class in vm.get_classes():\n                self._create_xref(current_class)\n\n        # TODO: After we collected all the information, we should add field and\n        # string xrefs to each MethodAnalysis\n\n        logger.info(\n            \"End of creating cross references (XREF) \"\n            \"run time: {:0d}min {:02d}s\".format(\n                *divmod(int(time.time() - tic), 60)\n            )\n        )\n\n    def _create_xref(self, current_class: dex.ClassDefItem) -&gt; None:\n        \"\"\"\n        Create the xref for `current_class`\n\n        There are four steps involved in getting the xrefs:\n        * Xrefs for class instantiation and static class usage\n        *       for method calls\n        *       for string usage\n        *       for field manipulation\n\n        All these information are stored in the *Analysis Objects.\n\n        Note that this might be quite slow, as all instructions are parsed.\n\n        :param current_class: The class to create xrefs for\n        \"\"\"\n        cur_cls_name = current_class.get_name()\n\n        logger.debug(\n            \"Creating XREF/DREF for class at @0x{:08x}\".format(\n                current_class.get_class_data_off()\n            )\n        )\n        for current_method in current_class.get_methods():\n            logger.debug(\n                \"Creating XREF for method at @0x{:08x}\".format(\n                    current_method.get_code_off()\n                )\n            )\n\n            cur_meth = self.get_method(current_method)\n            cur_cls = self.classes[cur_cls_name]\n\n            for off, instruction in current_method.get_instructions_idx():\n                op_value = instruction.get_op_value()\n\n                # 1) check for class calls: const-class (0x1c), new-instance (0x22)\n                if op_value in [0x1C, 0x22]:\n                    idx_type = instruction.get_ref_kind()\n                    # type_info is the string like 'Ljava/lang/Object;'\n                    type_info = instruction.cm.vm.get_cm_type(idx_type).lstrip(\n                        '['\n                    )\n                    if type_info[0] != 'L':\n                        # Need to make sure, that we get class types and not other types\n                        continue\n\n                    if type_info == cur_cls_name:\n                        # FIXME: effectively ignoring calls to itself - do we want that?\n                        continue\n\n                    if type_info not in self.classes:\n                        # Create new external class\n                        self.classes[type_info] = ClassAnalysis(\n                            ExternalClass(type_info)\n                        )\n\n                    oth_cls = self.classes[type_info]\n\n                    # FIXME: xref_to does not work here! current_method is wrong, as it is not the target!\n                    # In this case that means, that current_method calls the class oth_class.\n                    # Hence, on xref_to the method info is the calling method not the called one,\n                    # as there is no called method!\n                    # With the _new_instance and _const_class can this be deprecated?\n                    # Removing these does not impact tests\n                    cur_cls.add_xref_to(\n                        REF_TYPE(op_value), oth_cls, cur_meth, off\n                    )\n                    oth_cls.add_xref_from(\n                        REF_TYPE(op_value), cur_cls, cur_meth, off\n                    )\n\n                    if op_value == 0x1C:\n                        cur_meth.add_xref_const_class(oth_cls, off)\n                        oth_cls.add_xref_const_class(cur_meth, off)\n                    if op_value == 0x22:\n                        cur_meth.add_xref_new_instance(oth_cls, off)\n                        oth_cls.add_xref_new_instance(cur_meth, off)\n\n                # 2) check for method calls: invoke-* (0x6e ... 0x72), invoke-xxx/range (0x74 ... 0x78)\n                elif (0x6E &lt;= op_value &lt;= 0x72) or (0x74 &lt;= op_value &lt;= 0x78):\n                    idx_meth = instruction.get_ref_kind()\n                    method_info = instruction.cm.vm.get_cm_method(idx_meth)\n                    if not method_info:\n                        logger.warning(\n                            \"Could not get method_info \"\n                            \"for instruction at {} in method at @{}. \"\n                            \"Requested IDX {}\".format(\n                                off, current_method.get_code_off(), idx_meth\n                            )\n                        )\n                        continue\n\n                    class_info = method_info[0].lstrip('[')\n                    if class_info[0] != 'L':\n                        # Need to make sure, that we get class types and not other types\n                        # If another type, like int is used, we simply skip it.\n                        continue\n\n                    # Resolve the second MethodAnalysis\n                    oth_meth = self._resolve_method(\n                        class_info, method_info[1], method_info[2]\n                    )\n\n                    oth_cls = self.classes[class_info]\n\n                    # FIXME: we could merge add_method_xref_* and add_xref_*\n                    cur_cls.add_method_xref_to(\n                        cur_meth, oth_cls, oth_meth, off\n                    )\n                    oth_cls.add_method_xref_from(\n                        oth_meth, cur_cls, cur_meth, off\n                    )\n                    # Internal xref related to class manipulation\n                    cur_cls.add_xref_to(\n                        REF_TYPE(op_value), oth_cls, oth_meth, off\n                    )\n                    oth_cls.add_xref_from(\n                        REF_TYPE(op_value), cur_cls, cur_meth, off\n                    )\n\n                # 3) check for string usage: const-string (0x1a), const-string/jumbo (0x1b)\n                elif 0x1A &lt;= op_value &lt;= 0x1B:\n                    string_value = instruction.cm.vm.get_cm_string(\n                        instruction.get_ref_kind()\n                    )\n                    if string_value not in self.strings:\n                        self.strings[string_value] = StringAnalysis(\n                            string_value\n                        )\n\n                    self.strings[string_value].add_xref_from(\n                        cur_cls, cur_meth, off\n                    )\n\n                # TODO maybe we should add a step 3a) here and check for all const fields. You can then xref for integers etc!\n                # But: This does not work, as const fields are usually optimized internally to const calls...\n\n                # 4) check for field usage: i*op (0x52 ... 0x5f), s*op (0x60 ... 0x6d)\n                elif 0x52 &lt;= op_value &lt;= 0x6D:\n                    idx_field = instruction.get_ref_kind()\n                    field_info = instruction.cm.vm.get_cm_field(idx_field)\n                    field_item = (\n                        instruction.cm.vm.get_encoded_field_descriptor(\n                            field_info[0], field_info[2], field_info[1]\n                        )\n                    )\n                    if not field_item:\n                        continue\n\n                    if (0x52 &lt;= op_value &lt;= 0x58) or (\n                        0x60 &lt;= op_value &lt;= 0x66\n                    ):\n                        # read access to a field\n                        self.classes[cur_cls_name].add_field_xref_read(\n                            cur_meth, cur_cls, field_item, off\n                        )\n                        cur_meth.add_xref_read(cur_cls, field_item, off)\n                    else:\n                        # write access to a field\n                        self.classes[cur_cls_name].add_field_xref_write(\n                            cur_meth, cur_cls, field_item, off\n                        )\n                        cur_meth.add_xref_write(cur_cls, field_item, off)\n\n    def get_method(\n        self, method: dex.EncodedMethod\n    ) -&gt; Union[MethodAnalysis, None]:\n        \"\"\"\n        Get the [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis] object for a given [EncodedMethod][androguard.core.dex.EncodedMethod].\n        This Analysis object is used to enhance `EncodedMethods`.\n\n        :param method: `EncodedMethod` to search for\n        :returns: `MethodAnalysis` object for the given method, or None if method was not found\n        \"\"\"\n        if method in self.methods:\n            return self.methods[method]\n        return None\n\n    # Alias\n    get_method_analysis = get_method\n\n    def _resolve_method(\n        self, class_name: str, method_name: str, method_descriptor: list[str]\n    ) -&gt; MethodAnalysis:\n        \"\"\"\n        Resolves the Method and returns [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis].\n        Will automatically create [ExternalMethods][androguard.core.analysis.analysis.ExternalMethod] if can not resolve and add to the ClassAnalysis etc\n\n        :param class_name:\n        :param method_name:\n        :param method_descriptor: Tuple which has parameters and return type, i.e. `['(I Z)', 'V']`\n        :returns: the `MethodAnalysis`\n        \"\"\"\n        m_hash = (class_name, method_name, ''.join(method_descriptor))\n        if m_hash not in self.__method_hashes:\n            # Need to create a new method\n            if class_name not in self.classes:\n                # External class? no problem!\n                self.classes[class_name] = ClassAnalysis(\n                    ExternalClass(class_name)\n                )\n\n            # Create external method\n            meth = ExternalMethod(\n                class_name, method_name, ''.join(method_descriptor)\n            )\n            meth_analysis = MethodAnalysis(None, meth)\n\n            # add to all the collections we have\n            self.__method_hashes[m_hash] = meth_analysis\n            self.classes[class_name].add_method(meth_analysis)\n            self.methods[meth] = meth_analysis\n\n        return self.__method_hashes[m_hash]\n\n    def get_method_by_name(\n        self, class_name: str, method_name: str, method_descriptor: str\n    ) -&gt; Union[dex.EncodedMethod, None]:\n        \"\"\"\n        Search for a [EncodedMethod][androguard.core.dex.EncodedMethod] in all classes in this analysis\n\n        :param class_name: name of the class, for example `'Ljava/lang/Object;'`\n        :param method_name: name of the method, for example `'onCreate'`\n        :param method_descriptor: descriptor, for example `'(I I Ljava/lang/String)V'`\n        :returns: `EncodedMethod` or None if method was not found\n        \"\"\"\n        m_a = self.get_method_analysis_by_name(\n            class_name, method_name, method_descriptor\n        )\n        if m_a and not m_a.is_external():\n            return m_a.get_method()\n        return None\n\n    def get_method_analysis_by_name(\n        self, class_name: str, method_name: str, method_descriptor: str\n    ) -&gt; Union[MethodAnalysis, None]:\n        \"\"\"\n        Returns the crossreferencing object for a given method.\n\n        This function is similar to [get_method_analysis][androguard.core.analysis.analysis.ClassAnalysis.get_method_analysis], with the difference\n        that you can look up the Method by name\n\n        :param class_name: name of the class, for example `'Ljava/lang/Object;'`\n        :param method_name: name of the method, for example `'onCreate'`\n        :param method_descriptor: method descriptor, for example `'(I I)V'`\n        :returns: `MethodAnalysis`\n        \"\"\"\n        m_hash = (class_name, method_name, method_descriptor)\n        if m_hash not in self.__method_hashes:\n            return None\n        return self.__method_hashes[m_hash]\n\n    def get_field_analysis(\n        self, field: dex.EncodedField\n    ) -&gt; Union[FieldAnalysis, None]:\n        \"\"\"\n        Get the [FieldAnalysis][androguard.core.analysis.analysis.FieldAnalysis] for a given [EncodedField][androguard.core.dex.EncodedField]\n\n        :param field: the `EncodedField`\n        :returns: the `FieldAnalysis`\n        \"\"\"\n        class_analysis = self.get_class_analysis(field.get_class_name())\n        if class_analysis:\n            return class_analysis.get_field_analysis(field)\n        return None\n\n    def is_class_present(self, class_name: str) -&gt; bool:\n        \"\"\"\n        Checks if a given class name is part of this Analysis.\n\n        :param class_name: classname like 'Ljava/lang/Object;' (including L and ;)\n        :returns: True if class was found, False otherwise\n        \"\"\"\n        return class_name in self.classes\n\n    def get_class_analysis(self, class_name: str) -&gt; ClassAnalysis:\n        \"\"\"\n        Returns the [ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis] object for a given classname.\n\n        :param class_name: classname like `'Ljava/lang/Object;'` (including L and ;)\n        :returns: `ClassAnalysis`\n        \"\"\"\n        return self.classes.get(class_name)\n\n    def get_external_classes(self) -&gt; Iterator[ClassAnalysis]:\n        \"\"\"\n        Returns all external classes, that means all classes that are not\n        defined in the given set of [DEX][androguard.core.dex.DEX].\n\n        :returns: the external classes\n        \"\"\"\n        for cls in self.classes.values():\n            if cls.is_external():\n                yield cls\n\n    def get_internal_classes(self) -&gt; Iterator[ClassAnalysis]:\n        \"\"\"\n        Returns all internal classes, that means all classes that are\n        defined in the given set of [DEX][androguard.core.dex.DEX].\n\n        :returns: the internal classes\n        \"\"\"\n        for cls in self.classes.values():\n            if not cls.is_external():\n                yield cls\n\n    def get_internal_methods(self) -&gt; Iterator[MethodAnalysis]:\n        \"\"\"\n        Returns all internal methods, that means all methods that are\n        defined in the given set of [DEX][androguard.core.dex.DEX].\n\n        :returns: the internal methods\n        \"\"\"\n        for m in self.methods.values():\n            if not m.is_external():\n                yield m\n\n    def get_external_methods(self) -&gt; Iterator[MethodAnalysis]:\n        \"\"\"\n        Returns all external methods, that means all methods that are not\n        defined in the given set of [DEX][androguard.core.dex.DEX].\n\n        :returns: the external methods\n        \"\"\"\n        for m in self.methods.values():\n            if m.is_external():\n                yield m\n\n    def get_strings_analysis(self) -&gt; dict[str, StringAnalysis]:\n        \"\"\"\n        Returns a dictionary of strings and their corresponding [StringAnalysis][androguard.core.analysis.analysis.StringAnalysis]\n\n        :returns: the dictionary of strings\n        \"\"\"\n        return self.strings\n\n    def get_strings(self) -&gt; list[StringAnalysis]:\n        \"\"\"\n        Returns a list of [StringAnalysis][androguard.core.analysis.analysis.StringAnalysis] objects\n\n        :returns: list of `StringAnalysis objects\n        \"\"\"\n        return self.strings.values()\n\n    def get_classes(self) -&gt; list[ClassAnalysis]:\n        \"\"\"\n        Returns a list of [ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis] objects\n\n        Returns both internal and external classes (if any)\n\n        :returns: list of `ClassAnalysis` objects\n        \"\"\"\n        return self.classes.values()\n\n    def get_methods(self) -&gt; Iterator[MethodAnalysis]:\n        \"\"\"\n        Returns a generator of [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis] objects\n\n        :returns: generator of `MethodAnalysis` objects\n\n        \"\"\"\n        yield from self.methods.values()\n\n    def get_fields(self) -&gt; Iterator[FieldAnalysis]:\n        \"\"\"\n        Returns a generator of [FieldAnalysis][androguard.core.analysis.analysis.FieldAnalysis]  objects\n\n        :returns: generator of `FieldAnalysis` objects\n        \"\"\"\n        for c in self.classes.values():\n            for f in c.get_fields():\n                yield f\n\n    def find_classes(\n        self, name: str = \".*\", no_external: bool = False\n    ) -&gt; Iterator[ClassAnalysis]:\n        \"\"\"\n        Find classes by name, using regular expression\n        This method will return all [ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis] Object that match the name of\n        the class.\n\n        :param name: regular expression for class name (default \".*\")\n        :param no_external: Remove external classes from the output (default False)\n        :returns: generator of `ClassAnalysis` objects\n        \"\"\"\n        for cname, c in self.classes.items():\n            if no_external and isinstance(c.get_vm_class(), ExternalClass):\n                continue\n            if re.match(name, cname):\n                yield c\n\n    def find_methods(\n        self,\n        classname: str = \".*\",\n        methodname: str = \".*\",\n        descriptor: str = \".*\",\n        accessflags: str = \".*\",\n        no_external: bool = False,\n    ) -&gt; Iterator[MethodAnalysis]:\n        \"\"\"\n        Find a method by name using regular expression.\n        This method will return all [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis] objects, which match the\n        classname, methodname, descriptor and accessflags of the method.\n\n        :param classname: regular expression for the classname\n        :param methodname: regular expression for the method name\n        :param descriptor: regular expression for the descriptor\n        :param accessflags: regular expression for the accessflags\n        :param no_external: Remove external method from the output (default False)\n        :returns: generator of `MethodAnalysis` objects\n        \"\"\"\n        for cname, c in self.classes.items():\n            if re.match(classname, cname):\n                for m in c.get_methods():\n                    z = m.get_method()\n\n                    # TODO is it even possible that an internal class has\n                    # external methods? Maybe we should check for ExternalClass\n                    # instead...\n                    # Above: Yes, it is possible.  Internal classes that inherit from\n                    # an External class and call inherited methods will show as\n                    # external calls\n                    if no_external and isinstance(z, ExternalMethod):\n                        continue\n                    if (\n                        re.match(methodname, z.get_name())\n                        and re.match(descriptor, z.get_descriptor())\n                        and re.match(accessflags, z.get_access_flags_string())\n                    ):\n                        yield m\n\n    def find_strings(self, string: str = \".*\") -&gt; Iterator[StringAnalysis]:\n        \"\"\"\n        Find strings by regex\n\n        :param string: regular expression for the string to search for\n        :returns: generator of `StringAnalysis` objects\n        \"\"\"\n        for s, sa in self.strings.items():\n            if re.match(string, s):\n                yield sa\n\n    def find_fields(\n        self,\n        classname: str = \".*\",\n        fieldname: str = \".*\",\n        fieldtype: str = \".*\",\n        accessflags: str = \".*\",\n    ) -&gt; Iterator[FieldAnalysis]:\n        \"\"\"\n        find fields by regex\n\n        :param classname: regular expression of the classname\n        :param fieldname: regular expression of the fieldname\n        :param fieldtype: regular expression of the fieldtype\n        :param accessflags: regular expression of the access flags\n        :returns: generator of `FieldAnalysis`\n        \"\"\"\n        for cname, c in self.classes.items():\n            if re.match(classname, cname):\n                for f in c.get_fields():\n                    z = f.get_field()\n                    if (\n                        re.match(fieldname, z.get_name())\n                        and re.match(fieldtype, z.get_descriptor())\n                        and re.match(accessflags, z.get_access_flags_string())\n                    ):\n                        yield f\n\n    def __repr__(self):\n        return \"&lt;analysis.Analysis VMs: {}, Classes: {}, Methods: {}, Strings: {}&gt;\".format(\n            len(self.vms),\n            len(self.classes),\n            len(self.methods),\n            len(self.strings),\n        )\n\n    def get_call_graph(\n        self,\n        classname: str = \".*\",\n        methodname: str = \".*\",\n        descriptor: str = \".*\",\n        accessflags: str = \".*\",\n        no_isolated: bool = False,\n        entry_points: list = [],\n    ) -&gt; nx.DiGraph:\n        \"\"\"\n        Generate a directed graph based on the methods found by the filters applied.\n        The filters are the same as in [find_methods][androguard.core.analysis.analysis.Analysis.find_methods]\n\n        A `networkx.DiGraph` is returned, containing all edges only once!\n        that means, if a method calls some method twice or more often, there will\n        only be a single connection.\n\n        :param classname: regular expression of the classname (default: \".*\")\n        :param methodname: regular expression of the methodname (default: \".*\")\n        :param descriptor: regular expression of the descriptor (default: \".*\")\n        :param accessflags: regular expression of the access flags (default: \".*\")\n        :param no_isolated: remove isolated nodes from the graph, e.g. methods which do not call anything (default: `False`)\n        :param entry_points: A list of classes that are marked as entry point\n\n        :returns: the `DiGraph` object\n        \"\"\"\n\n        def _add_node(G, method, _entry_points):\n            \"\"\"\n            Wrapper to add methods to a graph\n            \"\"\"\n            if method not in G:\n                if isinstance(method, ExternalMethod):\n                    is_external = True\n                else:\n                    is_external = False\n\n                if method.get_class_name() in _entry_points:\n                    is_entry_point = True\n                else:\n                    is_entry_point = False\n\n                G.add_node(\n                    method,\n                    external=is_external,\n                    entrypoint=is_entry_point,\n                    methodname=method.get_name(),\n                    descriptor=method.get_descriptor(),\n                    accessflags=method.get_access_flags_string(),\n                    classname=method.get_class_name(),\n                )\n\n        CG = nx.DiGraph()\n\n        # Note: If you create the CG from many classes at the same time, the drawing\n        # will be a total mess...\n        for m in self.find_methods(\n            classname=classname,\n            methodname=methodname,\n            descriptor=descriptor,\n            accessflags=accessflags,\n        ):\n\n            orig_method = m.get_method()\n            logger.info(\"Found Method --&gt; {}\".format(orig_method))\n\n            if no_isolated and len(m.get_xref_to()) == 0:\n                logger.info(\n                    \"Skipped {}, because if has no xrefs\".format(orig_method)\n                )\n                continue\n\n            _add_node(CG, orig_method, entry_points)\n\n            for callee_class, callee_method, offset in m.get_xref_to():\n                _add_node(CG, callee_method.method, entry_points)\n\n                # As this is a DiGraph and we are not interested in duplicate edges,\n                # check if the edge is already in the edge set.\n                # If you need all calls, you probably want to check out MultiDiGraph\n                if not CG.has_edge(orig_method, callee_method.method):\n                    CG.add_edge(orig_method, callee_method.method)\n\n        return CG\n\n    def create_ipython_exports(self) -&gt; None:\n        \"\"\"\n        WARNING: this feature is experimental and is currently not enabled by default! Use with caution!\n\n        Creates attributes for all classes, methods and fields on the `Analysis` object itself.\n        This makes it easier to work with `Analysis` module in an iPython shell.\n\n        Classes can be search by typing `dx.CLASS_&lt;tab&gt;`, as each class is added via this attribute name.\n        Each class will have all methods attached to it via `dx.CLASS_Foobar.METHOD_&lt;tab&gt;`.\n        Fields have a similar syntax: `dx.CLASS_Foobar.FIELD_&lt;tab&gt;`.\n\n        As Strings can contain nearly anything, use [find_strings][androguard.core.analysis.analysis.Analysis.find_strings] instead.\n\n        * Each `CLASS_` item will return a [ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis]\n        * Each `METHOD_` item will return a [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis]\n        * Each `FIELD_` item will return a [FieldAnalysis][androguard.core.analysis.analysis.FieldAnalysis]\n        \"\"\"\n        # TODO: it would be fun to have the classes organized like the packages. I.e. you could do dx.CLASS_xx.yyy.zzz\n        for cls in self.get_classes():\n            name = \"CLASS_\" + bytecode.FormatClassToPython(cls.name)\n            if hasattr(self, name):\n                logger.warning(\"Already existing class {}!\".format(name))\n            setattr(self, name, cls)\n\n            for meth in cls.get_methods():\n                method_name = meth.name\n                if method_name in [\"&lt;init&gt;\", \"&lt;clinit&gt;\"]:\n                    _, method_name = bytecode.get_package_class_name(cls.name)\n\n                # FIXME this naming schema is not very good... but to describe a method uniquely, we need all of it\n                mname = (\n                    \"METH_\"\n                    + method_name\n                    + \"_\"\n                    + bytecode.FormatDescriptorToPython(meth.access)\n                    + \"_\"\n                    + bytecode.FormatDescriptorToPython(meth.descriptor)\n                )\n                if hasattr(cls, mname):\n                    logger.warning(\n                        \"already existing method: {} at class {}\".format(\n                            mname, name\n                        )\n                    )\n                setattr(cls, mname, meth)\n\n            # FIXME: syntetic classes produce problems here.\n            # If the field name is the same in the parent as in the syntetic one, we can only add one!\n            for field in cls.get_fields():\n                mname = \"FIELD_\" + bytecode.FormatNameToPython(field.name)\n                if hasattr(cls, mname):\n                    logger.warning(\n                        \"already existing field: {} at class {}\".format(\n                            mname, name\n                        )\n                    )\n                setattr(cls, mname, field)\n\n    def get_permissions(\n        self, apilevel: Union[str, int, None] = None\n    ) -&gt; Iterator[MethodAnalysis, list[str]]:\n        \"\"\"\n        Returns the permissions and the API method based on the API level specified.\n        This can be used to find usage of API methods which require a permission.\n        Should be used in combination with an [APK][androguard.core.apk.APK]\n\n        The returned permissions are a list, as some API methods require multiple permissions at once.\n\n        The following example shows the usage and how to get the calling methods using XREF:\n\n        Examples: \n\n            &gt;&gt;&gt; from androguard.misc import AnalyzeAPK\n            &gt;&gt;&gt; a, d, dx = AnalyzeAPK(\"somefile.apk\")\n\n            &gt;&gt;&gt; for meth, perm in dx.get_permissions(a.get_effective_target_sdk_version()):\n            &gt;&gt;&gt;     print(\"Using API method {} for permission {}\".format(meth, perm))\n            &gt;&gt;&gt;     print(\"used in:\")\n            &gt;&gt;&gt;     for _, m, _ in meth.get_xref_from():\n            &gt;&gt;&gt;         print(m.full_name)\n\n        .Note:\n            This method might be unreliable and might not extract all used permissions.\n            The permission mapping is based on [Axplorer](https://github.com/reddr/axplorer)\n            and might be incomplete due to the nature of the extraction process.\n            Unfortunately, there is no official API&lt;-&gt;Permission mapping.\n\n            The output of this method relies also on the set API level.\n            If the wrong API level is used, the results might be wrong.\n\n        :param apilevel: API level to load, or None for default\n        :returns: yields tuples of `MethodAnalysis` (of the API method) and list of permission string\n        \"\"\"\n\n        # TODO maybe have the API level loading in the __init__ method and pass the APK as well?\n        permmap = load_api_specific_resource_module(\n            'api_permission_mappings', apilevel\n        )\n        if not permmap:\n            raise ValueError(\n                \"No permission mapping found! Is one available? \"\n                \"The requested API level was '{}'\".format(apilevel)\n            )\n\n        for cls in self.get_external_classes():\n            for meth_analysis in cls.get_methods():\n                meth = meth_analysis.get_method()\n                if meth.permission_api_name in permmap:\n                    yield meth_analysis, permmap[meth.permission_api_name]\n\n    def get_permission_usage(\n        self, permission: str, apilevel: Union[str, int, None] = None\n    ) -&gt; Iterator[MethodAnalysis]:\n        \"\"\"\n        Find the usage of a permission inside the Analysis.\n\n        Examples:\n\n            &gt;&gt;&gt; from androguard.misc import AnalyzeAPK\n            &gt;&gt;&gt; a, d, dx = AnalyzeAPK(\"somefile.apk\")\n\n            &gt;&gt;&gt; for meth in dx.get_permission_usage('android.permission.SEND_SMS', a.get_effective_target_sdk_version()):\n            &gt;&gt;&gt;     print(\"Using API method {}\".format(meth))\n            &gt;&gt;&gt;     print(\"used in:\")\n            &gt;&gt;&gt;     for _, m, _ in meth.get_xref_from():\n            &gt;&gt;&gt;         print(m.full_name)\n\n        The permission mappings might be incomplete! See also  [get_permissions][androguard.core.analysis.analysis.Analysis.get_permissions].\n\n        :param permission: the name of the android permission (usually 'android.permission.XXX')\n        :param apilevel: the requested API level or None for default\n        :returns: yields `MethodAnalysis` objects for all using API methods\n        \"\"\"\n\n        # TODO maybe have the API level loading in the __init__ method and pass the APK as well?\n        permmap = load_api_specific_resource_module(\n            'api_permission_mappings', apilevel\n        )\n        if not permmap:\n            raise ValueError(\n                \"No permission mapping found! Is one available? \"\n                \"The requested API level was '{}'\".format(apilevel)\n            )\n\n        apis = {k for k, v in permmap.items() if permission in v}\n        if not apis:\n            raise ValueError(\n                \"No API methods could be found which use the permission. \"\n                \"Does the permission exists? You requested: '{}'\".format(\n                    permission\n                )\n            )\n\n        for cls in self.get_external_classes():\n            for meth_analysis in cls.get_methods():\n                meth = meth_analysis.get_method()\n                if meth.permission_api_name in apis:\n                    yield meth_analysis\n\n    def get_android_api_usage(self) -&gt; Iterator[MethodAnalysis]:\n        \"\"\"\n        Get all usage of the Android APIs inside the `Analysis`.\n\n        :returns: yields `MethodAnalysis` objects for all Android APIs methods\n        \"\"\"\n\n        for cls in self.get_external_classes():\n            for meth_analysis in cls.get_methods():\n                if meth_analysis.is_android_api():\n                    yield meth_analysis\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.fields","title":"<code>fields</code>  <code>property</code>","text":"<p>Returns FieldAnalysis generator of this <code>Analysis</code></p> <p>Returns:</p> Type Description <code>Iterator[FieldAnalysis]</code> <p>iterator of <code>FieldAnalysis</code> objects</p>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.__init__","title":"<code>__init__(vm=None)</code>","text":"<p>Initialize a new Analysis object</p> <p>Parameters:</p> Name Type Description Default <code>vm</code> <code>Union[DEX, None]</code> <p>inital DEX object (default None)</p> <code>None</code> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def __init__(self, vm: Union[dex.DEX, None] = None) -&gt; None:\n    \"\"\"Initialize a new [Analysis][androguard.core.analysis.analysis.Analysis] object\n\n    :param vm: inital DEX object (default None)\n    \"\"\"\n    # Contains DEX objects\n    self.vms = []\n    # A dict of {classname: ClassAnalysis}, populated on add(vm)\n    self.classes = dict()\n    # A dict of {string: StringAnalysis}, populated on add(vm) and create_xref()\n    self.strings = dict()\n    # A dict of {EncodedMethod: MethodAnalysis}, populated on add(vm)\n    self.methods = dict()\n\n    # Used to quickly look up methods\n    self.__method_hashes = dict()\n\n    if vm:\n        self.add(vm)\n\n    self.__created_xrefs = False\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.add","title":"<code>add(vm)</code>","text":"<p>Add a DEX to this Analysis.</p> <p>Parameters:</p> Name Type Description Default <code>vm</code> <code>DEX</code> <p><code>dex.DEX</code> to add to this Analysis</p> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def add(self, vm: dex.DEX) -&gt; None:\n    \"\"\"\n    Add a DEX to this Analysis.\n\n    :param vm: `dex.DEX` to add to this Analysis\n    \"\"\"\n\n    self.vms.append(vm)\n\n    logger.info(\"Adding DEX file version {}\".format(vm.version))\n\n    # TODO: This step can easily be multithreaded, as there is no dependency between the objects at this stage\n    tic = time.time()\n    for i, current_class in enumerate(vm.get_classes()):\n        # seed ClassAnalysis objects into classes attribute and add as new class\n        self.classes[current_class.get_name()] = ClassAnalysis(\n            current_class\n        )\n        new_class = self.classes[current_class.get_name()]\n\n        # Fix up the hidden api annotations (Android 10)\n        hidden_api = vm.get_hidden_api()\n        if hidden_api:\n            rf, df = hidden_api.get_flags(i)\n            new_class.set_restriction_flag(rf)\n            new_class.set_domain_flag(df)\n\n        # seed MethodAnalysis objects into methods attribute and add to new class analysis\n        for method in current_class.get_methods():\n            self.methods[method] = MethodAnalysis(vm, method)\n            new_class.add_method(self.methods[method])\n\n            # Store for faster lookup during create_xrefs\n            m_hash = (\n                current_class.get_name(),\n                method.get_name(),\n                str(method.get_descriptor()),\n            )\n            self.__method_hashes[m_hash] = self.methods[method]\n\n        # seed FieldAnalysis objects into to new class analysis\n        # since we access methods through a class property,\n        # which returns what's within a ClassAnalysis\n        # we don't have to track it internally in this class\n        for field in current_class.get_fields():\n            new_class.add_field(FieldAnalysis(field))\n\n    # seed StringAnalysis objects into strings attribute - connect alter using xrefs\n    for string_value in vm.get_strings():\n        self.strings[string_value] = StringAnalysis(string_value)\n\n    logger.info(\n        \"Added DEX in the analysis took : {:0d}min {:02d}s\".format(\n            *divmod(int(time.time() - tic), 60)\n        )\n    )\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.create_ipython_exports","title":"<code>create_ipython_exports()</code>","text":"<p>WARNING: this feature is experimental and is currently not enabled by default! Use with caution!</p> <p>Creates attributes for all classes, methods and fields on the <code>Analysis</code> object itself. This makes it easier to work with <code>Analysis</code> module in an iPython shell.</p> <p>Classes can be search by typing <code>dx.CLASS_&lt;tab&gt;</code>, as each class is added via this attribute name. Each class will have all methods attached to it via <code>dx.CLASS_Foobar.METHOD_&lt;tab&gt;</code>. Fields have a similar syntax: <code>dx.CLASS_Foobar.FIELD_&lt;tab&gt;</code>.</p> <p>As Strings can contain nearly anything, use find_strings instead.</p> <ul> <li>Each <code>CLASS_</code> item will return a ClassAnalysis</li> <li>Each <code>METHOD_</code> item will return a MethodAnalysis</li> <li>Each <code>FIELD_</code> item will return a FieldAnalysis</li> </ul> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def create_ipython_exports(self) -&gt; None:\n    \"\"\"\n    WARNING: this feature is experimental and is currently not enabled by default! Use with caution!\n\n    Creates attributes for all classes, methods and fields on the `Analysis` object itself.\n    This makes it easier to work with `Analysis` module in an iPython shell.\n\n    Classes can be search by typing `dx.CLASS_&lt;tab&gt;`, as each class is added via this attribute name.\n    Each class will have all methods attached to it via `dx.CLASS_Foobar.METHOD_&lt;tab&gt;`.\n    Fields have a similar syntax: `dx.CLASS_Foobar.FIELD_&lt;tab&gt;`.\n\n    As Strings can contain nearly anything, use [find_strings][androguard.core.analysis.analysis.Analysis.find_strings] instead.\n\n    * Each `CLASS_` item will return a [ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis]\n    * Each `METHOD_` item will return a [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis]\n    * Each `FIELD_` item will return a [FieldAnalysis][androguard.core.analysis.analysis.FieldAnalysis]\n    \"\"\"\n    # TODO: it would be fun to have the classes organized like the packages. I.e. you could do dx.CLASS_xx.yyy.zzz\n    for cls in self.get_classes():\n        name = \"CLASS_\" + bytecode.FormatClassToPython(cls.name)\n        if hasattr(self, name):\n            logger.warning(\"Already existing class {}!\".format(name))\n        setattr(self, name, cls)\n\n        for meth in cls.get_methods():\n            method_name = meth.name\n            if method_name in [\"&lt;init&gt;\", \"&lt;clinit&gt;\"]:\n                _, method_name = bytecode.get_package_class_name(cls.name)\n\n            # FIXME this naming schema is not very good... but to describe a method uniquely, we need all of it\n            mname = (\n                \"METH_\"\n                + method_name\n                + \"_\"\n                + bytecode.FormatDescriptorToPython(meth.access)\n                + \"_\"\n                + bytecode.FormatDescriptorToPython(meth.descriptor)\n            )\n            if hasattr(cls, mname):\n                logger.warning(\n                    \"already existing method: {} at class {}\".format(\n                        mname, name\n                    )\n                )\n            setattr(cls, mname, meth)\n\n        # FIXME: syntetic classes produce problems here.\n        # If the field name is the same in the parent as in the syntetic one, we can only add one!\n        for field in cls.get_fields():\n            mname = \"FIELD_\" + bytecode.FormatNameToPython(field.name)\n            if hasattr(cls, mname):\n                logger.warning(\n                    \"already existing field: {} at class {}\".format(\n                        mname, name\n                    )\n                )\n            setattr(cls, mname, field)\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.create_xref","title":"<code>create_xref()</code>","text":"<p>Create Class, Method, String and Field crossreferences for all classes in the Analysis.</p> <p>If you are using multiple DEX files, this function must be called when all DEX files are added. If you call the function after every DEX file, it will only work for the first time.</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def create_xref(self) -&gt; None:\n    \"\"\"\n    Create Class, Method, String and Field crossreferences\n    for all classes in the Analysis.\n\n    If you are using multiple DEX files, this function must\n    be called when all DEX files are added.\n    If you call the function after every DEX file, it will only work\n    for the first time.\n    \"\"\"\n    if self.__created_xrefs:\n        # TODO on concurrent runs, we probably need to clean up first,\n        # or check that we do not write garbage.\n        logger.error(\n            \"You have requested to run create_xref() twice! \"\n            \"This will not work and cause problems! This function will exit right now. \"\n            \"If you want to add multiple DEX files, use add() several times and then run create_xref() once.\"\n        )\n        return\n\n    self.__created_xrefs = True\n    logger.debug(\"Creating Crossreferences (XREF)\")\n    tic = time.time()\n\n    # TODO multiprocessing\n    # One reason why multiprocessing is hard to implement is the creation of\n    # the external classes and methods. This must be synchronized, which is now possible as we have a single method!\n    for vm in self.vms:\n        for current_class in vm.get_classes():\n            self._create_xref(current_class)\n\n    # TODO: After we collected all the information, we should add field and\n    # string xrefs to each MethodAnalysis\n\n    logger.info(\n        \"End of creating cross references (XREF) \"\n        \"run time: {:0d}min {:02d}s\".format(\n            *divmod(int(time.time() - tic), 60)\n        )\n    )\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.find_classes","title":"<code>find_classes(name='.*', no_external=False)</code>","text":"<p>Find classes by name, using regular expression This method will return all ClassAnalysis Object that match the name of the class.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>regular expression for class name (default \".*\")</p> <code>'.*'</code> <code>no_external</code> <code>bool</code> <p>Remove external classes from the output (default False)</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterator[ClassAnalysis]</code> <p>generator of <code>ClassAnalysis</code> objects</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def find_classes(\n    self, name: str = \".*\", no_external: bool = False\n) -&gt; Iterator[ClassAnalysis]:\n    \"\"\"\n    Find classes by name, using regular expression\n    This method will return all [ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis] Object that match the name of\n    the class.\n\n    :param name: regular expression for class name (default \".*\")\n    :param no_external: Remove external classes from the output (default False)\n    :returns: generator of `ClassAnalysis` objects\n    \"\"\"\n    for cname, c in self.classes.items():\n        if no_external and isinstance(c.get_vm_class(), ExternalClass):\n            continue\n        if re.match(name, cname):\n            yield c\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.find_fields","title":"<code>find_fields(classname='.*', fieldname='.*', fieldtype='.*', accessflags='.*')</code>","text":"<p>find fields by regex</p> <p>Parameters:</p> Name Type Description Default <code>classname</code> <code>str</code> <p>regular expression of the classname</p> <code>'.*'</code> <code>fieldname</code> <code>str</code> <p>regular expression of the fieldname</p> <code>'.*'</code> <code>fieldtype</code> <code>str</code> <p>regular expression of the fieldtype</p> <code>'.*'</code> <code>accessflags</code> <code>str</code> <p>regular expression of the access flags</p> <code>'.*'</code> <p>Returns:</p> Type Description <code>Iterator[FieldAnalysis]</code> <p>generator of <code>FieldAnalysis</code></p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def find_fields(\n    self,\n    classname: str = \".*\",\n    fieldname: str = \".*\",\n    fieldtype: str = \".*\",\n    accessflags: str = \".*\",\n) -&gt; Iterator[FieldAnalysis]:\n    \"\"\"\n    find fields by regex\n\n    :param classname: regular expression of the classname\n    :param fieldname: regular expression of the fieldname\n    :param fieldtype: regular expression of the fieldtype\n    :param accessflags: regular expression of the access flags\n    :returns: generator of `FieldAnalysis`\n    \"\"\"\n    for cname, c in self.classes.items():\n        if re.match(classname, cname):\n            for f in c.get_fields():\n                z = f.get_field()\n                if (\n                    re.match(fieldname, z.get_name())\n                    and re.match(fieldtype, z.get_descriptor())\n                    and re.match(accessflags, z.get_access_flags_string())\n                ):\n                    yield f\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.find_methods","title":"<code>find_methods(classname='.*', methodname='.*', descriptor='.*', accessflags='.*', no_external=False)</code>","text":"<p>Find a method by name using regular expression. This method will return all MethodAnalysis objects, which match the classname, methodname, descriptor and accessflags of the method.</p> <p>Parameters:</p> Name Type Description Default <code>classname</code> <code>str</code> <p>regular expression for the classname</p> <code>'.*'</code> <code>methodname</code> <code>str</code> <p>regular expression for the method name</p> <code>'.*'</code> <code>descriptor</code> <code>str</code> <p>regular expression for the descriptor</p> <code>'.*'</code> <code>accessflags</code> <code>str</code> <p>regular expression for the accessflags</p> <code>'.*'</code> <code>no_external</code> <code>bool</code> <p>Remove external method from the output (default False)</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterator[MethodAnalysis]</code> <p>generator of <code>MethodAnalysis</code> objects</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def find_methods(\n    self,\n    classname: str = \".*\",\n    methodname: str = \".*\",\n    descriptor: str = \".*\",\n    accessflags: str = \".*\",\n    no_external: bool = False,\n) -&gt; Iterator[MethodAnalysis]:\n    \"\"\"\n    Find a method by name using regular expression.\n    This method will return all [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis] objects, which match the\n    classname, methodname, descriptor and accessflags of the method.\n\n    :param classname: regular expression for the classname\n    :param methodname: regular expression for the method name\n    :param descriptor: regular expression for the descriptor\n    :param accessflags: regular expression for the accessflags\n    :param no_external: Remove external method from the output (default False)\n    :returns: generator of `MethodAnalysis` objects\n    \"\"\"\n    for cname, c in self.classes.items():\n        if re.match(classname, cname):\n            for m in c.get_methods():\n                z = m.get_method()\n\n                # TODO is it even possible that an internal class has\n                # external methods? Maybe we should check for ExternalClass\n                # instead...\n                # Above: Yes, it is possible.  Internal classes that inherit from\n                # an External class and call inherited methods will show as\n                # external calls\n                if no_external and isinstance(z, ExternalMethod):\n                    continue\n                if (\n                    re.match(methodname, z.get_name())\n                    and re.match(descriptor, z.get_descriptor())\n                    and re.match(accessflags, z.get_access_flags_string())\n                ):\n                    yield m\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.find_strings","title":"<code>find_strings(string='.*')</code>","text":"<p>Find strings by regex</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>regular expression for the string to search for</p> <code>'.*'</code> <p>Returns:</p> Type Description <code>Iterator[StringAnalysis]</code> <p>generator of <code>StringAnalysis</code> objects</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def find_strings(self, string: str = \".*\") -&gt; Iterator[StringAnalysis]:\n    \"\"\"\n    Find strings by regex\n\n    :param string: regular expression for the string to search for\n    :returns: generator of `StringAnalysis` objects\n    \"\"\"\n    for s, sa in self.strings.items():\n        if re.match(string, s):\n            yield sa\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.get_android_api_usage","title":"<code>get_android_api_usage()</code>","text":"<p>Get all usage of the Android APIs inside the <code>Analysis</code>.</p> <p>Returns:</p> Type Description <code>Iterator[MethodAnalysis]</code> <p>yields <code>MethodAnalysis</code> objects for all Android APIs methods</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_android_api_usage(self) -&gt; Iterator[MethodAnalysis]:\n    \"\"\"\n    Get all usage of the Android APIs inside the `Analysis`.\n\n    :returns: yields `MethodAnalysis` objects for all Android APIs methods\n    \"\"\"\n\n    for cls in self.get_external_classes():\n        for meth_analysis in cls.get_methods():\n            if meth_analysis.is_android_api():\n                yield meth_analysis\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.get_call_graph","title":"<code>get_call_graph(classname='.*', methodname='.*', descriptor='.*', accessflags='.*', no_isolated=False, entry_points=[])</code>","text":"<p>Generate a directed graph based on the methods found by the filters applied. The filters are the same as in find_methods</p> <p>A <code>networkx.DiGraph</code> is returned, containing all edges only once! that means, if a method calls some method twice or more often, there will only be a single connection.</p> <p>Parameters:</p> Name Type Description Default <code>classname</code> <code>str</code> <p>regular expression of the classname (default: \".*\")</p> <code>'.*'</code> <code>methodname</code> <code>str</code> <p>regular expression of the methodname (default: \".*\")</p> <code>'.*'</code> <code>descriptor</code> <code>str</code> <p>regular expression of the descriptor (default: \".*\")</p> <code>'.*'</code> <code>accessflags</code> <code>str</code> <p>regular expression of the access flags (default: \".*\")</p> <code>'.*'</code> <code>no_isolated</code> <code>bool</code> <p>remove isolated nodes from the graph, e.g. methods which do not call anything (default: <code>False</code>)</p> <code>False</code> <code>entry_points</code> <code>list</code> <p>A list of classes that are marked as entry point</p> <code>[]</code> <p>Returns:</p> Type Description <code>DiGraph</code> <p>the <code>DiGraph</code> object</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_call_graph(\n    self,\n    classname: str = \".*\",\n    methodname: str = \".*\",\n    descriptor: str = \".*\",\n    accessflags: str = \".*\",\n    no_isolated: bool = False,\n    entry_points: list = [],\n) -&gt; nx.DiGraph:\n    \"\"\"\n    Generate a directed graph based on the methods found by the filters applied.\n    The filters are the same as in [find_methods][androguard.core.analysis.analysis.Analysis.find_methods]\n\n    A `networkx.DiGraph` is returned, containing all edges only once!\n    that means, if a method calls some method twice or more often, there will\n    only be a single connection.\n\n    :param classname: regular expression of the classname (default: \".*\")\n    :param methodname: regular expression of the methodname (default: \".*\")\n    :param descriptor: regular expression of the descriptor (default: \".*\")\n    :param accessflags: regular expression of the access flags (default: \".*\")\n    :param no_isolated: remove isolated nodes from the graph, e.g. methods which do not call anything (default: `False`)\n    :param entry_points: A list of classes that are marked as entry point\n\n    :returns: the `DiGraph` object\n    \"\"\"\n\n    def _add_node(G, method, _entry_points):\n        \"\"\"\n        Wrapper to add methods to a graph\n        \"\"\"\n        if method not in G:\n            if isinstance(method, ExternalMethod):\n                is_external = True\n            else:\n                is_external = False\n\n            if method.get_class_name() in _entry_points:\n                is_entry_point = True\n            else:\n                is_entry_point = False\n\n            G.add_node(\n                method,\n                external=is_external,\n                entrypoint=is_entry_point,\n                methodname=method.get_name(),\n                descriptor=method.get_descriptor(),\n                accessflags=method.get_access_flags_string(),\n                classname=method.get_class_name(),\n            )\n\n    CG = nx.DiGraph()\n\n    # Note: If you create the CG from many classes at the same time, the drawing\n    # will be a total mess...\n    for m in self.find_methods(\n        classname=classname,\n        methodname=methodname,\n        descriptor=descriptor,\n        accessflags=accessflags,\n    ):\n\n        orig_method = m.get_method()\n        logger.info(\"Found Method --&gt; {}\".format(orig_method))\n\n        if no_isolated and len(m.get_xref_to()) == 0:\n            logger.info(\n                \"Skipped {}, because if has no xrefs\".format(orig_method)\n            )\n            continue\n\n        _add_node(CG, orig_method, entry_points)\n\n        for callee_class, callee_method, offset in m.get_xref_to():\n            _add_node(CG, callee_method.method, entry_points)\n\n            # As this is a DiGraph and we are not interested in duplicate edges,\n            # check if the edge is already in the edge set.\n            # If you need all calls, you probably want to check out MultiDiGraph\n            if not CG.has_edge(orig_method, callee_method.method):\n                CG.add_edge(orig_method, callee_method.method)\n\n    return CG\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.get_class_analysis","title":"<code>get_class_analysis(class_name)</code>","text":"<p>Returns the ClassAnalysis object for a given classname.</p> <p>Parameters:</p> Name Type Description Default <code>class_name</code> <code>str</code> <p>classname like <code>'Ljava/lang/Object;'</code> (including L and ;)</p> required <p>Returns:</p> Type Description <code>ClassAnalysis</code> <p><code>ClassAnalysis</code></p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_class_analysis(self, class_name: str) -&gt; ClassAnalysis:\n    \"\"\"\n    Returns the [ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis] object for a given classname.\n\n    :param class_name: classname like `'Ljava/lang/Object;'` (including L and ;)\n    :returns: `ClassAnalysis`\n    \"\"\"\n    return self.classes.get(class_name)\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.get_classes","title":"<code>get_classes()</code>","text":"<p>Returns a list of ClassAnalysis objects</p> <p>Returns both internal and external classes (if any)</p> <p>Returns:</p> Type Description <code>list[ClassAnalysis]</code> <p>list of <code>ClassAnalysis</code> objects</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_classes(self) -&gt; list[ClassAnalysis]:\n    \"\"\"\n    Returns a list of [ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis] objects\n\n    Returns both internal and external classes (if any)\n\n    :returns: list of `ClassAnalysis` objects\n    \"\"\"\n    return self.classes.values()\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.get_external_classes","title":"<code>get_external_classes()</code>","text":"<p>Returns all external classes, that means all classes that are not defined in the given set of DEX.</p> <p>Returns:</p> Type Description <code>Iterator[ClassAnalysis]</code> <p>the external classes</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_external_classes(self) -&gt; Iterator[ClassAnalysis]:\n    \"\"\"\n    Returns all external classes, that means all classes that are not\n    defined in the given set of [DEX][androguard.core.dex.DEX].\n\n    :returns: the external classes\n    \"\"\"\n    for cls in self.classes.values():\n        if cls.is_external():\n            yield cls\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.get_external_methods","title":"<code>get_external_methods()</code>","text":"<p>Returns all external methods, that means all methods that are not defined in the given set of DEX.</p> <p>Returns:</p> Type Description <code>Iterator[MethodAnalysis]</code> <p>the external methods</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_external_methods(self) -&gt; Iterator[MethodAnalysis]:\n    \"\"\"\n    Returns all external methods, that means all methods that are not\n    defined in the given set of [DEX][androguard.core.dex.DEX].\n\n    :returns: the external methods\n    \"\"\"\n    for m in self.methods.values():\n        if m.is_external():\n            yield m\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.get_field_analysis","title":"<code>get_field_analysis(field)</code>","text":"<p>Get the FieldAnalysis for a given EncodedField</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>EncodedField</code> <p>the <code>EncodedField</code></p> required <p>Returns:</p> Type Description <code>Union[FieldAnalysis, None]</code> <p>the <code>FieldAnalysis</code></p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_field_analysis(\n    self, field: dex.EncodedField\n) -&gt; Union[FieldAnalysis, None]:\n    \"\"\"\n    Get the [FieldAnalysis][androguard.core.analysis.analysis.FieldAnalysis] for a given [EncodedField][androguard.core.dex.EncodedField]\n\n    :param field: the `EncodedField`\n    :returns: the `FieldAnalysis`\n    \"\"\"\n    class_analysis = self.get_class_analysis(field.get_class_name())\n    if class_analysis:\n        return class_analysis.get_field_analysis(field)\n    return None\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.get_fields","title":"<code>get_fields()</code>","text":"<p>Returns a generator of FieldAnalysis  objects</p> <p>Returns:</p> Type Description <code>Iterator[FieldAnalysis]</code> <p>generator of <code>FieldAnalysis</code> objects</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_fields(self) -&gt; Iterator[FieldAnalysis]:\n    \"\"\"\n    Returns a generator of [FieldAnalysis][androguard.core.analysis.analysis.FieldAnalysis]  objects\n\n    :returns: generator of `FieldAnalysis` objects\n    \"\"\"\n    for c in self.classes.values():\n        for f in c.get_fields():\n            yield f\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.get_internal_classes","title":"<code>get_internal_classes()</code>","text":"<p>Returns all internal classes, that means all classes that are defined in the given set of DEX.</p> <p>Returns:</p> Type Description <code>Iterator[ClassAnalysis]</code> <p>the internal classes</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_internal_classes(self) -&gt; Iterator[ClassAnalysis]:\n    \"\"\"\n    Returns all internal classes, that means all classes that are\n    defined in the given set of [DEX][androguard.core.dex.DEX].\n\n    :returns: the internal classes\n    \"\"\"\n    for cls in self.classes.values():\n        if not cls.is_external():\n            yield cls\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.get_internal_methods","title":"<code>get_internal_methods()</code>","text":"<p>Returns all internal methods, that means all methods that are defined in the given set of DEX.</p> <p>Returns:</p> Type Description <code>Iterator[MethodAnalysis]</code> <p>the internal methods</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_internal_methods(self) -&gt; Iterator[MethodAnalysis]:\n    \"\"\"\n    Returns all internal methods, that means all methods that are\n    defined in the given set of [DEX][androguard.core.dex.DEX].\n\n    :returns: the internal methods\n    \"\"\"\n    for m in self.methods.values():\n        if not m.is_external():\n            yield m\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.get_method","title":"<code>get_method(method)</code>","text":"<p>Get the MethodAnalysis object for a given EncodedMethod. This Analysis object is used to enhance <code>EncodedMethods</code>.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>EncodedMethod</code> <p><code>EncodedMethod</code> to search for</p> required <p>Returns:</p> Type Description <code>Union[MethodAnalysis, None]</code> <p><code>MethodAnalysis</code> object for the given method, or None if method was not found</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_method(\n    self, method: dex.EncodedMethod\n) -&gt; Union[MethodAnalysis, None]:\n    \"\"\"\n    Get the [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis] object for a given [EncodedMethod][androguard.core.dex.EncodedMethod].\n    This Analysis object is used to enhance `EncodedMethods`.\n\n    :param method: `EncodedMethod` to search for\n    :returns: `MethodAnalysis` object for the given method, or None if method was not found\n    \"\"\"\n    if method in self.methods:\n        return self.methods[method]\n    return None\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.get_method_analysis_by_name","title":"<code>get_method_analysis_by_name(class_name, method_name, method_descriptor)</code>","text":"<p>Returns the crossreferencing object for a given method.</p> <p>This function is similar to get_method_analysis, with the difference that you can look up the Method by name</p> <p>Parameters:</p> Name Type Description Default <code>class_name</code> <code>str</code> <p>name of the class, for example <code>'Ljava/lang/Object;'</code></p> required <code>method_name</code> <code>str</code> <p>name of the method, for example <code>'onCreate'</code></p> required <code>method_descriptor</code> <code>str</code> <p>method descriptor, for example <code>'(I I)V'</code></p> required <p>Returns:</p> Type Description <code>Union[MethodAnalysis, None]</code> <p><code>MethodAnalysis</code></p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_method_analysis_by_name(\n    self, class_name: str, method_name: str, method_descriptor: str\n) -&gt; Union[MethodAnalysis, None]:\n    \"\"\"\n    Returns the crossreferencing object for a given method.\n\n    This function is similar to [get_method_analysis][androguard.core.analysis.analysis.ClassAnalysis.get_method_analysis], with the difference\n    that you can look up the Method by name\n\n    :param class_name: name of the class, for example `'Ljava/lang/Object;'`\n    :param method_name: name of the method, for example `'onCreate'`\n    :param method_descriptor: method descriptor, for example `'(I I)V'`\n    :returns: `MethodAnalysis`\n    \"\"\"\n    m_hash = (class_name, method_name, method_descriptor)\n    if m_hash not in self.__method_hashes:\n        return None\n    return self.__method_hashes[m_hash]\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.get_method_by_name","title":"<code>get_method_by_name(class_name, method_name, method_descriptor)</code>","text":"<p>Search for a EncodedMethod in all classes in this analysis</p> <p>Parameters:</p> Name Type Description Default <code>class_name</code> <code>str</code> <p>name of the class, for example <code>'Ljava/lang/Object;'</code></p> required <code>method_name</code> <code>str</code> <p>name of the method, for example <code>'onCreate'</code></p> required <code>method_descriptor</code> <code>str</code> <p>descriptor, for example <code>'(I I Ljava/lang/String)V'</code></p> required <p>Returns:</p> Type Description <code>Union[EncodedMethod, None]</code> <p><code>EncodedMethod</code> or None if method was not found</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_method_by_name(\n    self, class_name: str, method_name: str, method_descriptor: str\n) -&gt; Union[dex.EncodedMethod, None]:\n    \"\"\"\n    Search for a [EncodedMethod][androguard.core.dex.EncodedMethod] in all classes in this analysis\n\n    :param class_name: name of the class, for example `'Ljava/lang/Object;'`\n    :param method_name: name of the method, for example `'onCreate'`\n    :param method_descriptor: descriptor, for example `'(I I Ljava/lang/String)V'`\n    :returns: `EncodedMethod` or None if method was not found\n    \"\"\"\n    m_a = self.get_method_analysis_by_name(\n        class_name, method_name, method_descriptor\n    )\n    if m_a and not m_a.is_external():\n        return m_a.get_method()\n    return None\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.get_methods","title":"<code>get_methods()</code>","text":"<p>Returns a generator of MethodAnalysis objects</p> <p>Returns:</p> Type Description <code>Iterator[MethodAnalysis]</code> <p>generator of <code>MethodAnalysis</code> objects</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_methods(self) -&gt; Iterator[MethodAnalysis]:\n    \"\"\"\n    Returns a generator of [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis] objects\n\n    :returns: generator of `MethodAnalysis` objects\n\n    \"\"\"\n    yield from self.methods.values()\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.get_permission_usage","title":"<code>get_permission_usage(permission, apilevel=None)</code>","text":"<p>Find the usage of a permission inside the Analysis.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from androguard.misc import AnalyzeAPK\n&gt;&gt;&gt; a, d, dx = AnalyzeAPK(\"somefile.apk\")\n\n&gt;&gt;&gt; for meth in dx.get_permission_usage('android.permission.SEND_SMS', a.get_effective_target_sdk_version()):\n&gt;&gt;&gt;     print(\"Using API method {}\".format(meth))\n&gt;&gt;&gt;     print(\"used in:\")\n&gt;&gt;&gt;     for _, m, _ in meth.get_xref_from():\n&gt;&gt;&gt;         print(m.full_name)\n</code></pre> <p>The permission mappings might be incomplete! See also  get_permissions.</p> <p>Parameters:</p> Name Type Description Default <code>permission</code> <code>str</code> <p>the name of the android permission (usually 'android.permission.XXX')</p> required <code>apilevel</code> <code>Union[str, int, None]</code> <p>the requested API level or None for default</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[MethodAnalysis]</code> <p>yields <code>MethodAnalysis</code> objects for all using API methods</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_permission_usage(\n    self, permission: str, apilevel: Union[str, int, None] = None\n) -&gt; Iterator[MethodAnalysis]:\n    \"\"\"\n    Find the usage of a permission inside the Analysis.\n\n    Examples:\n\n        &gt;&gt;&gt; from androguard.misc import AnalyzeAPK\n        &gt;&gt;&gt; a, d, dx = AnalyzeAPK(\"somefile.apk\")\n\n        &gt;&gt;&gt; for meth in dx.get_permission_usage('android.permission.SEND_SMS', a.get_effective_target_sdk_version()):\n        &gt;&gt;&gt;     print(\"Using API method {}\".format(meth))\n        &gt;&gt;&gt;     print(\"used in:\")\n        &gt;&gt;&gt;     for _, m, _ in meth.get_xref_from():\n        &gt;&gt;&gt;         print(m.full_name)\n\n    The permission mappings might be incomplete! See also  [get_permissions][androguard.core.analysis.analysis.Analysis.get_permissions].\n\n    :param permission: the name of the android permission (usually 'android.permission.XXX')\n    :param apilevel: the requested API level or None for default\n    :returns: yields `MethodAnalysis` objects for all using API methods\n    \"\"\"\n\n    # TODO maybe have the API level loading in the __init__ method and pass the APK as well?\n    permmap = load_api_specific_resource_module(\n        'api_permission_mappings', apilevel\n    )\n    if not permmap:\n        raise ValueError(\n            \"No permission mapping found! Is one available? \"\n            \"The requested API level was '{}'\".format(apilevel)\n        )\n\n    apis = {k for k, v in permmap.items() if permission in v}\n    if not apis:\n        raise ValueError(\n            \"No API methods could be found which use the permission. \"\n            \"Does the permission exists? You requested: '{}'\".format(\n                permission\n            )\n        )\n\n    for cls in self.get_external_classes():\n        for meth_analysis in cls.get_methods():\n            meth = meth_analysis.get_method()\n            if meth.permission_api_name in apis:\n                yield meth_analysis\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.get_permissions","title":"<code>get_permissions(apilevel=None)</code>","text":"<p>Returns the permissions and the API method based on the API level specified. This can be used to find usage of API methods which require a permission. Should be used in combination with an APK</p> <p>The returned permissions are a list, as some API methods require multiple permissions at once.</p> <p>The following example shows the usage and how to get the calling methods using XREF:</p> <p>Examples: </p> <pre><code>&gt;&gt;&gt; from androguard.misc import AnalyzeAPK\n&gt;&gt;&gt; a, d, dx = AnalyzeAPK(\"somefile.apk\")\n\n&gt;&gt;&gt; for meth, perm in dx.get_permissions(a.get_effective_target_sdk_version()):\n&gt;&gt;&gt;     print(\"Using API method {} for permission {}\".format(meth, perm))\n&gt;&gt;&gt;     print(\"used in:\")\n&gt;&gt;&gt;     for _, m, _ in meth.get_xref_from():\n&gt;&gt;&gt;         print(m.full_name)\n</code></pre> <p>.Note:     This method might be unreliable and might not extract all used permissions.     The permission mapping is based on Axplorer     and might be incomplete due to the nature of the extraction process.     Unfortunately, there is no official API&lt;-&gt;Permission mapping.</p> <pre><code>The output of this method relies also on the set API level.\nIf the wrong API level is used, the results might be wrong.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>apilevel</code> <code>Union[str, int, None]</code> <p>API level to load, or None for default</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[MethodAnalysis, list[str]]</code> <p>yields tuples of <code>MethodAnalysis</code> (of the API method) and list of permission string</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_permissions(\n    self, apilevel: Union[str, int, None] = None\n) -&gt; Iterator[MethodAnalysis, list[str]]:\n    \"\"\"\n    Returns the permissions and the API method based on the API level specified.\n    This can be used to find usage of API methods which require a permission.\n    Should be used in combination with an [APK][androguard.core.apk.APK]\n\n    The returned permissions are a list, as some API methods require multiple permissions at once.\n\n    The following example shows the usage and how to get the calling methods using XREF:\n\n    Examples: \n\n        &gt;&gt;&gt; from androguard.misc import AnalyzeAPK\n        &gt;&gt;&gt; a, d, dx = AnalyzeAPK(\"somefile.apk\")\n\n        &gt;&gt;&gt; for meth, perm in dx.get_permissions(a.get_effective_target_sdk_version()):\n        &gt;&gt;&gt;     print(\"Using API method {} for permission {}\".format(meth, perm))\n        &gt;&gt;&gt;     print(\"used in:\")\n        &gt;&gt;&gt;     for _, m, _ in meth.get_xref_from():\n        &gt;&gt;&gt;         print(m.full_name)\n\n    .Note:\n        This method might be unreliable and might not extract all used permissions.\n        The permission mapping is based on [Axplorer](https://github.com/reddr/axplorer)\n        and might be incomplete due to the nature of the extraction process.\n        Unfortunately, there is no official API&lt;-&gt;Permission mapping.\n\n        The output of this method relies also on the set API level.\n        If the wrong API level is used, the results might be wrong.\n\n    :param apilevel: API level to load, or None for default\n    :returns: yields tuples of `MethodAnalysis` (of the API method) and list of permission string\n    \"\"\"\n\n    # TODO maybe have the API level loading in the __init__ method and pass the APK as well?\n    permmap = load_api_specific_resource_module(\n        'api_permission_mappings', apilevel\n    )\n    if not permmap:\n        raise ValueError(\n            \"No permission mapping found! Is one available? \"\n            \"The requested API level was '{}'\".format(apilevel)\n        )\n\n    for cls in self.get_external_classes():\n        for meth_analysis in cls.get_methods():\n            meth = meth_analysis.get_method()\n            if meth.permission_api_name in permmap:\n                yield meth_analysis, permmap[meth.permission_api_name]\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.get_strings","title":"<code>get_strings()</code>","text":"<p>Returns a list of StringAnalysis objects</p> <p>Returns:</p> Type Description <code>list[StringAnalysis]</code> <p>list of `StringAnalysis objects</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_strings(self) -&gt; list[StringAnalysis]:\n    \"\"\"\n    Returns a list of [StringAnalysis][androguard.core.analysis.analysis.StringAnalysis] objects\n\n    :returns: list of `StringAnalysis objects\n    \"\"\"\n    return self.strings.values()\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.get_strings_analysis","title":"<code>get_strings_analysis()</code>","text":"<p>Returns a dictionary of strings and their corresponding StringAnalysis</p> <p>Returns:</p> Type Description <code>dict[str, StringAnalysis]</code> <p>the dictionary of strings</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_strings_analysis(self) -&gt; dict[str, StringAnalysis]:\n    \"\"\"\n    Returns a dictionary of strings and their corresponding [StringAnalysis][androguard.core.analysis.analysis.StringAnalysis]\n\n    :returns: the dictionary of strings\n    \"\"\"\n    return self.strings\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.Analysis.is_class_present","title":"<code>is_class_present(class_name)</code>","text":"<p>Checks if a given class name is part of this Analysis.</p> <p>Parameters:</p> Name Type Description Default <code>class_name</code> <code>str</code> <p>classname like 'Ljava/lang/Object;' (including L and ;)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if class was found, False otherwise</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def is_class_present(self, class_name: str) -&gt; bool:\n    \"\"\"\n    Checks if a given class name is part of this Analysis.\n\n    :param class_name: classname like 'Ljava/lang/Object;' (including L and ;)\n    :returns: True if class was found, False otherwise\n    \"\"\"\n    return class_name in self.classes\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.BasicBlocks","title":"<code>BasicBlocks</code>","text":"<p>This class represents all basic blocks of a method.</p> <p>It is a collection of many DEXBasicBlock.</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>class BasicBlocks:\n    \"\"\"\n    This class represents all basic blocks of a method.\n\n    It is a collection of many [DEXBasicBlock][androguard.core.analysis.analysis.DEXBasicBlock].\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.bb = []\n\n    def push(self, bb: DEXBasicBlock) -&gt; None:\n        \"\"\"\n        Adds another basic block to the collection\n\n        :param bb: the `DEXBasicBlock` to add\n        \"\"\"\n        self.bb.append(bb)\n\n    def pop(self, idx: int) -&gt; DEXBasicBlock:\n        \"\"\"remove and return [DEXBasicBlock][androguard.core.analysis.analysis.DEXBasicBlock] at `idx`\n\n        :param idx: the index of the `DEXBasicBlock` to pop and return\n        :return: the popped `DEXBasicBlock`\n        \"\"\"\n        return self.bb.pop(idx)\n\n    def get_basic_block(self, idx: int) -&gt; Union[DEXBasicBlock,None]:\n        \"\"\"return the [DEXBasicBlock][androguard.core.analysis.analysis.DEXBasicBlock] at `idx` \n\n        :param idx: the index of the `DEXBasicBlock` to return\n        :return: the `DEXBasicBlock` or `None` if not found\n        \"\"\"\n        for i in self.bb:\n            if i.get_start() &lt;= idx &lt; i.get_end():\n                return i\n        return None\n\n    def __len__(self) -&gt; int:\n        return len(self.bb)\n\n    def __iter__(self) -&gt; Iterator[DEXBasicBlock]:\n        \"\"\"\n        :returns: yields each basic block (`DEXBasicBlock` object)\n        \"\"\"\n        yield from self.bb\n\n    def __getitem__(self, item: int) -&gt; DEXBasicBlock:\n        \"\"\"\n        Get the basic block at the index\n\n        :param item: index\n        :returns: The basic block\n        \"\"\"\n        return self.bb[item]\n\n    def gets(self) -&gt; list[DEXBasicBlock]:\n        \"\"\"\n        :returns: a list of [DEXBasicBlock][androguard.core.analysis.analysis.DEXBasicBlock]\n        \"\"\"\n        return self.bb\n\n    # Alias for legacy programs\n    get = __iter__\n    get_basic_block_pos = __getitem__\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.BasicBlocks.__getitem__","title":"<code>__getitem__(item)</code>","text":"<p>Get the basic block at the index</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>int</code> <p>index</p> required <p>Returns:</p> Type Description <code>DEXBasicBlock</code> <p>The basic block</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def __getitem__(self, item: int) -&gt; DEXBasicBlock:\n    \"\"\"\n    Get the basic block at the index\n\n    :param item: index\n    :returns: The basic block\n    \"\"\"\n    return self.bb[item]\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.BasicBlocks.__iter__","title":"<code>__iter__()</code>","text":"<p>Returns:</p> Type Description <code>Iterator[DEXBasicBlock]</code> <p>yields each basic block (<code>DEXBasicBlock</code> object)</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def __iter__(self) -&gt; Iterator[DEXBasicBlock]:\n    \"\"\"\n    :returns: yields each basic block (`DEXBasicBlock` object)\n    \"\"\"\n    yield from self.bb\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.BasicBlocks.get_basic_block","title":"<code>get_basic_block(idx)</code>","text":"<p>return the DEXBasicBlock at <code>idx</code> </p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>the index of the <code>DEXBasicBlock</code> to return</p> required <p>Returns:</p> Type Description <code>Union[DEXBasicBlock, None]</code> <p>the <code>DEXBasicBlock</code> or <code>None</code> if not found</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_basic_block(self, idx: int) -&gt; Union[DEXBasicBlock,None]:\n    \"\"\"return the [DEXBasicBlock][androguard.core.analysis.analysis.DEXBasicBlock] at `idx` \n\n    :param idx: the index of the `DEXBasicBlock` to return\n    :return: the `DEXBasicBlock` or `None` if not found\n    \"\"\"\n    for i in self.bb:\n        if i.get_start() &lt;= idx &lt; i.get_end():\n            return i\n    return None\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.BasicBlocks.gets","title":"<code>gets()</code>","text":"<p>Returns:</p> Type Description <code>list[DEXBasicBlock]</code> <p>a list of DEXBasicBlock</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def gets(self) -&gt; list[DEXBasicBlock]:\n    \"\"\"\n    :returns: a list of [DEXBasicBlock][androguard.core.analysis.analysis.DEXBasicBlock]\n    \"\"\"\n    return self.bb\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.BasicBlocks.pop","title":"<code>pop(idx)</code>","text":"<p>remove and return DEXBasicBlock at <code>idx</code></p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>the index of the <code>DEXBasicBlock</code> to pop and return</p> required <p>Returns:</p> Type Description <code>DEXBasicBlock</code> <p>the popped <code>DEXBasicBlock</code></p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def pop(self, idx: int) -&gt; DEXBasicBlock:\n    \"\"\"remove and return [DEXBasicBlock][androguard.core.analysis.analysis.DEXBasicBlock] at `idx`\n\n    :param idx: the index of the `DEXBasicBlock` to pop and return\n    :return: the popped `DEXBasicBlock`\n    \"\"\"\n    return self.bb.pop(idx)\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.BasicBlocks.push","title":"<code>push(bb)</code>","text":"<p>Adds another basic block to the collection</p> <p>Parameters:</p> Name Type Description Default <code>bb</code> <code>DEXBasicBlock</code> <p>the <code>DEXBasicBlock</code> to add</p> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def push(self, bb: DEXBasicBlock) -&gt; None:\n    \"\"\"\n    Adds another basic block to the collection\n\n    :param bb: the `DEXBasicBlock` to add\n    \"\"\"\n    self.bb.append(bb)\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis","title":"<code>ClassAnalysis</code>","text":"<p>ClassAnalysis contains the XREFs from a given Class. It is also used to wrap [ClassDefItem[androguard.core.dex.ClassDefItem], which contain the actual class content like bytecode.</p> <p>Also external classes will generate xrefs, obviously only XREF_FROM are shown for external classes.</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>class ClassAnalysis:\n    \"\"\"\n    ClassAnalysis contains the XREFs from a given Class.\n    It is also used to wrap [ClassDefItem[androguard.core.dex.ClassDefItem], which\n    contain the actual class content like bytecode.\n\n    Also external classes will generate xrefs, obviously only XREF_FROM are\n    shown for external classes.\n    \"\"\"\n\n    def __init__(\n        self, classobj: Union[dex.ClassDefItem, ExternalClass]\n    ) -&gt; None:\n        \"\"\"Initialize a new [ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis] object\n\n        :param classobj: the original class\n        \"\"\"\n\n        logger.info(f\"Adding new ClassAnalysis: {classobj}\")\n        # Automatically decide if the class is external or not\n        self.external = isinstance(classobj, ExternalClass)\n\n        self.orig_class = classobj\n\n        # Contains EncodedMethod/ExternalMethod -&gt; MethodAnalysis\n        self._methods = dict()\n\n        # Contains EncodedField -&gt; FieldAnalysis\n        self._fields = dict()\n\n        self.xrefto = collections.defaultdict(set)\n        self.xreffrom = collections.defaultdict(set)\n\n        self.xrefnewinstance = set()\n        self.xrefconstclass = set()\n\n        # Reserved for further use\n        self.apilist = None\n\n    def add_method(self, method_analysis: MethodAnalysis) -&gt; None:\n        \"\"\"\n        Add the given method to this analyis.\n        usually only called during [Analysis.add][androguard.core.analysis.analysis.Analysis.add] and `Analysis._resolve_method`\n\n        :param method_analysis: the method to add\n        \"\"\"\n        self._methods[method_analysis.get_method()] = method_analysis\n        if self.external:\n            # Propagate ExternalMethod to ExternalClass\n            self.orig_class.add_method(method_analysis.get_method())\n\n    @property\n    def implements(self) -&gt; list[str]:\n        \"\"\"\n        Get a list of interfaces which are implemented by this class\n\n        :returns: a list of Interface names\n        \"\"\"\n        if self.is_external():\n            return []\n\n        return self.orig_class.get_interfaces()\n\n    @property\n    def extends(self) -&gt; str:\n        \"\"\"\n        Return the parent class\n\n        For external classes, this is not sure, thus we return always Object (which is the parent of all classes)\n\n        :returns: a string of the parent class name\n        \"\"\"\n        if self.is_external():\n            return \"Ljava/lang/Object;\"\n\n        return self.orig_class.get_superclassname()\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Return the class name\n\n        :returns:\n        \"\"\"\n        return self.orig_class.get_name()\n\n    def is_external(self) -&gt; bool:\n        \"\"\"\n        Tests if this class is an external class\n\n        :returns: True if the Class is external, False otherwise\n        \"\"\"\n        return self.external\n\n    def is_android_api(self) -&gt; bool:\n        \"\"\"\n        Tries to guess if the current class is an Android API class.\n\n        This might be not very precise unless an apilist is given, with classes that\n        are in fact known APIs.\n        Such a list might be generated by using the android.jar files.\n\n        :returns: True if the class is an Andorid API class, else False.\n        \"\"\"\n\n        # Packages found at https://developer.android.com/reference/packages.html\n        api_candidates = [\n            \"Landroid/\",\n            \"Lcom/android/internal/util\",\n            \"Ldalvik/\",\n            \"Ljava/\",\n            \"Ljavax/\",\n            \"Lorg/apache/\",\n            \"Lorg/json/\",\n            \"Lorg/w3c/dom/\",\n            \"Lorg/xml/sax\",\n            \"Lorg/xmlpull/v1/\",\n            \"Ljunit/\",\n        ]\n\n        if not self.is_external():\n            # API must be external\n            return False\n\n        if self.apilist:\n            return self.orig_class.get_name() in self.apilist\n        else:\n            for candidate in api_candidates:\n                if self.orig_class.get_name().startswith(candidate):\n                    return True\n\n        return False\n\n    def get_methods(self) -&gt; list[MethodAnalysis]:\n        \"\"\"\n        Return all [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis] objects of this class\n\n        :returns: the `MethodAnalysis` objects in this class\n        \"\"\"\n        return self._methods.values()\n        # return list(self._methods.values())\n\n    def get_fields(self) -&gt; list[FieldAnalysis]:\n        \"\"\"\n        Return all [FieldAnalysis][androguard.core.analysis.analysis.FieldAnalysis] objects of this class\n\n        :returns: the `FieldAnalysis` objects in this class\n        \"\"\"\n        return self._fields.values()\n\n    def get_nb_methods(self) -&gt; int:\n        \"\"\"\n        Get the number of methods in this class\n\n        :returns: the number of methods\n        \"\"\"\n        return len(self._methods)\n\n    def get_method_analysis(self, method: dex.EncodedMethod) -&gt; MethodAnalysis:\n        \"\"\"\n        Return the [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis] object for a given [EncodedMethod][androguard.core.dex.EncodedMethod]\n\n        :param method: the method to get a `MethodAnalysis` for\n        :returns: the related `MethodAnalysis`\n        \"\"\"\n        return self._methods.get(method)\n\n    def get_field_analysis(self, field: dex.EncodedMethod) -&gt; FieldAnalysis:\n        \"\"\"Return the [FieldAnalysis][androguard.core.analysis.analysis.FieldAnalysis] object for a given [EncodedMethod][androguard.core.dex.EncodedMethod]\n\n        :param field: the method to get a `FieldAnalysis` for\n        :returns: the related `FieldAnalysis`\n        \"\"\"\n        return self._fields.get(field)\n\n    def add_field(self, field_analysis: FieldAnalysis) -&gt; None:\n        \"\"\"\n        Add the given field to this analyis.\n        usually only called during [Analysis.add][androguard.core.analysis.analysis.Analysis.add]\n\n        :param field_analysis: the `FieldAnalysis` to add\n        \"\"\"\n        self._fields[field_analysis.get_field()] = field_analysis\n        # if self.external:\n        #     # Propagate ExternalField to ExternalClass\n        #     self.orig_class.add_method(field_analysis.get_field())\n\n    def add_field_xref_read(\n        self,\n        method: MethodAnalysis,\n        classobj: ClassAnalysis,\n        field: dex.EncodedField,\n        off: int,\n    ) -&gt; None:\n        \"\"\"\n        Add a Field Read to this class\n\n        :param method:\n        :param classobj:\n        :param field:\n        :param int off:\n        \"\"\"\n        if field not in self._fields:\n            self._fields[field] = FieldAnalysis(field)\n        self._fields[field].add_xref_read(classobj, method, off)\n\n    def add_field_xref_write(\n        self,\n        method: MethodAnalysis,\n        classobj: ClassAnalysis,\n        field: dex.EncodedField,\n        off: int,\n    ) -&gt; None:\n        \"\"\"\n        Add a Field Write to this class in a given method\n\n        :param method:\n        :param classobj:\n        :param field:\n        :param int off:\n        \"\"\"\n        if field not in self._fields:\n            self._fields[field] = FieldAnalysis(field)\n        self._fields[field].add_xref_write(classobj, method, off)\n\n    def add_method_xref_to(\n        self,\n        method1: MethodAnalysis,\n        classobj: ClassAnalysis,\n        method2: MethodAnalysis,\n        offset: int,\n    ) -&gt; None:\n        \"\"\"\n\n        :param method1: the calling method\n        :param classobj: the calling class\n        :param method2: the called method\n        :param int offset: offset in the bytecode of calling method\n        \"\"\"\n\n        # FIXME: Not entirely sure why this can happen but usually a multidex issue:\n        # The given method was not added before...\n        if method1.get_method() not in self._methods:\n            self.add_method(method1)\n\n        self._methods[method1.get_method()].add_xref_to(\n            classobj, method2, offset\n        )\n\n    def add_method_xref_from(\n        self,\n        method1: MethodAnalysis,\n        classobj: ClassAnalysis,\n        method2: MethodAnalysis,\n        offset: int,\n    ) -&gt; None:\n        \"\"\"\n        :param method1:\n        :param classobj:\n        :param method2:\n        :param int offset:\n        \"\"\"\n        # FIXME: Not entirely sure why this can happen but usually a multidex issue:\n        # The given method was not added before...\n        if method1.get_method() not in self._methods:\n            self.add_method(method1)\n\n        self._methods[method1.get_method()].add_xref_from(\n            classobj, method2, offset\n        )\n\n    def add_xref_to(\n        self,\n        ref_kind: REF_TYPE,\n        classobj: ClassAnalysis,\n        methodobj: MethodAnalysis,\n        offset: int,\n    ) -&gt; None:\n        \"\"\"\n        Creates a crossreference to another class.\n        XrefTo means, that the current class calls another class.\n        The current class should also be contained in the another class' XrefFrom list.\n\n        WARNING: The implementation of this specific method might not be what you expect! the parameter `methodobj` is the source method and not the destination in the case that `ref_kind` is const-class or new-instance!\n\n        :param ref_kind: type of call\n        :param classobj: `ClassAnalysis` object to link\n        :param methodobj:\n        :param offset: Offset in the Methods Bytecode, where the call happens\n        \"\"\"\n        self.xrefto[classobj].add((ref_kind, methodobj, offset))\n\n    def add_xref_from(\n        self,\n        ref_kind: REF_TYPE,\n        classobj: ClassAnalysis,\n        methodobj: MethodAnalysis,\n        offset: int,\n    ) -&gt; None:\n        \"\"\"\n        Creates a crossreference from this class.\n        XrefFrom means, that the current class is called by another class.\n\n        :param ref_kind: type of call\n        :param classobj: `ClassAnalysis` object to link\n        :param methodobj:\n        :param offset: Offset in the methods bytecode, where the call happens\n        \"\"\"\n        self.xreffrom[classobj].add((ref_kind, methodobj, offset))\n\n    def get_xref_from(\n        self,\n    ) -&gt; dict[ClassAnalysis, tuple[REF_TYPE, MethodAnalysis, int]]:\n        \"\"\"\n        Returns a dictionary of all classes calling the current class.\n        This dictionary contains also information from which method the class is accessed.\n\n        Note: this method might contains wrong information about class usage!\n\n        The dictionary contains the classes as keys (stored as [ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis])\n        and has a tuple as values, where the first item is the `ref_kind` (which is an Enum of type [REF_TYPE][androguard.core.analysis.analysis.REF_TYPE]),\n        the second one is the method in which the class is called ([MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis])\n        and the third the offset in the method where the call is originating.\n\n        Examples: \n\n            &gt;&gt;&gt; # dx is an Analysis object\n            for cls in dx.find_classes('.*some/name.*'):\n            &gt;&gt;&gt;     print(\"Found class {} in Analysis\".format(cls.name)\n            &gt;&gt;&gt;     for caller, refs in cls.get_xref_from().items():\n            &gt;&gt;&gt;         print(\"  called from {}\".format(caller.name))\n            &gt;&gt;&gt;         for ref_kind, ref_method, ref_offset in refs:\n            &gt;&gt;&gt;             print(\"    in method {} {}\".format(ref_kind, ref_method))\n\n        :returns: `xreffrom`, a dictionary of all classes calling the current class\n        \"\"\"\n        return self.xreffrom\n\n    def get_xref_to(\n        self,\n    ) -&gt; dict[ClassAnalysis, tuple[REF_TYPE, MethodAnalysis, int]]:\n        \"\"\"\n        Returns a dictionary of all classes which are called by the current class.\n        This dictionary contains also information about the method which is called.\n\n        Note: this method might contains wrong information about class usage!\n\n        The dictionary contains the classes as keys (stored as [ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis])\n        and has a tuple as values, where the first item is the `ref_kind` (which is an Enum of type [REF_TYPE][androguard.core.analysis.analysis.REF_TYPE]),\n        the second one is the method called ([MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis])\n        and the third the offset in the method where the call is originating.\n\n        Examples:\n\n            &gt;&gt;&gt; # dx is an Analysis object\n            &gt;&gt;&gt; for cls in dx.find_classes('.*some/name.*'):\n            &gt;&gt;&gt;     print(\"Found class {} in Analysis\".format(cls.name)\n            &gt;&gt;&gt;     for calling, refs in cls.get_xref_from().items():\n            &gt;&gt;&gt;         print(\"  calling class {}\".format(calling.name))\n            &gt;&gt;&gt;         for ref_kind, ref_method, ref_offset in refs:\n            &gt;&gt;&gt;             print(\"    calling method {} {}\".format(ref_kind, ref_method))\n\n        :returns: `xrefto`, a dictionary of all classes which are called by the current class\n        \"\"\"\n        return self.xrefto\n\n    def add_xref_new_instance(\n        self, methobj: MethodAnalysis, offset: int\n    ) -&gt; None:\n        \"\"\"\n        Add a crossreference to another method that is\n        instancing this class.\n\n        :param methobj: The `MethodAnalysis` that this class calls\n        :param offset: integer where in the method the instantiation happens\n        \"\"\"\n        self.xrefnewinstance.add((methobj, offset))\n\n    def get_xref_new_instance(self) -&gt; list[tuple[MethodAnalysis, int]]:\n        \"\"\"\n        Returns a list of tuples containing the set of methods\n        with offsets that instance this class\n\n\n        The list of tuples has the form:\n        ([MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis],\n        `int`)\n\n        :returns: the list of tuples\n        \"\"\"\n        return self.xrefnewinstance\n\n    def add_xref_const_class(\n        self, methobj: MethodAnalysis, offset: int\n    ) -&gt; None:\n        \"\"\"\n        Add a crossreference to a method referencing this classtype.\n\n        :param methobj: The `MethodAnalysis` that this class calls\n        :param offset: integer where in the method the classtype is referenced\n        \"\"\"\n        self.xrefconstclass.add((methobj, offset))\n\n    def get_xref_const_class(self) -&gt; list[tuple[MethodAnalysis, int]]:\n        \"\"\"\n        Returns a list of tuples containing the method and offset\n        referencing this classtype.\n\n        The list of tuples has the form:\n        ([MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis],\n        `int`)\n\n        :returns: the list of tuples\n        \"\"\"\n        return self.xrefconstclass\n\n    def get_vm_class(self) -&gt; Union[dex.ClassDefItem, ExternalClass]:\n        \"\"\"\n        Returns the original Dalvik VM class or the external class object.\n\n        :returns: the `dex.ClassDefItem` or `ExternalClass`\n        \"\"\"\n        return self.orig_class\n\n    def set_restriction_flag(\n        self, flag: dex.HiddenApiClassDataItem.RestrictionApiFlag\n    ) -&gt; None:\n        \"\"\"\n        Set the level of restriction for this class (hidden level, from Android 10)\n        (only applicable to internal classes)\n\n        :param flag: The flag to set to\n        \"\"\"\n        if self.is_external():\n            raise RuntimeError(\n                \"Can\\'t set restriction flag for external class: %s\"\n                % (self.orig_class.name,)\n            )\n        self.restriction_flag = flag\n\n    def set_domain_flag(\n        self, flag: dex.HiddenApiClassDataItem.DomapiApiFlag\n    ) -&gt; None:\n        \"\"\"\n        Set the api domain for this class (hidden level, from Android 10)\n        (only applicable to internal classes)\n\n        :param flag: The flag to set to\n        \"\"\"\n        if self.is_external():\n            raise RuntimeError(\n                \"Can\\'t set domain flag for external class: %s\"\n                % (self.orig_class.name,)\n            )\n        self.domain_flag = flag\n\n    # Alias\n    get_class = get_vm_class\n\n    def __repr__(self):\n        return \"&lt;analysis.ClassAnalysis {}{}&gt;\".format(\n            self.orig_class.get_name(),\n            \" EXTERNAL\" if isinstance(self.orig_class, ExternalClass) else \"\",\n        )\n\n    def __str__(self):\n        # Print only instantiation from other classes here\n        # TODO also method xref and field xref should be printed?\n        data = \"XREFto for %s\\n\" % self.orig_class\n        for ref_class in self.xrefto:\n            data += str(ref_class.get_vm_class().get_name()) + \" \"\n            data += \"in\\n\"\n            for ref_kind, ref_method, ref_offset in self.xrefto[ref_class]:\n                data += \"%d %s 0x%x\\n\" % (ref_kind, ref_method, ref_offset)\n\n            data += \"\\n\"\n\n        data += \"XREFFrom for %s\\n\" % self.orig_class\n        for ref_class in self.xreffrom:\n            data += str(ref_class.get_vm_class().get_name()) + \" \"\n            data += \"in\\n\"\n            for ref_kind, ref_method, ref_offset in self.xreffrom[ref_class]:\n                data += \"%d %s 0x%x\\n\" % (ref_kind, ref_method, ref_offset)\n\n            data += \"\\n\"\n\n        return data\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.extends","title":"<code>extends</code>  <code>property</code>","text":"<p>Return the parent class</p> <p>For external classes, this is not sure, thus we return always Object (which is the parent of all classes)</p> <p>Returns:</p> Type Description <code>str</code> <p>a string of the parent class name</p>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.implements","title":"<code>implements</code>  <code>property</code>","text":"<p>Get a list of interfaces which are implemented by this class</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>a list of Interface names</p>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.name","title":"<code>name</code>  <code>property</code>","text":"<p>Return the class name</p> <p>Returns:</p> Type Description <code>str</code>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.__init__","title":"<code>__init__(classobj)</code>","text":"<p>Initialize a new ClassAnalysis object</p> <p>Parameters:</p> Name Type Description Default <code>classobj</code> <code>Union[ClassDefItem, ExternalClass]</code> <p>the original class</p> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def __init__(\n    self, classobj: Union[dex.ClassDefItem, ExternalClass]\n) -&gt; None:\n    \"\"\"Initialize a new [ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis] object\n\n    :param classobj: the original class\n    \"\"\"\n\n    logger.info(f\"Adding new ClassAnalysis: {classobj}\")\n    # Automatically decide if the class is external or not\n    self.external = isinstance(classobj, ExternalClass)\n\n    self.orig_class = classobj\n\n    # Contains EncodedMethod/ExternalMethod -&gt; MethodAnalysis\n    self._methods = dict()\n\n    # Contains EncodedField -&gt; FieldAnalysis\n    self._fields = dict()\n\n    self.xrefto = collections.defaultdict(set)\n    self.xreffrom = collections.defaultdict(set)\n\n    self.xrefnewinstance = set()\n    self.xrefconstclass = set()\n\n    # Reserved for further use\n    self.apilist = None\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.add_field","title":"<code>add_field(field_analysis)</code>","text":"<p>Add the given field to this analyis. usually only called during Analysis.add</p> <p>Parameters:</p> Name Type Description Default <code>field_analysis</code> <code>FieldAnalysis</code> <p>the <code>FieldAnalysis</code> to add</p> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def add_field(self, field_analysis: FieldAnalysis) -&gt; None:\n    \"\"\"\n    Add the given field to this analyis.\n    usually only called during [Analysis.add][androguard.core.analysis.analysis.Analysis.add]\n\n    :param field_analysis: the `FieldAnalysis` to add\n    \"\"\"\n    self._fields[field_analysis.get_field()] = field_analysis\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.add_field_xref_read","title":"<code>add_field_xref_read(method, classobj, field, off)</code>","text":"<p>Add a Field Read to this class</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>MethodAnalysis</code> required <code>classobj</code> <code>ClassAnalysis</code> required <code>field</code> <code>EncodedField</code> required <code>off</code> <code>int</code> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def add_field_xref_read(\n    self,\n    method: MethodAnalysis,\n    classobj: ClassAnalysis,\n    field: dex.EncodedField,\n    off: int,\n) -&gt; None:\n    \"\"\"\n    Add a Field Read to this class\n\n    :param method:\n    :param classobj:\n    :param field:\n    :param int off:\n    \"\"\"\n    if field not in self._fields:\n        self._fields[field] = FieldAnalysis(field)\n    self._fields[field].add_xref_read(classobj, method, off)\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.add_field_xref_write","title":"<code>add_field_xref_write(method, classobj, field, off)</code>","text":"<p>Add a Field Write to this class in a given method</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>MethodAnalysis</code> required <code>classobj</code> <code>ClassAnalysis</code> required <code>field</code> <code>EncodedField</code> required <code>off</code> <code>int</code> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def add_field_xref_write(\n    self,\n    method: MethodAnalysis,\n    classobj: ClassAnalysis,\n    field: dex.EncodedField,\n    off: int,\n) -&gt; None:\n    \"\"\"\n    Add a Field Write to this class in a given method\n\n    :param method:\n    :param classobj:\n    :param field:\n    :param int off:\n    \"\"\"\n    if field not in self._fields:\n        self._fields[field] = FieldAnalysis(field)\n    self._fields[field].add_xref_write(classobj, method, off)\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.add_method","title":"<code>add_method(method_analysis)</code>","text":"<p>Add the given method to this analyis. usually only called during Analysis.add and <code>Analysis._resolve_method</code></p> <p>Parameters:</p> Name Type Description Default <code>method_analysis</code> <code>MethodAnalysis</code> <p>the method to add</p> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def add_method(self, method_analysis: MethodAnalysis) -&gt; None:\n    \"\"\"\n    Add the given method to this analyis.\n    usually only called during [Analysis.add][androguard.core.analysis.analysis.Analysis.add] and `Analysis._resolve_method`\n\n    :param method_analysis: the method to add\n    \"\"\"\n    self._methods[method_analysis.get_method()] = method_analysis\n    if self.external:\n        # Propagate ExternalMethod to ExternalClass\n        self.orig_class.add_method(method_analysis.get_method())\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.add_method_xref_from","title":"<code>add_method_xref_from(method1, classobj, method2, offset)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>method1</code> <code>MethodAnalysis</code> required <code>classobj</code> <code>ClassAnalysis</code> required <code>method2</code> <code>MethodAnalysis</code> required <code>offset</code> <code>int</code> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def add_method_xref_from(\n    self,\n    method1: MethodAnalysis,\n    classobj: ClassAnalysis,\n    method2: MethodAnalysis,\n    offset: int,\n) -&gt; None:\n    \"\"\"\n    :param method1:\n    :param classobj:\n    :param method2:\n    :param int offset:\n    \"\"\"\n    # FIXME: Not entirely sure why this can happen but usually a multidex issue:\n    # The given method was not added before...\n    if method1.get_method() not in self._methods:\n        self.add_method(method1)\n\n    self._methods[method1.get_method()].add_xref_from(\n        classobj, method2, offset\n    )\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.add_method_xref_to","title":"<code>add_method_xref_to(method1, classobj, method2, offset)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>method1</code> <code>MethodAnalysis</code> <p>the calling method</p> required <code>classobj</code> <code>ClassAnalysis</code> <p>the calling class</p> required <code>method2</code> <code>MethodAnalysis</code> <p>the called method</p> required <code>offset</code> <code>int</code> <p>offset in the bytecode of calling method</p> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def add_method_xref_to(\n    self,\n    method1: MethodAnalysis,\n    classobj: ClassAnalysis,\n    method2: MethodAnalysis,\n    offset: int,\n) -&gt; None:\n    \"\"\"\n\n    :param method1: the calling method\n    :param classobj: the calling class\n    :param method2: the called method\n    :param int offset: offset in the bytecode of calling method\n    \"\"\"\n\n    # FIXME: Not entirely sure why this can happen but usually a multidex issue:\n    # The given method was not added before...\n    if method1.get_method() not in self._methods:\n        self.add_method(method1)\n\n    self._methods[method1.get_method()].add_xref_to(\n        classobj, method2, offset\n    )\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.add_xref_const_class","title":"<code>add_xref_const_class(methobj, offset)</code>","text":"<p>Add a crossreference to a method referencing this classtype.</p> <p>Parameters:</p> Name Type Description Default <code>methobj</code> <code>MethodAnalysis</code> <p>The <code>MethodAnalysis</code> that this class calls</p> required <code>offset</code> <code>int</code> <p>integer where in the method the classtype is referenced</p> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def add_xref_const_class(\n    self, methobj: MethodAnalysis, offset: int\n) -&gt; None:\n    \"\"\"\n    Add a crossreference to a method referencing this classtype.\n\n    :param methobj: The `MethodAnalysis` that this class calls\n    :param offset: integer where in the method the classtype is referenced\n    \"\"\"\n    self.xrefconstclass.add((methobj, offset))\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.add_xref_from","title":"<code>add_xref_from(ref_kind, classobj, methodobj, offset)</code>","text":"<p>Creates a crossreference from this class. XrefFrom means, that the current class is called by another class.</p> <p>Parameters:</p> Name Type Description Default <code>ref_kind</code> <code>REF_TYPE</code> <p>type of call</p> required <code>classobj</code> <code>ClassAnalysis</code> <p><code>ClassAnalysis</code> object to link</p> required <code>methodobj</code> <code>MethodAnalysis</code> required <code>offset</code> <code>int</code> <p>Offset in the methods bytecode, where the call happens</p> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def add_xref_from(\n    self,\n    ref_kind: REF_TYPE,\n    classobj: ClassAnalysis,\n    methodobj: MethodAnalysis,\n    offset: int,\n) -&gt; None:\n    \"\"\"\n    Creates a crossreference from this class.\n    XrefFrom means, that the current class is called by another class.\n\n    :param ref_kind: type of call\n    :param classobj: `ClassAnalysis` object to link\n    :param methodobj:\n    :param offset: Offset in the methods bytecode, where the call happens\n    \"\"\"\n    self.xreffrom[classobj].add((ref_kind, methodobj, offset))\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.add_xref_new_instance","title":"<code>add_xref_new_instance(methobj, offset)</code>","text":"<p>Add a crossreference to another method that is instancing this class.</p> <p>Parameters:</p> Name Type Description Default <code>methobj</code> <code>MethodAnalysis</code> <p>The <code>MethodAnalysis</code> that this class calls</p> required <code>offset</code> <code>int</code> <p>integer where in the method the instantiation happens</p> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def add_xref_new_instance(\n    self, methobj: MethodAnalysis, offset: int\n) -&gt; None:\n    \"\"\"\n    Add a crossreference to another method that is\n    instancing this class.\n\n    :param methobj: The `MethodAnalysis` that this class calls\n    :param offset: integer where in the method the instantiation happens\n    \"\"\"\n    self.xrefnewinstance.add((methobj, offset))\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.add_xref_to","title":"<code>add_xref_to(ref_kind, classobj, methodobj, offset)</code>","text":"<p>Creates a crossreference to another class. XrefTo means, that the current class calls another class. The current class should also be contained in the another class' XrefFrom list.</p> <p>WARNING: The implementation of this specific method might not be what you expect! the parameter <code>methodobj</code> is the source method and not the destination in the case that <code>ref_kind</code> is const-class or new-instance!</p> <p>Parameters:</p> Name Type Description Default <code>ref_kind</code> <code>REF_TYPE</code> <p>type of call</p> required <code>classobj</code> <code>ClassAnalysis</code> <p><code>ClassAnalysis</code> object to link</p> required <code>methodobj</code> <code>MethodAnalysis</code> required <code>offset</code> <code>int</code> <p>Offset in the Methods Bytecode, where the call happens</p> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def add_xref_to(\n    self,\n    ref_kind: REF_TYPE,\n    classobj: ClassAnalysis,\n    methodobj: MethodAnalysis,\n    offset: int,\n) -&gt; None:\n    \"\"\"\n    Creates a crossreference to another class.\n    XrefTo means, that the current class calls another class.\n    The current class should also be contained in the another class' XrefFrom list.\n\n    WARNING: The implementation of this specific method might not be what you expect! the parameter `methodobj` is the source method and not the destination in the case that `ref_kind` is const-class or new-instance!\n\n    :param ref_kind: type of call\n    :param classobj: `ClassAnalysis` object to link\n    :param methodobj:\n    :param offset: Offset in the Methods Bytecode, where the call happens\n    \"\"\"\n    self.xrefto[classobj].add((ref_kind, methodobj, offset))\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.get_field_analysis","title":"<code>get_field_analysis(field)</code>","text":"<p>Return the FieldAnalysis object for a given EncodedMethod</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>EncodedMethod</code> <p>the method to get a <code>FieldAnalysis</code> for</p> required <p>Returns:</p> Type Description <code>FieldAnalysis</code> <p>the related <code>FieldAnalysis</code></p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_field_analysis(self, field: dex.EncodedMethod) -&gt; FieldAnalysis:\n    \"\"\"Return the [FieldAnalysis][androguard.core.analysis.analysis.FieldAnalysis] object for a given [EncodedMethod][androguard.core.dex.EncodedMethod]\n\n    :param field: the method to get a `FieldAnalysis` for\n    :returns: the related `FieldAnalysis`\n    \"\"\"\n    return self._fields.get(field)\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.get_fields","title":"<code>get_fields()</code>","text":"<p>Return all FieldAnalysis objects of this class</p> <p>Returns:</p> Type Description <code>list[FieldAnalysis]</code> <p>the <code>FieldAnalysis</code> objects in this class</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_fields(self) -&gt; list[FieldAnalysis]:\n    \"\"\"\n    Return all [FieldAnalysis][androguard.core.analysis.analysis.FieldAnalysis] objects of this class\n\n    :returns: the `FieldAnalysis` objects in this class\n    \"\"\"\n    return self._fields.values()\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.get_method_analysis","title":"<code>get_method_analysis(method)</code>","text":"<p>Return the MethodAnalysis object for a given EncodedMethod</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>EncodedMethod</code> <p>the method to get a <code>MethodAnalysis</code> for</p> required <p>Returns:</p> Type Description <code>MethodAnalysis</code> <p>the related <code>MethodAnalysis</code></p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_method_analysis(self, method: dex.EncodedMethod) -&gt; MethodAnalysis:\n    \"\"\"\n    Return the [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis] object for a given [EncodedMethod][androguard.core.dex.EncodedMethod]\n\n    :param method: the method to get a `MethodAnalysis` for\n    :returns: the related `MethodAnalysis`\n    \"\"\"\n    return self._methods.get(method)\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.get_methods","title":"<code>get_methods()</code>","text":"<p>Return all MethodAnalysis objects of this class</p> <p>Returns:</p> Type Description <code>list[MethodAnalysis]</code> <p>the <code>MethodAnalysis</code> objects in this class</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_methods(self) -&gt; list[MethodAnalysis]:\n    \"\"\"\n    Return all [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis] objects of this class\n\n    :returns: the `MethodAnalysis` objects in this class\n    \"\"\"\n    return self._methods.values()\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.get_nb_methods","title":"<code>get_nb_methods()</code>","text":"<p>Get the number of methods in this class</p> <p>Returns:</p> Type Description <code>int</code> <p>the number of methods</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_nb_methods(self) -&gt; int:\n    \"\"\"\n    Get the number of methods in this class\n\n    :returns: the number of methods\n    \"\"\"\n    return len(self._methods)\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.get_vm_class","title":"<code>get_vm_class()</code>","text":"<p>Returns the original Dalvik VM class or the external class object.</p> <p>Returns:</p> Type Description <code>Union[ClassDefItem, ExternalClass]</code> <p>the <code>dex.ClassDefItem</code> or <code>ExternalClass</code></p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_vm_class(self) -&gt; Union[dex.ClassDefItem, ExternalClass]:\n    \"\"\"\n    Returns the original Dalvik VM class or the external class object.\n\n    :returns: the `dex.ClassDefItem` or `ExternalClass`\n    \"\"\"\n    return self.orig_class\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.get_xref_const_class","title":"<code>get_xref_const_class()</code>","text":"<p>Returns a list of tuples containing the method and offset referencing this classtype.</p> <p>The list of tuples has the form: (MethodAnalysis, <code>int</code>)</p> <p>Returns:</p> Type Description <code>list[tuple[MethodAnalysis, int]]</code> <p>the list of tuples</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_xref_const_class(self) -&gt; list[tuple[MethodAnalysis, int]]:\n    \"\"\"\n    Returns a list of tuples containing the method and offset\n    referencing this classtype.\n\n    The list of tuples has the form:\n    ([MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis],\n    `int`)\n\n    :returns: the list of tuples\n    \"\"\"\n    return self.xrefconstclass\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.get_xref_from","title":"<code>get_xref_from()</code>","text":"<p>Returns a dictionary of all classes calling the current class. This dictionary contains also information from which method the class is accessed.</p> <p>Note: this method might contains wrong information about class usage!</p> <p>The dictionary contains the classes as keys (stored as ClassAnalysis) and has a tuple as values, where the first item is the <code>ref_kind</code> (which is an Enum of type REF_TYPE), the second one is the method in which the class is called (MethodAnalysis) and the third the offset in the method where the call is originating.</p> <p>Examples: </p> <pre><code>&gt;&gt;&gt; # dx is an Analysis object\nfor cls in dx.find_classes('.*some/name.*'):\n&gt;&gt;&gt;     print(\"Found class {} in Analysis\".format(cls.name)\n&gt;&gt;&gt;     for caller, refs in cls.get_xref_from().items():\n&gt;&gt;&gt;         print(\"  called from {}\".format(caller.name))\n&gt;&gt;&gt;         for ref_kind, ref_method, ref_offset in refs:\n&gt;&gt;&gt;             print(\"    in method {} {}\".format(ref_kind, ref_method))\n</code></pre> <p>Returns:</p> Type Description <code>dict[ClassAnalysis, tuple[REF_TYPE, MethodAnalysis, int]]</code> <p><code>xreffrom</code>, a dictionary of all classes calling the current class</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_xref_from(\n    self,\n) -&gt; dict[ClassAnalysis, tuple[REF_TYPE, MethodAnalysis, int]]:\n    \"\"\"\n    Returns a dictionary of all classes calling the current class.\n    This dictionary contains also information from which method the class is accessed.\n\n    Note: this method might contains wrong information about class usage!\n\n    The dictionary contains the classes as keys (stored as [ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis])\n    and has a tuple as values, where the first item is the `ref_kind` (which is an Enum of type [REF_TYPE][androguard.core.analysis.analysis.REF_TYPE]),\n    the second one is the method in which the class is called ([MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis])\n    and the third the offset in the method where the call is originating.\n\n    Examples: \n\n        &gt;&gt;&gt; # dx is an Analysis object\n        for cls in dx.find_classes('.*some/name.*'):\n        &gt;&gt;&gt;     print(\"Found class {} in Analysis\".format(cls.name)\n        &gt;&gt;&gt;     for caller, refs in cls.get_xref_from().items():\n        &gt;&gt;&gt;         print(\"  called from {}\".format(caller.name))\n        &gt;&gt;&gt;         for ref_kind, ref_method, ref_offset in refs:\n        &gt;&gt;&gt;             print(\"    in method {} {}\".format(ref_kind, ref_method))\n\n    :returns: `xreffrom`, a dictionary of all classes calling the current class\n    \"\"\"\n    return self.xreffrom\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.get_xref_new_instance","title":"<code>get_xref_new_instance()</code>","text":"<p>Returns a list of tuples containing the set of methods with offsets that instance this class</p> <p>The list of tuples has the form: (MethodAnalysis, <code>int</code>)</p> <p>Returns:</p> Type Description <code>list[tuple[MethodAnalysis, int]]</code> <p>the list of tuples</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_xref_new_instance(self) -&gt; list[tuple[MethodAnalysis, int]]:\n    \"\"\"\n    Returns a list of tuples containing the set of methods\n    with offsets that instance this class\n\n\n    The list of tuples has the form:\n    ([MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis],\n    `int`)\n\n    :returns: the list of tuples\n    \"\"\"\n    return self.xrefnewinstance\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.get_xref_to","title":"<code>get_xref_to()</code>","text":"<p>Returns a dictionary of all classes which are called by the current class. This dictionary contains also information about the method which is called.</p> <p>Note: this method might contains wrong information about class usage!</p> <p>The dictionary contains the classes as keys (stored as ClassAnalysis) and has a tuple as values, where the first item is the <code>ref_kind</code> (which is an Enum of type REF_TYPE), the second one is the method called (MethodAnalysis) and the third the offset in the method where the call is originating.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # dx is an Analysis object\n&gt;&gt;&gt; for cls in dx.find_classes('.*some/name.*'):\n&gt;&gt;&gt;     print(\"Found class {} in Analysis\".format(cls.name)\n&gt;&gt;&gt;     for calling, refs in cls.get_xref_from().items():\n&gt;&gt;&gt;         print(\"  calling class {}\".format(calling.name))\n&gt;&gt;&gt;         for ref_kind, ref_method, ref_offset in refs:\n&gt;&gt;&gt;             print(\"    calling method {} {}\".format(ref_kind, ref_method))\n</code></pre> <p>Returns:</p> Type Description <code>dict[ClassAnalysis, tuple[REF_TYPE, MethodAnalysis, int]]</code> <p><code>xrefto</code>, a dictionary of all classes which are called by the current class</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_xref_to(\n    self,\n) -&gt; dict[ClassAnalysis, tuple[REF_TYPE, MethodAnalysis, int]]:\n    \"\"\"\n    Returns a dictionary of all classes which are called by the current class.\n    This dictionary contains also information about the method which is called.\n\n    Note: this method might contains wrong information about class usage!\n\n    The dictionary contains the classes as keys (stored as [ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis])\n    and has a tuple as values, where the first item is the `ref_kind` (which is an Enum of type [REF_TYPE][androguard.core.analysis.analysis.REF_TYPE]),\n    the second one is the method called ([MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis])\n    and the third the offset in the method where the call is originating.\n\n    Examples:\n\n        &gt;&gt;&gt; # dx is an Analysis object\n        &gt;&gt;&gt; for cls in dx.find_classes('.*some/name.*'):\n        &gt;&gt;&gt;     print(\"Found class {} in Analysis\".format(cls.name)\n        &gt;&gt;&gt;     for calling, refs in cls.get_xref_from().items():\n        &gt;&gt;&gt;         print(\"  calling class {}\".format(calling.name))\n        &gt;&gt;&gt;         for ref_kind, ref_method, ref_offset in refs:\n        &gt;&gt;&gt;             print(\"    calling method {} {}\".format(ref_kind, ref_method))\n\n    :returns: `xrefto`, a dictionary of all classes which are called by the current class\n    \"\"\"\n    return self.xrefto\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.is_android_api","title":"<code>is_android_api()</code>","text":"<p>Tries to guess if the current class is an Android API class.</p> <p>This might be not very precise unless an apilist is given, with classes that are in fact known APIs. Such a list might be generated by using the android.jar files.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the class is an Andorid API class, else False.</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def is_android_api(self) -&gt; bool:\n    \"\"\"\n    Tries to guess if the current class is an Android API class.\n\n    This might be not very precise unless an apilist is given, with classes that\n    are in fact known APIs.\n    Such a list might be generated by using the android.jar files.\n\n    :returns: True if the class is an Andorid API class, else False.\n    \"\"\"\n\n    # Packages found at https://developer.android.com/reference/packages.html\n    api_candidates = [\n        \"Landroid/\",\n        \"Lcom/android/internal/util\",\n        \"Ldalvik/\",\n        \"Ljava/\",\n        \"Ljavax/\",\n        \"Lorg/apache/\",\n        \"Lorg/json/\",\n        \"Lorg/w3c/dom/\",\n        \"Lorg/xml/sax\",\n        \"Lorg/xmlpull/v1/\",\n        \"Ljunit/\",\n    ]\n\n    if not self.is_external():\n        # API must be external\n        return False\n\n    if self.apilist:\n        return self.orig_class.get_name() in self.apilist\n    else:\n        for candidate in api_candidates:\n            if self.orig_class.get_name().startswith(candidate):\n                return True\n\n    return False\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.is_external","title":"<code>is_external()</code>","text":"<p>Tests if this class is an external class</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the Class is external, False otherwise</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def is_external(self) -&gt; bool:\n    \"\"\"\n    Tests if this class is an external class\n\n    :returns: True if the Class is external, False otherwise\n    \"\"\"\n    return self.external\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.set_domain_flag","title":"<code>set_domain_flag(flag)</code>","text":"<p>Set the api domain for this class (hidden level, from Android 10) (only applicable to internal classes)</p> <p>Parameters:</p> Name Type Description Default <code>flag</code> <code>DomapiApiFlag</code> <p>The flag to set to</p> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def set_domain_flag(\n    self, flag: dex.HiddenApiClassDataItem.DomapiApiFlag\n) -&gt; None:\n    \"\"\"\n    Set the api domain for this class (hidden level, from Android 10)\n    (only applicable to internal classes)\n\n    :param flag: The flag to set to\n    \"\"\"\n    if self.is_external():\n        raise RuntimeError(\n            \"Can\\'t set domain flag for external class: %s\"\n            % (self.orig_class.name,)\n        )\n    self.domain_flag = flag\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ClassAnalysis.set_restriction_flag","title":"<code>set_restriction_flag(flag)</code>","text":"<p>Set the level of restriction for this class (hidden level, from Android 10) (only applicable to internal classes)</p> <p>Parameters:</p> Name Type Description Default <code>flag</code> <code>RestrictionApiFlag</code> <p>The flag to set to</p> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def set_restriction_flag(\n    self, flag: dex.HiddenApiClassDataItem.RestrictionApiFlag\n) -&gt; None:\n    \"\"\"\n    Set the level of restriction for this class (hidden level, from Android 10)\n    (only applicable to internal classes)\n\n    :param flag: The flag to set to\n    \"\"\"\n    if self.is_external():\n        raise RuntimeError(\n            \"Can\\'t set restriction flag for external class: %s\"\n            % (self.orig_class.name,)\n        )\n    self.restriction_flag = flag\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.DEXBasicBlock","title":"<code>DEXBasicBlock</code>","text":"<p>A simple basic block of a DEX method.</p> <p>A basic block consists of a series of Instruction which are not interrupted by branch or jump instructions such as <code>goto</code>, <code>if</code>, <code>throw</code>, <code>return</code>, <code>switch</code> etc.</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>class DEXBasicBlock:\n    \"\"\"\n    A simple basic block of a DEX method.\n\n    A basic block consists of a series of [Instruction][androguard.core.dex.Instruction]\n    which are not interrupted by branch or jump instructions such as `goto`, `if`, `throw`, `return`, `switch` etc.\n    \"\"\"\n\n    def __init__(\n        self,\n        start: int,\n        vm: dex.DEX,\n        method: dex.EncodedMethod,\n        context: BasicBlocks,\n    ) -&gt; None:\n        \"\"\"Initialize a new [DEXBasicBlock][androguard.core.analysis.analysis.DEXBasicBlock]\n\n        :param start: start address of the basic block\n        :param vm: `DEX` containing the basic block\n        :param method: `EncodedMethod` containing the basic block\n        :param context: `BasicBlocks` containing this basic block\n        \"\"\"\n        self.__vm = vm\n        self.method = method\n        self.context = context\n\n        self.last_length = 0\n        self.nb_instructions = 0\n\n        self.fathers = []\n        self.childs = []\n\n        self.start = start\n        self.end = self.start\n\n        self.special_ins = {}\n\n        self.name = ''.join([self.method.get_name(), '-BB@', hex(self.start)])\n        self.exception_analysis = None\n\n        self.notes = []\n\n        self.__cached_instructions = None\n\n    def get_notes(self) -&gt; list[str]:\n        return self.notes\n\n    def set_notes(self, value: str) -&gt; None:\n        self.notes = [value]\n\n    def add_note(self, note: str) -&gt; None:\n        self.notes.append(note)\n\n    def clear_notes(self) -&gt; None:\n        self.notes = []\n\n    def get_instructions(self) -&gt; Iterator[dex.Instruction]:\n        \"\"\"\n        Get all instructions from a basic block.\n\n        :returns: Return all instructions in the current basic block\n        \"\"\"\n        idx = 0\n        for i in self.method.get_instructions():\n            if self.start &lt;= idx &lt; self.end:\n                yield i\n            idx += i.get_length()\n\n    def get_nb_instructions(self) -&gt; int:\n        return self.nb_instructions\n\n    def get_method(self) -&gt; dex.EncodedMethod:\n        \"\"\"\n        Returns the originating method\n\n        :returns: the originating `dex.EncodedMethod` object\n        \"\"\"\n        return self.method\n\n    def get_name(self) -&gt; str:\n        return self.name\n\n    def get_start(self) -&gt; int:\n        \"\"\"\n        Get the starting offset of this basic block\n\n        :returns: starting offset\n        \"\"\"\n        return self.start\n\n    def get_end(self) -&gt; int:\n        \"\"\"\n        Get the end offset of this basic block\n\n        :returns: end offset\n        \"\"\"\n        return self.end\n\n    def get_last(self) -&gt; dex.Instruction:\n        \"\"\"\n        Get the last instruction in the basic block\n\n        :returns: the last `androguard.core.dex.Instruction` in the basic block\n        \"\"\"\n        return list(self.get_instructions())[-1]\n\n    def get_next(self) -&gt; DEXBasicBlock:\n        \"\"\"\n        Get next basic blocks\n\n        :returns: a list of the next `DEXBasicBlock` objects\n        \"\"\"\n        return self.childs\n\n    def get_prev(self) -&gt; DEXBasicBlock:\n        \"\"\"\n        Get previous basic blocks\n\n        :returns: a list of the previous `DEXBasicBlock` objects\n        \"\"\"\n        return self.fathers\n\n    def set_fathers(self, f: DEXBasicBlock) -&gt; None:\n        self.fathers.append(f)\n\n    def get_last_length(self) -&gt; int:\n        return self.last_length\n\n    def set_childs(self, values: list[int]) -&gt; None:\n        # print self, self.start, self.end, values\n        if not values:\n            next_block = self.context.get_basic_block(self.end + 1)\n            if next_block is not None:\n                self.childs.append(\n                    (self.end - self.get_last_length(), self.end, next_block)\n                )\n        else:\n            for i in values:\n                if i != -1:\n                    next_block = self.context.get_basic_block(i)\n                    if next_block is not None:\n                        self.childs.append(\n                            (self.end - self.get_last_length(), i, next_block)\n                        )\n\n        for c in self.childs:\n            if c[2] is not None:\n                c[2].set_fathers((c[1], c[0], self))\n\n    def push(self, i: DEXBasicBlock) -&gt; None:\n        self.nb_instructions += 1\n        idx = self.end\n        self.last_length = i.get_length()\n        self.end += self.last_length\n\n        op_value = i.get_op_value()\n\n        if op_value == 0x26 or (0x2B &lt;= op_value &lt;= 0x2C):\n            code = self.method.get_code().get_bc()\n            self.special_ins[idx] = code.get_ins_off(idx + i.get_ref_off() * 2)\n\n    def get_special_ins(self, idx: int) -&gt; Union[dex.Instruction, None]:\n        \"\"\"\n        Return the associated instruction to a specific instruction (for example a packed/sparse switch)\n\n        :param idx: the index of the instruction\n\n        :returns: the associated `dex.Instruction`\n        \"\"\"\n        if idx in self.special_ins:\n            return self.special_ins[idx]\n        else:\n            return None\n\n    def get_exception_analysis(self) -&gt; ExceptionAnalysis:\n        return self.exception_analysis\n\n    def set_exception_analysis(self, exception_analysis: ExceptionAnalysis):\n        self.exception_analysis = exception_analysis\n\n    def show(self) -&gt; None:\n        print(\n            \"{}: {:04x} - {:04x}\".format(\n                self.get_name(), self.get_start(), self.get_end()\n            )\n        )\n        for note in self.get_notes():\n            print(note)\n        print('=' * 20)\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.DEXBasicBlock.__init__","title":"<code>__init__(start, vm, method, context)</code>","text":"<p>Initialize a new DEXBasicBlock</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>int</code> <p>start address of the basic block</p> required <code>vm</code> <code>DEX</code> <p><code>DEX</code> containing the basic block</p> required <code>method</code> <code>EncodedMethod</code> <p><code>EncodedMethod</code> containing the basic block</p> required <code>context</code> <code>BasicBlocks</code> <p><code>BasicBlocks</code> containing this basic block</p> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def __init__(\n    self,\n    start: int,\n    vm: dex.DEX,\n    method: dex.EncodedMethod,\n    context: BasicBlocks,\n) -&gt; None:\n    \"\"\"Initialize a new [DEXBasicBlock][androguard.core.analysis.analysis.DEXBasicBlock]\n\n    :param start: start address of the basic block\n    :param vm: `DEX` containing the basic block\n    :param method: `EncodedMethod` containing the basic block\n    :param context: `BasicBlocks` containing this basic block\n    \"\"\"\n    self.__vm = vm\n    self.method = method\n    self.context = context\n\n    self.last_length = 0\n    self.nb_instructions = 0\n\n    self.fathers = []\n    self.childs = []\n\n    self.start = start\n    self.end = self.start\n\n    self.special_ins = {}\n\n    self.name = ''.join([self.method.get_name(), '-BB@', hex(self.start)])\n    self.exception_analysis = None\n\n    self.notes = []\n\n    self.__cached_instructions = None\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.DEXBasicBlock.get_end","title":"<code>get_end()</code>","text":"<p>Get the end offset of this basic block</p> <p>Returns:</p> Type Description <code>int</code> <p>end offset</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_end(self) -&gt; int:\n    \"\"\"\n    Get the end offset of this basic block\n\n    :returns: end offset\n    \"\"\"\n    return self.end\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.DEXBasicBlock.get_instructions","title":"<code>get_instructions()</code>","text":"<p>Get all instructions from a basic block.</p> <p>Returns:</p> Type Description <code>Iterator[Instruction]</code> <p>Return all instructions in the current basic block</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_instructions(self) -&gt; Iterator[dex.Instruction]:\n    \"\"\"\n    Get all instructions from a basic block.\n\n    :returns: Return all instructions in the current basic block\n    \"\"\"\n    idx = 0\n    for i in self.method.get_instructions():\n        if self.start &lt;= idx &lt; self.end:\n            yield i\n        idx += i.get_length()\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.DEXBasicBlock.get_last","title":"<code>get_last()</code>","text":"<p>Get the last instruction in the basic block</p> <p>Returns:</p> Type Description <code>Instruction</code> <p>the last <code>androguard.core.dex.Instruction</code> in the basic block</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_last(self) -&gt; dex.Instruction:\n    \"\"\"\n    Get the last instruction in the basic block\n\n    :returns: the last `androguard.core.dex.Instruction` in the basic block\n    \"\"\"\n    return list(self.get_instructions())[-1]\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.DEXBasicBlock.get_method","title":"<code>get_method()</code>","text":"<p>Returns the originating method</p> <p>Returns:</p> Type Description <code>EncodedMethod</code> <p>the originating <code>dex.EncodedMethod</code> object</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_method(self) -&gt; dex.EncodedMethod:\n    \"\"\"\n    Returns the originating method\n\n    :returns: the originating `dex.EncodedMethod` object\n    \"\"\"\n    return self.method\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.DEXBasicBlock.get_next","title":"<code>get_next()</code>","text":"<p>Get next basic blocks</p> <p>Returns:</p> Type Description <code>DEXBasicBlock</code> <p>a list of the next <code>DEXBasicBlock</code> objects</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_next(self) -&gt; DEXBasicBlock:\n    \"\"\"\n    Get next basic blocks\n\n    :returns: a list of the next `DEXBasicBlock` objects\n    \"\"\"\n    return self.childs\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.DEXBasicBlock.get_prev","title":"<code>get_prev()</code>","text":"<p>Get previous basic blocks</p> <p>Returns:</p> Type Description <code>DEXBasicBlock</code> <p>a list of the previous <code>DEXBasicBlock</code> objects</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_prev(self) -&gt; DEXBasicBlock:\n    \"\"\"\n    Get previous basic blocks\n\n    :returns: a list of the previous `DEXBasicBlock` objects\n    \"\"\"\n    return self.fathers\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.DEXBasicBlock.get_special_ins","title":"<code>get_special_ins(idx)</code>","text":"<p>Return the associated instruction to a specific instruction (for example a packed/sparse switch)</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>the index of the instruction</p> required <p>Returns:</p> Type Description <code>Union[Instruction, None]</code> <p>the associated <code>dex.Instruction</code></p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_special_ins(self, idx: int) -&gt; Union[dex.Instruction, None]:\n    \"\"\"\n    Return the associated instruction to a specific instruction (for example a packed/sparse switch)\n\n    :param idx: the index of the instruction\n\n    :returns: the associated `dex.Instruction`\n    \"\"\"\n    if idx in self.special_ins:\n        return self.special_ins[idx]\n    else:\n        return None\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.DEXBasicBlock.get_start","title":"<code>get_start()</code>","text":"<p>Get the starting offset of this basic block</p> <p>Returns:</p> Type Description <code>int</code> <p>starting offset</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_start(self) -&gt; int:\n    \"\"\"\n    Get the starting offset of this basic block\n\n    :returns: starting offset\n    \"\"\"\n    return self.start\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ExternalClass","title":"<code>ExternalClass</code>","text":"<p>The ExternalClass is used for all classes that are not defined in the DEX file, thus are external classes.</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>class ExternalClass:\n    \"\"\"\n    The ExternalClass is used for all classes that are not defined in the\n    DEX file, thus are external classes.\n\n    \"\"\"\n\n    def __init__(self, name: str) -&gt; None:\n        \"\"\"Instantiate a new [ExternalClass][androguard.core.analysis.analysis.ExternalClass] object\n        :param name: Name of the external class\n        \"\"\"\n        self.name = name\n        self.methods = []\n\n    def get_methods(self) -&gt; list[MethodAnalysis]:\n        \"\"\"\n        Return the list of stored [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis] for this external class\n        :returns: the list of `MethodAnalysis` objects\n        \"\"\"\n        return self.methods\n\n    def add_method(self, method: MethodAnalysis) -&gt; None:\n        self.methods.append(method)\n\n    def get_name(self) -&gt; str:\n        \"\"\"\n        Returns the name of the [ExternalClass][androguard.core.analysis.analysis.ExternalClass] object\n\n        :returns: the name of the external class\n        \"\"\"\n        return self.name\n\n    def __repr__(self):\n        return \"&lt;analysis.ExternalClass {}&gt;\".format(self.name)\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ExternalClass.__init__","title":"<code>__init__(name)</code>","text":"<p>Instantiate a new ExternalClass object</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the external class</p> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def __init__(self, name: str) -&gt; None:\n    \"\"\"Instantiate a new [ExternalClass][androguard.core.analysis.analysis.ExternalClass] object\n    :param name: Name of the external class\n    \"\"\"\n    self.name = name\n    self.methods = []\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ExternalClass.get_methods","title":"<code>get_methods()</code>","text":"<p>Return the list of stored MethodAnalysis for this external class</p> <p>Returns:</p> Type Description <code>list[MethodAnalysis]</code> <p>the list of <code>MethodAnalysis</code> objects</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_methods(self) -&gt; list[MethodAnalysis]:\n    \"\"\"\n    Return the list of stored [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis] for this external class\n    :returns: the list of `MethodAnalysis` objects\n    \"\"\"\n    return self.methods\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ExternalClass.get_name","title":"<code>get_name()</code>","text":"<p>Returns the name of the ExternalClass object</p> <p>Returns:</p> Type Description <code>str</code> <p>the name of the external class</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_name(self) -&gt; str:\n    \"\"\"\n    Returns the name of the [ExternalClass][androguard.core.analysis.analysis.ExternalClass] object\n\n    :returns: the name of the external class\n    \"\"\"\n    return self.name\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ExternalMethod","title":"<code>ExternalMethod</code>","text":"<p>ExternalMethod is a stub class for methods that are not part of the current Analysis. There are two possibilities for this:</p> <p>1) The method is defined inside another DEX file which was not loaded into the Analysis 2) The method is an API method, hence it is defined in the Android system</p> <p>External methods should have a similar API to EncodedMethod but obviously they have no code attached. The only known information about such methods are the class name, the method name and its descriptor.</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>class ExternalMethod:\n    \"\"\"\n    ExternalMethod is a stub class for methods that are not part of the current Analysis.\n    There are two possibilities for this:\n\n    1) The method is defined inside another DEX file which was not loaded into the Analysis\n    2) The method is an API method, hence it is defined in the Android system\n\n    External methods should have a similar API to [EncodedMethod][androguard.core.dex.EncodedMethod]\n    but obviously they have no code attached.\n    The only known information about such methods are the class name, the method name and its descriptor.\n    \"\"\"\n\n    def __init__(self, class_name: str, name: str, descriptor: str) -&gt; None:\n        \"\"\"Initialize a new [ExternalMethod][androguard.core.analysis.analysis.ExternalMethod] object\n\n        :param class_name: name of the class\n        :param name: name of the method\n        :param descriptor: descriptor string\n        \"\"\"\n        self.class_name = class_name\n        self.name = name\n        self.descriptor = descriptor\n\n    def get_name(self) -&gt; str:\n        \"\"\"return the name of the external method\n\n        :return: the name of the external method\n        \"\"\"\n        return self.name\n\n    def get_class_name(self) -&gt; str:\n        \"\"\"return the name of the class of this external method\n\n        :return: the name of the class\n        \"\"\"\n        return self.class_name\n\n    def get_descriptor(self) -&gt; str:\n        \"\"\"return the descriptor of this external method\n        :return: the descriptor of the external method\n        \"\"\"\n        return self.descriptor\n\n    @property\n    def full_name(self) -&gt; str:\n        \"\"\"Returns classname + name + descriptor, separated by spaces (no access flags)'\n\n        :returns: the formatted name\n        \"\"\"\n        return (\n            self.class_name\n            + \" \"\n            + self.name\n            + \" \"\n            + str(self.get_descriptor())\n        )\n\n    @property\n    def permission_api_name(self) -&gt; str:\n        \"\"\"Returns a name which can be used to look up in the permission maps\n\n        :returns: the formatted name\n        \"\"\"\n        return (\n            self.class_name\n            + \"-\"\n            + self.name\n            + \"-\"\n            + str(self.get_descriptor())\n        )\n\n    def get_access_flags_string(self) -&gt; str:\n        \"\"\"\n        Returns the access flags string.\n\n        Right now, this is always an empty strings, as we can not say what\n        kind of access flags an external method might have.\n        \"\"\"\n        # TODO can we assume that external methods are always public?\n        # they can also be static...\n        # or constructor...\n        # or they might be inherited and have all kinds of access flags...\n        return \"\"\n\n    def __str__(self):\n        return \"{}-&gt;{}{}\".format(\n            self.class_name.__str__(),\n            self.name.__str__(),\n            str(self.get_descriptor()),\n        )\n\n    def __repr__(self):\n        return \"&lt;analysis.ExternalMethod {}&gt;\".format(self.__str__())\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ExternalMethod.full_name","title":"<code>full_name</code>  <code>property</code>","text":"<p>Returns classname + name + descriptor, separated by spaces (no access flags)'</p> <p>Returns:</p> Type Description <code>str</code> <p>the formatted name</p>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ExternalMethod.permission_api_name","title":"<code>permission_api_name</code>  <code>property</code>","text":"<p>Returns a name which can be used to look up in the permission maps</p> <p>Returns:</p> Type Description <code>str</code> <p>the formatted name</p>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ExternalMethod.__init__","title":"<code>__init__(class_name, name, descriptor)</code>","text":"<p>Initialize a new ExternalMethod object</p> <p>Parameters:</p> Name Type Description Default <code>class_name</code> <code>str</code> <p>name of the class</p> required <code>name</code> <code>str</code> <p>name of the method</p> required <code>descriptor</code> <code>str</code> <p>descriptor string</p> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def __init__(self, class_name: str, name: str, descriptor: str) -&gt; None:\n    \"\"\"Initialize a new [ExternalMethod][androguard.core.analysis.analysis.ExternalMethod] object\n\n    :param class_name: name of the class\n    :param name: name of the method\n    :param descriptor: descriptor string\n    \"\"\"\n    self.class_name = class_name\n    self.name = name\n    self.descriptor = descriptor\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ExternalMethod.get_access_flags_string","title":"<code>get_access_flags_string()</code>","text":"<p>Returns the access flags string.</p> <p>Right now, this is always an empty strings, as we can not say what kind of access flags an external method might have.</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_access_flags_string(self) -&gt; str:\n    \"\"\"\n    Returns the access flags string.\n\n    Right now, this is always an empty strings, as we can not say what\n    kind of access flags an external method might have.\n    \"\"\"\n    # TODO can we assume that external methods are always public?\n    # they can also be static...\n    # or constructor...\n    # or they might be inherited and have all kinds of access flags...\n    return \"\"\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ExternalMethod.get_class_name","title":"<code>get_class_name()</code>","text":"<p>return the name of the class of this external method</p> <p>Returns:</p> Type Description <code>str</code> <p>the name of the class</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_class_name(self) -&gt; str:\n    \"\"\"return the name of the class of this external method\n\n    :return: the name of the class\n    \"\"\"\n    return self.class_name\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ExternalMethod.get_descriptor","title":"<code>get_descriptor()</code>","text":"<p>return the descriptor of this external method</p> <p>Returns:</p> Type Description <code>str</code> <p>the descriptor of the external method</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_descriptor(self) -&gt; str:\n    \"\"\"return the descriptor of this external method\n    :return: the descriptor of the external method\n    \"\"\"\n    return self.descriptor\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.ExternalMethod.get_name","title":"<code>get_name()</code>","text":"<p>return the name of the external method</p> <p>Returns:</p> Type Description <code>str</code> <p>the name of the external method</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_name(self) -&gt; str:\n    \"\"\"return the name of the external method\n\n    :return: the name of the external method\n    \"\"\"\n    return self.name\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.FieldAnalysis","title":"<code>FieldAnalysis</code>","text":"<p>FieldAnalysis contains the XREFs for a class field.</p> <p>Instead of using XREF_FROM/XREF_TO, this object has methods for READ and WRITE access to the field.</p> <p>That means, that it will show you, where the field is read or written.</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>class FieldAnalysis:\n    \"\"\"\n    FieldAnalysis contains the XREFs for a class field.\n\n    Instead of using XREF_FROM/XREF_TO, this object has methods for READ and\n    WRITE access to the field.\n\n    That means, that it will show you, where the field is read or written.\n    \"\"\"\n\n    def __init__(self, field: dex.EncodedField) -&gt; None:\n        \"\"\"Initialize a new [FieldAnalysis][androguard.core.analysis.analysis.FieldAnalysis] object\n        :param field:\n        \"\"\"\n        self.field = field\n        self.xrefread = set()\n        self.xrefwrite = set()\n\n    @property\n    def name(self) -&gt; str:\n        return self.field.get_name()\n\n    def add_xref_read(\n        self, classobj: ClassAnalysis, methodobj: MethodAnalysis, offset: int\n    ) -&gt; None:\n        \"\"\"\n        :param classobj:\n        :param methodobj:\n        :param offset: offset in the bytecode\n        \"\"\"\n        self.xrefread.add((classobj, methodobj, offset))\n\n    def add_xref_write(\n        self, classobj: ClassAnalysis, methodobj: MethodAnalysis, offset: int\n    ) -&gt; None:\n        \"\"\"\n        :param classobj:\n        :param methodobj:\n        :param offset: offset in the bytecode\n        \"\"\"\n        self.xrefwrite.add((classobj, methodobj, offset))\n\n    def get_xref_read(\n        self, with_offset: bool = False\n    ) -&gt; list[tuple[ClassAnalysis, MethodAnalysis]]:\n        \"\"\"\n        Returns a list of xrefs where the field is read.\n\n        The list contains tuples of the originating class and methods,\n        where the class is represented as a [ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis],\n        while the method is a [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis].\n\n        :param with_offset: return the xrefs including the offset\n\n        :returns: the `xrefread` list\n        \"\"\"\n        if with_offset:\n            return self.xrefread\n        # Legacy option, might be removed in the future\n        return set(map(itemgetter(slice(0, 2)), self.xrefread))\n\n    def get_xref_write(\n        self, with_offset: bool = False\n    ) -&gt; list[tuple[ClassAnalysis, MethodAnalysis]]:\n        \"\"\"\n        Returns a list of xrefs where the field is written to.\n\n        The list contains tuples of the originating class and methods,\n        where the class is represented as a [ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis],\n        while the method is a [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis]`.\n\n        :param with_offset: return the xrefs including the offset\n\n        :returns: the `xrefwrite` list\n        \"\"\"\n        if with_offset:\n            return self.xrefwrite\n        # Legacy option, might be removed in the future\n        return set(map(itemgetter(slice(0, 2)), self.xrefwrite))\n\n    def get_field(self) -&gt; dex.EncodedField:\n        \"\"\"\n        Returns the actual [EncodedField][androguard.core.dex.EncodedField] object\n\n        :returns: the `dex.EncodedField` object\n        \"\"\"\n        return self.field\n\n    def __str__(self):\n        data = \"XREFRead for %s\\n\" % self.field\n        for ref_class, ref_method, off in self.xrefread:\n            data += \"in\\n\"\n            data += \"{}:{} @{}\\n\".format(\n                ref_class.get_vm_class().get_name(), ref_method, off\n            )\n\n        data += \"XREFWrite for %s\\n\" % self.field\n        for ref_class, ref_method, off in self.xrefwrite:\n            data += \"in\\n\"\n            data += \"{}:{} @{}\\n\".format(\n                ref_class.get_vm_class().get_name(), ref_method, off\n            )\n\n        return data\n\n    def __repr__(self):\n        return \"&lt;analysis.FieldAnalysis {}-&gt;{}&gt;\".format(\n            self.field.class_name, self.field.name\n        )\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.FieldAnalysis.__init__","title":"<code>__init__(field)</code>","text":"<p>Initialize a new FieldAnalysis object</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>EncodedField</code> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def __init__(self, field: dex.EncodedField) -&gt; None:\n    \"\"\"Initialize a new [FieldAnalysis][androguard.core.analysis.analysis.FieldAnalysis] object\n    :param field:\n    \"\"\"\n    self.field = field\n    self.xrefread = set()\n    self.xrefwrite = set()\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.FieldAnalysis.add_xref_read","title":"<code>add_xref_read(classobj, methodobj, offset)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>classobj</code> <code>ClassAnalysis</code> required <code>methodobj</code> <code>MethodAnalysis</code> required <code>offset</code> <code>int</code> <p>offset in the bytecode</p> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def add_xref_read(\n    self, classobj: ClassAnalysis, methodobj: MethodAnalysis, offset: int\n) -&gt; None:\n    \"\"\"\n    :param classobj:\n    :param methodobj:\n    :param offset: offset in the bytecode\n    \"\"\"\n    self.xrefread.add((classobj, methodobj, offset))\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.FieldAnalysis.add_xref_write","title":"<code>add_xref_write(classobj, methodobj, offset)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>classobj</code> <code>ClassAnalysis</code> required <code>methodobj</code> <code>MethodAnalysis</code> required <code>offset</code> <code>int</code> <p>offset in the bytecode</p> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def add_xref_write(\n    self, classobj: ClassAnalysis, methodobj: MethodAnalysis, offset: int\n) -&gt; None:\n    \"\"\"\n    :param classobj:\n    :param methodobj:\n    :param offset: offset in the bytecode\n    \"\"\"\n    self.xrefwrite.add((classobj, methodobj, offset))\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.FieldAnalysis.get_field","title":"<code>get_field()</code>","text":"<p>Returns the actual EncodedField object</p> <p>Returns:</p> Type Description <code>EncodedField</code> <p>the <code>dex.EncodedField</code> object</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_field(self) -&gt; dex.EncodedField:\n    \"\"\"\n    Returns the actual [EncodedField][androguard.core.dex.EncodedField] object\n\n    :returns: the `dex.EncodedField` object\n    \"\"\"\n    return self.field\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.FieldAnalysis.get_xref_read","title":"<code>get_xref_read(with_offset=False)</code>","text":"<p>Returns a list of xrefs where the field is read.</p> <p>The list contains tuples of the originating class and methods, where the class is represented as a ClassAnalysis, while the method is a MethodAnalysis.</p> <p>Parameters:</p> Name Type Description Default <code>with_offset</code> <code>bool</code> <p>return the xrefs including the offset</p> <code>False</code> <p>Returns:</p> Type Description <code>list[tuple[ClassAnalysis, MethodAnalysis]]</code> <p>the <code>xrefread</code> list</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_xref_read(\n    self, with_offset: bool = False\n) -&gt; list[tuple[ClassAnalysis, MethodAnalysis]]:\n    \"\"\"\n    Returns a list of xrefs where the field is read.\n\n    The list contains tuples of the originating class and methods,\n    where the class is represented as a [ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis],\n    while the method is a [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis].\n\n    :param with_offset: return the xrefs including the offset\n\n    :returns: the `xrefread` list\n    \"\"\"\n    if with_offset:\n        return self.xrefread\n    # Legacy option, might be removed in the future\n    return set(map(itemgetter(slice(0, 2)), self.xrefread))\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.FieldAnalysis.get_xref_write","title":"<code>get_xref_write(with_offset=False)</code>","text":"<p>Returns a list of xrefs where the field is written to.</p> <p>The list contains tuples of the originating class and methods, where the class is represented as a ClassAnalysis, while the method is a MethodAnalysis`.</p> <p>Parameters:</p> Name Type Description Default <code>with_offset</code> <code>bool</code> <p>return the xrefs including the offset</p> <code>False</code> <p>Returns:</p> Type Description <code>list[tuple[ClassAnalysis, MethodAnalysis]]</code> <p>the <code>xrefwrite</code> list</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_xref_write(\n    self, with_offset: bool = False\n) -&gt; list[tuple[ClassAnalysis, MethodAnalysis]]:\n    \"\"\"\n    Returns a list of xrefs where the field is written to.\n\n    The list contains tuples of the originating class and methods,\n    where the class is represented as a [ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis],\n    while the method is a [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis]`.\n\n    :param with_offset: return the xrefs including the offset\n\n    :returns: the `xrefwrite` list\n    \"\"\"\n    if with_offset:\n        return self.xrefwrite\n    # Legacy option, might be removed in the future\n    return set(map(itemgetter(slice(0, 2)), self.xrefwrite))\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis","title":"<code>MethodAnalysis</code>","text":"<p>This class analyzes in details a method of a class/dex file It is a wrapper around a androguard.core.dex.EncodedMethod and enhances it by using multiple DEXBasicBlock encapsulated in a BasicBlocks object.</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>class MethodAnalysis:\n    \"\"\"\n    This class analyzes in details a method of a class/dex file\n    It is a wrapper around a [androguard.core.dex.EncodedMethod][] and enhances it\n    by using multiple [DEXBasicBlock][androguard.core.analysis.analysis.DEXBasicBlock] encapsulated in a [BasicBlocks][androguard.core.analysis.analysis.BasicBlocks] object.\n    \"\"\"\n    def __init__(self, vm: dex.DEX, method: dex.EncodedMethod) -&gt; None:\n        \"\"\"Initialize new [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis]\n\n        :param vm: the `dex.DEX` containing the method\n        :param method: the `dex.EncodedMethod` to wrap\n        \"\"\"\n        logger.debug(\n            \"Adding new method {} {}\".format(\n                method.get_class_name(), method.get_name()\n            )\n        )\n\n        self.__vm = vm\n        self.method = method\n\n        self.basic_blocks = BasicBlocks()\n        self.exceptions = Exceptions()\n\n        self.xrefto = set()\n        self.xreffrom = set()\n\n        self.xrefread = set()\n        self.xrefwrite = set()\n\n        self.xrefnewinstance = set()\n        self.xrefconstclass = set()\n\n        # For Android 10+\n        self.restriction_flag = None\n        self.domain_flag = None\n\n        # Reserved for further use\n        self.apilist = None\n\n        if vm is None or isinstance(method, ExternalMethod):\n            # Support external methods here\n            # external methods usually dont have a VM associated\n            self.code = None\n        else:\n            self.code = self.method.get_code()\n\n        if self.code:\n            self._create_basic_block()\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Returns the name of this method\n\n        :returns: the name\n        \"\"\"\n        return self.method.get_name()\n\n    @property\n    def descriptor(self) -&gt; str:\n        \"\"\"Returns the type descriptor for this method\n\n        :returns: the type descriptor\n        \"\"\"\n        return self.method.get_descriptor()\n\n    @property\n    def access(self) -&gt; str:\n        \"\"\"Returns the access flags to the method as a string\n\n        :returns: the access flags\n        \"\"\"\n        return self.method.get_access_flags_string()\n\n    @property\n    def class_name(self) -&gt; str:\n        \"\"\"Returns the name of the class of this method\n\n        :returns: the name of the class\n        \"\"\"\n        return self.method.class_name\n\n    @property\n    def full_name(self) -&gt; str:\n        \"\"\"Returns classname + name + descriptor, separated by spaces (no access flags)\n\n        :returns: the method full name\n        \"\"\"\n        return self.method.full_name\n\n    def get_class_name(self) -&gt; str:\n        \"\"\"Return the class name of the method\n\n        :returns: the name of the class\n        \"\"\"\n        return self.class_name\n\n    def get_access_flags_string(self) -&gt; str:\n        \"\"\"Returns the concatenated access flags string\n\n        :returns: the access flags\n        \"\"\"\n        return self.access\n\n    def get_descriptor(self) -&gt; str:\n        return self.descriptor\n\n    def _create_basic_block(self) -&gt; None:\n        \"\"\"\n        Internal Method to create the basic block structure\n        Parses all instructions and exceptions.\n        \"\"\"\n        current_basic = DEXBasicBlock(\n            0, self.__vm, self.method, self.basic_blocks\n        )\n        self.basic_blocks.push(current_basic)\n\n        l = []\n        h = dict()\n\n        logger.debug(\n            \"Parsing instructions for method at @0x{:08x}\".format(\n                self.method.get_code_off()\n            )\n        )\n        for idx, ins in self.method.get_instructions_idx():\n            if ins.get_op_value() in BasicOPCODES:\n                v = dex.determineNext(ins, idx, self.method)\n                h[idx] = v\n                l.extend(v)\n\n        logger.debug(\"Parsing exceptions\")\n        excepts = dex.determineException(self.__vm, self.method)\n        for i in excepts:\n            l.extend([i[0]])\n            for handler in i[2:]:\n                l.append(handler[1])\n\n        logger.debug(\"Creating basic blocks\")\n        for idx, ins in self.method.get_instructions_idx():\n            # index is a destination\n            if idx in l:\n                if current_basic.get_nb_instructions() != 0:\n                    current_basic = DEXBasicBlock(\n                        current_basic.get_end(),\n                        self.__vm,\n                        self.method,\n                        self.basic_blocks,\n                    )\n                    self.basic_blocks.push(current_basic)\n\n            current_basic.push(ins)\n\n            # index is a branch instruction\n            if idx in h:\n                current_basic = DEXBasicBlock(\n                    current_basic.get_end(),\n                    self.__vm,\n                    self.method,\n                    self.basic_blocks,\n                )\n                self.basic_blocks.push(current_basic)\n\n        if current_basic.get_nb_instructions() == 0:\n            self.basic_blocks.pop(-1)\n\n        logger.debug(\"Settings basic blocks childs\")\n        for i in self.basic_blocks.get():\n            try:\n                i.set_childs(h[i.end - i.get_last_length()])\n            except KeyError:\n                i.set_childs([])\n\n        logger.debug(\"Creating exceptions\")\n        self.exceptions.add(excepts, self.basic_blocks)\n\n        for i in self.basic_blocks.get():\n            # setup exception by basic block\n            i.set_exception_analysis(\n                self.exceptions.get_exception(i.start, i.end - 1)\n            )\n\n    def add_xref_read(\n        self, classobj: ClassAnalysis, fieldobj: FieldAnalysis, offset: int\n    ) -&gt; None:\n        \"\"\"\n        :param ClassAnalysis classobj:\n        :param FieldAnalysis fieldobj:\n        :param int offset: offset in the bytecode\n        \"\"\"\n        self.xrefread.add((classobj, fieldobj, offset))\n\n    def add_xref_write(\n        self, classobj: ClassAnalysis, fieldobj: FieldAnalysis, offset: int\n    ) -&gt; None:\n        \"\"\"\n        :param ClassAnalysis classobj:\n        :param FieldAnalysis fieldobj:\n        :param int offset: offset in the bytecode\n        \"\"\"\n        self.xrefwrite.add((classobj, fieldobj, offset))\n\n    def get_xref_read(self) -&gt; list[tuple[ClassAnalysis, FieldAnalysis]]:\n        \"\"\"\n        Returns a list of xrefs where a field is read by this method.\n\n        The list contains tuples of the originating class and methods,\n        where the class is represented as a [ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis],\n        while the Field is a [FieldAnalysis][androguard.core.analysis.analysis.FieldAnalysis].\n\n        :returns: the `xrefread` list\n        \"\"\"\n        return self.xrefread\n\n    def get_xref_write(self) -&gt; list[tuple[ClassAnalysis, FieldAnalysis]]:\n        \"\"\"\n        Returns a list of xrefs where a field is written to by this method.\n\n        The list contains tuples of the originating class and methods,\n        where the class is represented as a [ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis],\n        while the Field is a [FieldAnalysis][androguard.core.analysis.analysis.FieldAnalysis].\n\n        :returns: the `xrefwrite` list\n        \"\"\"\n        return self.xrefwrite\n\n    def add_xref_to(\n        self, classobj: ClassAnalysis, methodobj: MethodAnalysis, offset: int\n    ) -&gt; None:\n        \"\"\"\n        Add a crossreference to another method\n        (this method calls another method)\n        \"\"\"\n        self.xrefto.add((classobj, methodobj, offset))\n\n    def add_xref_from(\n        self, classobj: ClassAnalysis, methodobj: MethodAnalysis, offset: int\n    ) -&gt; None:\n        \"\"\"\n        Add a crossrefernece from another method\n        (this method is called by another method)\n        \"\"\"\n        self.xreffrom.add((classobj, methodobj, offset))\n\n    def get_xref_from(self) -&gt; list[tuple[ClassAnalysis, MethodAnalysis, int]]:\n        \"\"\"\n        Returns a list of tuples containing the class, method and offset of\n        the call, from where this object was called.\n\n        The list of tuples has the form:\n        ([ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis],\n        [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis],\n        `int`)\n\n        :returns: the `xreffrom` list\n        \"\"\"\n        return self.xreffrom\n\n    def get_xref_to(self) -&gt; list[tuple[ClassAnalysis, MethodAnalysis, int]]:\n        \"\"\"\n        Returns a list of tuples containing the class, method and offset of\n        the call, which are called by this method.\n\n        The list of tuples has the form:\n        ([ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis],\n        [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis],\n        `int`)\n\n        :returns: the `xrefto` list\n        \"\"\"\n        return self.xrefto\n\n    def add_xref_new_instance(\n        self, classobj: ClassAnalysis, offset: int\n    ) -&gt; None:\n        \"\"\"\n        Add a crossreference to another class that is\n        instanced within this method.\n        \"\"\"\n        self.xrefnewinstance.add((classobj, offset))\n\n    def get_xref_new_instance(self) -&gt; list[tuple[ClassAnalysis, int]]:\n        \"\"\"\n        Returns a list of tuples containing the class and offset of\n        the creation of a new instance of a class by this method.\n\n        The list of tuples has the form:\n        ([ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis],\n        `int`)\n\n        :returns: the `xrefnewinstance` list\n        \"\"\"\n        return self.xrefnewinstance\n\n    def add_xref_const_class(\n        self, classobj: ClassAnalysis, offset: int\n    ) -&gt; None:\n        \"\"\"\n        Add a crossreference to another classtype.\n        \"\"\"\n        self.xrefconstclass.add((classobj, offset))\n\n    def get_xref_const_class(self) -&gt; list[tuple[ClassAnalysis, int]]:\n        \"\"\"\n        Returns a list of tuples containing the class and offset of\n        the references to another classtype by this method.\n\n        The list of tuples has the form:\n        ([ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis],\n        `int`)\n\n        :returns: the `xrefconstclass` list\n        \"\"\"\n        return self.xrefconstclass\n\n    def is_external(self) -&gt; bool:\n        \"\"\"\n        Returns `True` if the underlying method is external\n\n        :returns: `True` if the underlying method is external, else `False`\n        \"\"\"\n        return isinstance(self.method, ExternalMethod)\n\n    def is_android_api(self) -&gt; bool:\n        \"\"\"\n        Returns `True` if the method seems to be an Android API method.\n\n        This method might be not very precise unless an list of known API methods\n        is given.\n\n        :returns: `True` if the method seems to be an Android API method, else `False`\n        \"\"\"\n        if not self.is_external():\n            # Method must be external to be an API\n            return False\n\n        # Packages found at https://developer.android.com/reference/packages.html\n        api_candidates = [\n            \"Landroid/\",\n            \"Lcom/android/internal/util\",\n            \"Ldalvik/\",\n            \"Ljava/\",\n            \"Ljavax/\",\n            \"Lorg/apache/\",\n            \"Lorg/json/\",\n            \"Lorg/w3c/dom/\",\n            \"Lorg/xml/sax\",\n            \"Lorg/xmlpull/v1/\",\n            \"Ljunit/\",\n        ]\n\n        if self.apilist:\n            # FIXME: This will not work... need to introduce a name for lookup (like EncodedMethod.__str__ but without\n            # the offset! Such a name is also needed for the lookup in permissions\n            return self.method.get_name() in self.apilist\n        else:\n            for candidate in api_candidates:\n                if self.method.get_class_name().startswith(candidate):\n                    return True\n\n        return False\n\n    def get_basic_blocks(self) -&gt; BasicBlocks:\n        \"\"\"\n        Returns the [BasicBlocks][androguard.core.analysis.analysis.BasicBlocks] generated for this method.\n        The [BasicBlocks][androguard.core.analysis.analysis.BasicBlocks] can be used to get a control flow graph (CFG) of the method.\n\n        :returns: a `BasicBlocks` object\n        \"\"\"\n        return self.basic_blocks\n\n    def get_length(self) -&gt; int:\n        \"\"\"\n        :returns: an integer which is the length of the code\n        \"\"\"\n        return self.code.get_length() if self.code else 0\n\n    def get_vm(self) -&gt; dex.DEX:\n        \"\"\"\n        :returns: the `dex.DEX` object\n        \"\"\"\n        return self.__vm\n\n    def get_method(self) -&gt; dex.EncodedMethod:\n        \"\"\"\n        :returns: the `dex.EncodedMethod` object\n        \"\"\"\n        return self.method\n\n    def show(self) -&gt; None:\n        \"\"\"\n        Prints the content of this method to stdout.\n\n        This will print the method signature and the decompiled code.\n        \"\"\"\n        args, ret = self.method.get_descriptor()[1:].split(\")\")\n        if self.code:\n            # We patch the descriptor here and add the registers, if code is available\n            args = args.split(\" \")\n\n            reg_len = self.code.get_registers_size()\n            nb_args = len(args)\n\n            start_reg = reg_len - nb_args\n            args = [\n                \"{} v{}\".format(a, start_reg + i) for i, a in enumerate(args)\n            ]\n\n        print(\n            \"METHOD {} {} {} ({}){}\".format(\n                self.method.get_class_name(),\n                self.method.get_access_flags_string(),\n                self.method.get_name(),\n                \", \".join(args),\n                ret,\n            )\n        )\n\n        if not self.is_external():\n            bytecode.PrettyShow(self.basic_blocks.gets(), self.method.notes)\n\n    def show_xrefs(self) -&gt; None:\n        data = \"XREFto for %s\\n\" % self.method\n        for ref_class, ref_method, offset in self.xrefto:\n            data += \"in\\n\"\n            data += \"{}:{} @0x{:x}\\n\".format(\n                ref_class.get_vm_class().get_name(), ref_method, offset\n            )\n\n        data += \"XREFFrom for %s\\n\" % self.method\n        for ref_class, ref_method, offset in self.xreffrom:\n            data += \"in\\n\"\n            data += \"{}:{} @0x{:x}\\n\".format(\n                ref_class.get_vm_class().get_name(), ref_method, offset\n            )\n\n        return data\n\n    def __repr__(self):\n        return \"&lt;analysis.MethodAnalysis {}&gt;\".format(self.method)\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.access","title":"<code>access</code>  <code>property</code>","text":"<p>Returns the access flags to the method as a string</p> <p>Returns:</p> Type Description <code>str</code> <p>the access flags</p>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.class_name","title":"<code>class_name</code>  <code>property</code>","text":"<p>Returns the name of the class of this method</p> <p>Returns:</p> Type Description <code>str</code> <p>the name of the class</p>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.descriptor","title":"<code>descriptor</code>  <code>property</code>","text":"<p>Returns the type descriptor for this method</p> <p>Returns:</p> Type Description <code>str</code> <p>the type descriptor</p>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.full_name","title":"<code>full_name</code>  <code>property</code>","text":"<p>Returns classname + name + descriptor, separated by spaces (no access flags)</p> <p>Returns:</p> Type Description <code>str</code> <p>the method full name</p>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.name","title":"<code>name</code>  <code>property</code>","text":"<p>Returns the name of this method</p> <p>Returns:</p> Type Description <code>str</code> <p>the name</p>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.__init__","title":"<code>__init__(vm, method)</code>","text":"<p>Initialize new MethodAnalysis</p> <p>Parameters:</p> Name Type Description Default <code>vm</code> <code>DEX</code> <p>the <code>dex.DEX</code> containing the method</p> required <code>method</code> <code>EncodedMethod</code> <p>the <code>dex.EncodedMethod</code> to wrap</p> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def __init__(self, vm: dex.DEX, method: dex.EncodedMethod) -&gt; None:\n    \"\"\"Initialize new [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis]\n\n    :param vm: the `dex.DEX` containing the method\n    :param method: the `dex.EncodedMethod` to wrap\n    \"\"\"\n    logger.debug(\n        \"Adding new method {} {}\".format(\n            method.get_class_name(), method.get_name()\n        )\n    )\n\n    self.__vm = vm\n    self.method = method\n\n    self.basic_blocks = BasicBlocks()\n    self.exceptions = Exceptions()\n\n    self.xrefto = set()\n    self.xreffrom = set()\n\n    self.xrefread = set()\n    self.xrefwrite = set()\n\n    self.xrefnewinstance = set()\n    self.xrefconstclass = set()\n\n    # For Android 10+\n    self.restriction_flag = None\n    self.domain_flag = None\n\n    # Reserved for further use\n    self.apilist = None\n\n    if vm is None or isinstance(method, ExternalMethod):\n        # Support external methods here\n        # external methods usually dont have a VM associated\n        self.code = None\n    else:\n        self.code = self.method.get_code()\n\n    if self.code:\n        self._create_basic_block()\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.add_xref_const_class","title":"<code>add_xref_const_class(classobj, offset)</code>","text":"<p>Add a crossreference to another classtype.</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def add_xref_const_class(\n    self, classobj: ClassAnalysis, offset: int\n) -&gt; None:\n    \"\"\"\n    Add a crossreference to another classtype.\n    \"\"\"\n    self.xrefconstclass.add((classobj, offset))\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.add_xref_from","title":"<code>add_xref_from(classobj, methodobj, offset)</code>","text":"<p>Add a crossrefernece from another method (this method is called by another method)</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def add_xref_from(\n    self, classobj: ClassAnalysis, methodobj: MethodAnalysis, offset: int\n) -&gt; None:\n    \"\"\"\n    Add a crossrefernece from another method\n    (this method is called by another method)\n    \"\"\"\n    self.xreffrom.add((classobj, methodobj, offset))\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.add_xref_new_instance","title":"<code>add_xref_new_instance(classobj, offset)</code>","text":"<p>Add a crossreference to another class that is instanced within this method.</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def add_xref_new_instance(\n    self, classobj: ClassAnalysis, offset: int\n) -&gt; None:\n    \"\"\"\n    Add a crossreference to another class that is\n    instanced within this method.\n    \"\"\"\n    self.xrefnewinstance.add((classobj, offset))\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.add_xref_read","title":"<code>add_xref_read(classobj, fieldobj, offset)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>classobj</code> <code>ClassAnalysis</code> required <code>fieldobj</code> <code>FieldAnalysis</code> required <code>offset</code> <code>int</code> <p>offset in the bytecode</p> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def add_xref_read(\n    self, classobj: ClassAnalysis, fieldobj: FieldAnalysis, offset: int\n) -&gt; None:\n    \"\"\"\n    :param ClassAnalysis classobj:\n    :param FieldAnalysis fieldobj:\n    :param int offset: offset in the bytecode\n    \"\"\"\n    self.xrefread.add((classobj, fieldobj, offset))\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.add_xref_to","title":"<code>add_xref_to(classobj, methodobj, offset)</code>","text":"<p>Add a crossreference to another method (this method calls another method)</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def add_xref_to(\n    self, classobj: ClassAnalysis, methodobj: MethodAnalysis, offset: int\n) -&gt; None:\n    \"\"\"\n    Add a crossreference to another method\n    (this method calls another method)\n    \"\"\"\n    self.xrefto.add((classobj, methodobj, offset))\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.add_xref_write","title":"<code>add_xref_write(classobj, fieldobj, offset)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>classobj</code> <code>ClassAnalysis</code> required <code>fieldobj</code> <code>FieldAnalysis</code> required <code>offset</code> <code>int</code> <p>offset in the bytecode</p> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def add_xref_write(\n    self, classobj: ClassAnalysis, fieldobj: FieldAnalysis, offset: int\n) -&gt; None:\n    \"\"\"\n    :param ClassAnalysis classobj:\n    :param FieldAnalysis fieldobj:\n    :param int offset: offset in the bytecode\n    \"\"\"\n    self.xrefwrite.add((classobj, fieldobj, offset))\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.get_access_flags_string","title":"<code>get_access_flags_string()</code>","text":"<p>Returns the concatenated access flags string</p> <p>Returns:</p> Type Description <code>str</code> <p>the access flags</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_access_flags_string(self) -&gt; str:\n    \"\"\"Returns the concatenated access flags string\n\n    :returns: the access flags\n    \"\"\"\n    return self.access\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.get_basic_blocks","title":"<code>get_basic_blocks()</code>","text":"<p>Returns the BasicBlocks generated for this method. The BasicBlocks can be used to get a control flow graph (CFG) of the method.</p> <p>Returns:</p> Type Description <code>BasicBlocks</code> <p>a <code>BasicBlocks</code> object</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_basic_blocks(self) -&gt; BasicBlocks:\n    \"\"\"\n    Returns the [BasicBlocks][androguard.core.analysis.analysis.BasicBlocks] generated for this method.\n    The [BasicBlocks][androguard.core.analysis.analysis.BasicBlocks] can be used to get a control flow graph (CFG) of the method.\n\n    :returns: a `BasicBlocks` object\n    \"\"\"\n    return self.basic_blocks\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.get_class_name","title":"<code>get_class_name()</code>","text":"<p>Return the class name of the method</p> <p>Returns:</p> Type Description <code>str</code> <p>the name of the class</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_class_name(self) -&gt; str:\n    \"\"\"Return the class name of the method\n\n    :returns: the name of the class\n    \"\"\"\n    return self.class_name\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.get_length","title":"<code>get_length()</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>an integer which is the length of the code</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_length(self) -&gt; int:\n    \"\"\"\n    :returns: an integer which is the length of the code\n    \"\"\"\n    return self.code.get_length() if self.code else 0\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.get_method","title":"<code>get_method()</code>","text":"<p>Returns:</p> Type Description <code>EncodedMethod</code> <p>the <code>dex.EncodedMethod</code> object</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_method(self) -&gt; dex.EncodedMethod:\n    \"\"\"\n    :returns: the `dex.EncodedMethod` object\n    \"\"\"\n    return self.method\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.get_vm","title":"<code>get_vm()</code>","text":"<p>Returns:</p> Type Description <code>DEX</code> <p>the <code>dex.DEX</code> object</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_vm(self) -&gt; dex.DEX:\n    \"\"\"\n    :returns: the `dex.DEX` object\n    \"\"\"\n    return self.__vm\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.get_xref_const_class","title":"<code>get_xref_const_class()</code>","text":"<p>Returns a list of tuples containing the class and offset of the references to another classtype by this method.</p> <p>The list of tuples has the form: (ClassAnalysis, <code>int</code>)</p> <p>Returns:</p> Type Description <code>list[tuple[ClassAnalysis, int]]</code> <p>the <code>xrefconstclass</code> list</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_xref_const_class(self) -&gt; list[tuple[ClassAnalysis, int]]:\n    \"\"\"\n    Returns a list of tuples containing the class and offset of\n    the references to another classtype by this method.\n\n    The list of tuples has the form:\n    ([ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis],\n    `int`)\n\n    :returns: the `xrefconstclass` list\n    \"\"\"\n    return self.xrefconstclass\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.get_xref_from","title":"<code>get_xref_from()</code>","text":"<p>Returns a list of tuples containing the class, method and offset of the call, from where this object was called.</p> <p>The list of tuples has the form: (ClassAnalysis, MethodAnalysis, <code>int</code>)</p> <p>Returns:</p> Type Description <code>list[tuple[ClassAnalysis, MethodAnalysis, int]]</code> <p>the <code>xreffrom</code> list</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_xref_from(self) -&gt; list[tuple[ClassAnalysis, MethodAnalysis, int]]:\n    \"\"\"\n    Returns a list of tuples containing the class, method and offset of\n    the call, from where this object was called.\n\n    The list of tuples has the form:\n    ([ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis],\n    [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis],\n    `int`)\n\n    :returns: the `xreffrom` list\n    \"\"\"\n    return self.xreffrom\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.get_xref_new_instance","title":"<code>get_xref_new_instance()</code>","text":"<p>Returns a list of tuples containing the class and offset of the creation of a new instance of a class by this method.</p> <p>The list of tuples has the form: (ClassAnalysis, <code>int</code>)</p> <p>Returns:</p> Type Description <code>list[tuple[ClassAnalysis, int]]</code> <p>the <code>xrefnewinstance</code> list</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_xref_new_instance(self) -&gt; list[tuple[ClassAnalysis, int]]:\n    \"\"\"\n    Returns a list of tuples containing the class and offset of\n    the creation of a new instance of a class by this method.\n\n    The list of tuples has the form:\n    ([ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis],\n    `int`)\n\n    :returns: the `xrefnewinstance` list\n    \"\"\"\n    return self.xrefnewinstance\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.get_xref_read","title":"<code>get_xref_read()</code>","text":"<p>Returns a list of xrefs where a field is read by this method.</p> <p>The list contains tuples of the originating class and methods, where the class is represented as a ClassAnalysis, while the Field is a FieldAnalysis.</p> <p>Returns:</p> Type Description <code>list[tuple[ClassAnalysis, FieldAnalysis]]</code> <p>the <code>xrefread</code> list</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_xref_read(self) -&gt; list[tuple[ClassAnalysis, FieldAnalysis]]:\n    \"\"\"\n    Returns a list of xrefs where a field is read by this method.\n\n    The list contains tuples of the originating class and methods,\n    where the class is represented as a [ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis],\n    while the Field is a [FieldAnalysis][androguard.core.analysis.analysis.FieldAnalysis].\n\n    :returns: the `xrefread` list\n    \"\"\"\n    return self.xrefread\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.get_xref_to","title":"<code>get_xref_to()</code>","text":"<p>Returns a list of tuples containing the class, method and offset of the call, which are called by this method.</p> <p>The list of tuples has the form: (ClassAnalysis, MethodAnalysis, <code>int</code>)</p> <p>Returns:</p> Type Description <code>list[tuple[ClassAnalysis, MethodAnalysis, int]]</code> <p>the <code>xrefto</code> list</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_xref_to(self) -&gt; list[tuple[ClassAnalysis, MethodAnalysis, int]]:\n    \"\"\"\n    Returns a list of tuples containing the class, method and offset of\n    the call, which are called by this method.\n\n    The list of tuples has the form:\n    ([ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis],\n    [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis],\n    `int`)\n\n    :returns: the `xrefto` list\n    \"\"\"\n    return self.xrefto\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.get_xref_write","title":"<code>get_xref_write()</code>","text":"<p>Returns a list of xrefs where a field is written to by this method.</p> <p>The list contains tuples of the originating class and methods, where the class is represented as a ClassAnalysis, while the Field is a FieldAnalysis.</p> <p>Returns:</p> Type Description <code>list[tuple[ClassAnalysis, FieldAnalysis]]</code> <p>the <code>xrefwrite</code> list</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_xref_write(self) -&gt; list[tuple[ClassAnalysis, FieldAnalysis]]:\n    \"\"\"\n    Returns a list of xrefs where a field is written to by this method.\n\n    The list contains tuples of the originating class and methods,\n    where the class is represented as a [ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis],\n    while the Field is a [FieldAnalysis][androguard.core.analysis.analysis.FieldAnalysis].\n\n    :returns: the `xrefwrite` list\n    \"\"\"\n    return self.xrefwrite\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.is_android_api","title":"<code>is_android_api()</code>","text":"<p>Returns <code>True</code> if the method seems to be an Android API method.</p> <p>This method might be not very precise unless an list of known API methods is given.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the method seems to be an Android API method, else <code>False</code></p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def is_android_api(self) -&gt; bool:\n    \"\"\"\n    Returns `True` if the method seems to be an Android API method.\n\n    This method might be not very precise unless an list of known API methods\n    is given.\n\n    :returns: `True` if the method seems to be an Android API method, else `False`\n    \"\"\"\n    if not self.is_external():\n        # Method must be external to be an API\n        return False\n\n    # Packages found at https://developer.android.com/reference/packages.html\n    api_candidates = [\n        \"Landroid/\",\n        \"Lcom/android/internal/util\",\n        \"Ldalvik/\",\n        \"Ljava/\",\n        \"Ljavax/\",\n        \"Lorg/apache/\",\n        \"Lorg/json/\",\n        \"Lorg/w3c/dom/\",\n        \"Lorg/xml/sax\",\n        \"Lorg/xmlpull/v1/\",\n        \"Ljunit/\",\n    ]\n\n    if self.apilist:\n        # FIXME: This will not work... need to introduce a name for lookup (like EncodedMethod.__str__ but without\n        # the offset! Such a name is also needed for the lookup in permissions\n        return self.method.get_name() in self.apilist\n    else:\n        for candidate in api_candidates:\n            if self.method.get_class_name().startswith(candidate):\n                return True\n\n    return False\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.is_external","title":"<code>is_external()</code>","text":"<p>Returns <code>True</code> if the underlying method is external</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the underlying method is external, else <code>False</code></p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def is_external(self) -&gt; bool:\n    \"\"\"\n    Returns `True` if the underlying method is external\n\n    :returns: `True` if the underlying method is external, else `False`\n    \"\"\"\n    return isinstance(self.method, ExternalMethod)\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.MethodAnalysis.show","title":"<code>show()</code>","text":"<p>Prints the content of this method to stdout.</p> <p>This will print the method signature and the decompiled code.</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"\n    Prints the content of this method to stdout.\n\n    This will print the method signature and the decompiled code.\n    \"\"\"\n    args, ret = self.method.get_descriptor()[1:].split(\")\")\n    if self.code:\n        # We patch the descriptor here and add the registers, if code is available\n        args = args.split(\" \")\n\n        reg_len = self.code.get_registers_size()\n        nb_args = len(args)\n\n        start_reg = reg_len - nb_args\n        args = [\n            \"{} v{}\".format(a, start_reg + i) for i, a in enumerate(args)\n        ]\n\n    print(\n        \"METHOD {} {} {} ({}){}\".format(\n            self.method.get_class_name(),\n            self.method.get_access_flags_string(),\n            self.method.get_name(),\n            \", \".join(args),\n            ret,\n        )\n    )\n\n    if not self.is_external():\n        bytecode.PrettyShow(self.basic_blocks.gets(), self.method.notes)\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.REF_TYPE","title":"<code>REF_TYPE</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Stores the opcodes for the type of usage in an XREF.</p> <p>Used in ClassAnalysis to store the type of reference to the class.</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>class REF_TYPE(IntEnum):\n    \"\"\"\n    Stores the opcodes for the type of usage in an XREF.\n\n    Used in [ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis] to store the type of reference to the class.\n    \"\"\"\n\n    REF_NEW_INSTANCE = 0x22\n    REF_CLASS_USAGE = 0x1C\n    INVOKE_VIRTUAL = 0x6E\n    INVOKE_SUPER = 0x6F\n    INVOKE_DIRECT = 0x70\n    INVOKE_STATIC = 0x71\n    INVOKE_INTERFACE = 0x72\n    INVOKE_VIRTUAL_RANGE = 0x74\n    INVOKE_SUPER_RANGE = 0x75\n    INVOKE_DIRECT_RANGE = 0x76\n    INVOKE_STATIC_RANGE = 0x77\n    INVOKE_INTERFACE_RANGE = 0x78\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.StringAnalysis","title":"<code>StringAnalysis</code>","text":"<p>StringAnalysis contains the XREFs of a string.</p> <p>As Strings are only used as a source, they only contain the XREF_FROM set, i.e. where the string is used.</p> <p>This Array stores the information in which method the String is used.</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>class StringAnalysis:\n    \"\"\"\n    StringAnalysis contains the XREFs of a string.\n\n    As Strings are only used as a source, they only contain\n    the XREF_FROM set, i.e. where the string is used.\n\n    This Array stores the information in which method the String is used.\n    \"\"\"\n\n    def __init__(self, value: str) -&gt; None:\n        \"\"\"Instantiate a new [StringAnalysis][androguard.core.analysis.analysis.StringAnalysis]\n\n        :param value: the original string value\n        \"\"\"\n        self.value = value\n        self.orig_value = value\n        self.xreffrom = set()\n\n    def add_xref_from(\n        self, classobj: ClassAnalysis, methodobj: MethodAnalysis, off: int\n    ) -&gt; None:\n        \"\"\"\n        Adds a xref from the given method to this string\n\n        :param classobj:\n        :param methodobj:\n        :param off: offset in the bytecode of the call\n        \"\"\"\n        self.xreffrom.add((classobj, methodobj, off))\n\n    def get_xref_from(\n        self, with_offset: bool = False\n    ) -&gt; list[tuple[ClassAnalysis, MethodAnalysis]]:\n        \"\"\"\n        Returns a list of xrefs accessing the String.\n\n        The list contains tuples of the originating class and methods,\n        where the class is represented as a [ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis],\n        while the method is a [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis].\n        \"\"\"\n        if with_offset:\n            return self.xreffrom\n        return set(map(itemgetter(slice(0, 2)), self.xreffrom))\n\n    def set_value(self, value: str) -&gt; None:\n        \"\"\"\n        Overwrite the current value of the String with a new value.\n        The original value is not lost and can still be retrieved using [get_orig_value][androguard.core.analysis.analysis.StringAnalysis.get_orig_value].\n\n        :param value: new string value\n        \"\"\"\n        self.value = value\n\n    def get_value(self) -&gt; str:\n        \"\"\"\n        Return the (possible overwritten) value of the string\n\n        :returns: the value of the string\n        \"\"\"\n        return self.value\n\n    def get_orig_value(self) -&gt; str:\n        \"\"\"\n        Return the original, read only, value of the string\n\n        :returns: the original value\n        \"\"\"\n        return self.orig_value\n\n    def is_overwritten(self) -&gt; bool:\n        \"\"\"\n        Returns `True` if the string was overwritten\n        :returns: `True` if the string was overwritten, else `False`\n        \"\"\"\n        return self.orig_value != self.value\n\n    def __str__(self):\n        data = \"XREFto for string %s in\\n\" % repr(self.get_value())\n        for ref_class, ref_method, _ in self.xreffrom:\n            data += \"{}:{}\\n\".format(\n                ref_class.get_vm_class().get_name(), ref_method\n            )\n        return data\n\n    def __repr__(self):\n        # TODO should remove all chars that are not pleasent. e.g. newlines\n        if len(self.get_value()) &gt; 20:\n            s = \"'{}'...\".format(self.get_value()[:20])\n        else:\n            s = \"'{}'\".format(self.get_value())\n        return \"&lt;analysis.StringAnalysis {}&gt;\".format(s)\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.StringAnalysis.__init__","title":"<code>__init__(value)</code>","text":"<p>Instantiate a new StringAnalysis</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>the original string value</p> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def __init__(self, value: str) -&gt; None:\n    \"\"\"Instantiate a new [StringAnalysis][androguard.core.analysis.analysis.StringAnalysis]\n\n    :param value: the original string value\n    \"\"\"\n    self.value = value\n    self.orig_value = value\n    self.xreffrom = set()\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.StringAnalysis.add_xref_from","title":"<code>add_xref_from(classobj, methodobj, off)</code>","text":"<p>Adds a xref from the given method to this string</p> <p>Parameters:</p> Name Type Description Default <code>classobj</code> <code>ClassAnalysis</code> required <code>methodobj</code> <code>MethodAnalysis</code> required <code>off</code> <code>int</code> <p>offset in the bytecode of the call</p> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def add_xref_from(\n    self, classobj: ClassAnalysis, methodobj: MethodAnalysis, off: int\n) -&gt; None:\n    \"\"\"\n    Adds a xref from the given method to this string\n\n    :param classobj:\n    :param methodobj:\n    :param off: offset in the bytecode of the call\n    \"\"\"\n    self.xreffrom.add((classobj, methodobj, off))\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.StringAnalysis.get_orig_value","title":"<code>get_orig_value()</code>","text":"<p>Return the original, read only, value of the string</p> <p>Returns:</p> Type Description <code>str</code> <p>the original value</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_orig_value(self) -&gt; str:\n    \"\"\"\n    Return the original, read only, value of the string\n\n    :returns: the original value\n    \"\"\"\n    return self.orig_value\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.StringAnalysis.get_value","title":"<code>get_value()</code>","text":"<p>Return the (possible overwritten) value of the string</p> <p>Returns:</p> Type Description <code>str</code> <p>the value of the string</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_value(self) -&gt; str:\n    \"\"\"\n    Return the (possible overwritten) value of the string\n\n    :returns: the value of the string\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.StringAnalysis.get_xref_from","title":"<code>get_xref_from(with_offset=False)</code>","text":"<p>Returns a list of xrefs accessing the String.</p> <p>The list contains tuples of the originating class and methods, where the class is represented as a ClassAnalysis, while the method is a MethodAnalysis.</p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def get_xref_from(\n    self, with_offset: bool = False\n) -&gt; list[tuple[ClassAnalysis, MethodAnalysis]]:\n    \"\"\"\n    Returns a list of xrefs accessing the String.\n\n    The list contains tuples of the originating class and methods,\n    where the class is represented as a [ClassAnalysis][androguard.core.analysis.analysis.ClassAnalysis],\n    while the method is a [MethodAnalysis][androguard.core.analysis.analysis.MethodAnalysis].\n    \"\"\"\n    if with_offset:\n        return self.xreffrom\n    return set(map(itemgetter(slice(0, 2)), self.xreffrom))\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.StringAnalysis.is_overwritten","title":"<code>is_overwritten()</code>","text":"<p>Returns <code>True</code> if the string was overwritten</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the string was overwritten, else <code>False</code></p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def is_overwritten(self) -&gt; bool:\n    \"\"\"\n    Returns `True` if the string was overwritten\n    :returns: `True` if the string was overwritten, else `False`\n    \"\"\"\n    return self.orig_value != self.value\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.StringAnalysis.set_value","title":"<code>set_value(value)</code>","text":"<p>Overwrite the current value of the String with a new value. The original value is not lost and can still be retrieved using get_orig_value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>new string value</p> required Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def set_value(self, value: str) -&gt; None:\n    \"\"\"\n    Overwrite the current value of the String with a new value.\n    The original value is not lost and can still be retrieved using [get_orig_value][androguard.core.analysis.analysis.StringAnalysis.get_orig_value].\n\n    :param value: new string value\n    \"\"\"\n    self.value = value\n</code></pre>"},{"location":"reference/androguard/core/analysis/analysis.html#androguard.core.analysis.analysis.is_ascii_obfuscation","title":"<code>is_ascii_obfuscation(vm)</code>","text":"<p>Tests if any class inside a DEX uses ASCII Obfuscation (e.g. UTF-8 Chars in Classnames)</p> <p>Parameters:</p> Name Type Description Default <code>vm</code> <code>DEX</code> <p><code>DEX</code></p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if ascii obfuscation otherwise <code>False</code></p> Source code in <code>androguard/core/analysis/analysis.py</code> <pre><code>def is_ascii_obfuscation(vm: dex.DEX) -&gt; bool:\n    \"\"\"\n    Tests if any class inside a [DEX][androguard.core.dex.DEX]\n    uses ASCII Obfuscation (e.g. UTF-8 Chars in Classnames)\n\n    :param vm: `DEX`\n    :returns: `True` if ascii obfuscation otherwise `False`\n    \"\"\"\n    for classe in vm.get_classes():\n        if is_ascii_problem(classe.get_name()):\n            return True\n        for method in classe.get_methods():\n            if is_ascii_problem(method.get_name()):\n                return True\n    return False\n</code></pre>"},{"location":"reference/androguard/core/api_specific_resources/index.html","title":"api_specific_resources","text":""},{"location":"reference/androguard/core/api_specific_resources/index.html#androguard.core.api_specific_resources.load_permission_mappings","title":"<code>load_permission_mappings(apilevel)</code>","text":"<p>Load the API/Permission mapping for the requested API level. If the requetsed level was not found, None is returned.</p> <p>Parameters:</p> Name Type Description Default <code>apilevel</code> <code>Union[str, int]</code> <p>integer value of the API level, i.e. 24 for Android 7.0</p> required <p>Returns:</p> Type Description <code>dict[str, list[str]]</code> <p>a dictionary of {MethodSignature: [List of Permissions]}</p> Source code in <code>androguard/core/api_specific_resources/__init__.py</code> <pre><code>def load_permission_mappings(\n    apilevel: Union[str, int]\n) -&gt; dict[str, list[str]]:\n    \"\"\"\n    Load the API/Permission mapping for the requested API level.\n    If the requetsed level was not found, None is returned.\n\n    :param apilevel: integer value of the API level, i.e. 24 for Android 7.0\n    :return: a dictionary of {MethodSignature: [List of Permissions]}\n    \"\"\"\n    root = os.path.dirname(os.path.realpath(__file__))\n    permissions_file = os.path.join(\n        root, \"api_permission_mappings\", \"permissions_{}.json\".format(apilevel)\n    )\n\n    if not os.path.isfile(permissions_file):\n        return {}\n\n    with open(permissions_file, \"r\") as fp:\n        return json.load(fp)\n</code></pre>"},{"location":"reference/androguard/core/api_specific_resources/index.html#androguard.core.api_specific_resources.load_permissions","title":"<code>load_permissions(apilevel, permtype='permissions')</code>","text":"<p>Load the Permissions for the given apilevel.</p> <p>The permissions lists are generated using this tool: https://github.com/U039b/aosp_permissions_extraction</p> <p>Has a fallback to select the maximum or minimal available API level. For example, if 28 is requested but only 26 is available, 26 is returned. If 5 is requested but 16 is available, 16 is returned.</p> <p>If an API level is requested which is in between of two API levels we got, the lower level is returned. For example, if 5,6,7,10 is available and 8 is requested, 7 is returned instead.</p> <p>Parameters:</p> Name Type Description Default <code>apilevel</code> <code>Union[str, int]</code> <p>integer value of the API level</p> required <code>permtype</code> <code>str</code> <p>either load permissions (<code>'permissions'</code>) or permission groups (<code>'groups'</code>)</p> <code>'permissions'</code> <p>Returns:</p> Type Description <code>dict[str, dict[str, str]]</code> <p>a dictionary of {Permission Name: {Permission info}</p> Source code in <code>androguard/core/api_specific_resources/__init__.py</code> <pre><code>def load_permissions(\n    apilevel: Union[str, int], permtype: str = 'permissions'\n) -&gt; dict[str, dict[str, str]]:\n    \"\"\"\n    Load the Permissions for the given apilevel.\n\n    The permissions lists are generated using this tool: https://github.com/U039b/aosp_permissions_extraction\n\n    Has a fallback to select the maximum or minimal available API level.\n    For example, if 28 is requested but only 26 is available, 26 is returned.\n    If 5 is requested but 16 is available, 16 is returned.\n\n    If an API level is requested which is in between of two API levels we got,\n    the lower level is returned. For example, if 5,6,7,10 is available and 8 is\n    requested, 7 is returned instead.\n\n    :param apilevel:  integer value of the API level\n    :param permtype: either load permissions (`'permissions'`) or\n    permission groups (`'groups'`)\n    :return: a dictionary of {Permission Name: {Permission info}\n    \"\"\"\n\n    if permtype not in ['permissions', 'groups']:\n        raise ValueError(\"The type of permission list is not known.\")\n\n    # Usually apilevel is supplied as string...\n    apilevel = int(apilevel)\n\n    root = os.path.dirname(os.path.realpath(__file__))\n    permissions_file = os.path.join(\n        root, \"aosp_permissions\", \"permissions_{}.json\".format(apilevel)\n    )\n\n    levels = filter(\n        lambda x: re.match(r'^permissions_\\d+\\.json$', x),\n        os.listdir(os.path.join(root, \"aosp_permissions\")),\n    )\n    levels = list(map(lambda x: int(x[:-5].split('_')[1]), levels))\n\n    if not levels:\n        logger.error(\"No Permissions available, can not load!\")\n        return {}\n\n    logger.debug(\n        \"Available API levels: {}\".format(\", \".join(map(str, sorted(levels))))\n    )\n\n    if not os.path.isfile(permissions_file):\n        if apilevel &gt; max(levels):\n            logger.warning(\n                \"Requested API level {} is larger than maximum we have, returning API level {} instead.\".format(\n                    apilevel, max(levels)\n                )\n            )\n            return load_permissions(max(levels), permtype)\n        if apilevel &lt; min(levels):\n            logger.warning(\n                \"Requested API level {} is smaller than minimal we have, returning API level {} instead.\".format(\n                    apilevel, max(levels)\n                )\n            )\n            return load_permissions(min(levels), permtype)\n\n        # Missing level between existing ones, return the lower level\n        lower_level = max(filter(lambda x: x &lt; apilevel, levels))\n        logger.warning(\n            \"Requested API Level could not be found, using {} instead\".format(\n                lower_level\n            )\n        )\n        return load_permissions(lower_level, permtype)\n\n    with open(permissions_file, \"r\") as fp:\n        return json.load(fp)[permtype]\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html","title":"apk","text":""},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK","title":"<code>APK</code>","text":"Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>class APK:\n    # Constants in ZipFile\n    _PK_END_OF_CENTRAL_DIR = b\"\\x50\\x4b\\x05\\x06\"\n    _PK_CENTRAL_DIR = b\"\\x50\\x4b\\x01\\x02\"\n\n    # Constants in the APK Signature Block\n    _APK_SIG_MAGIC = b\"APK Sig Block 42\"\n    _APK_SIG_KEY_V2_SIGNATURE = 0x7109871A\n    _APK_SIG_KEY_V3_SIGNATURE = 0xF05368C0\n    _APK_SIG_ATTR_V2_STRIPPING_PROTECTION = 0xBEEFF00D\n\n    _APK_SIG_ALGO_IDS = {\n        0x0101: \"RSASSA-PSS with SHA2-256 digest, SHA2-256 MGF1, 32 bytes of salt, trailer: 0xbc\",\n        0x0102: \"RSASSA-PSS with SHA2-512 digest, SHA2-512 MGF1, 64 bytes of salt, trailer: 0xbc\",\n        0x0103: \"RSASSA-PKCS1-v1_5 with SHA2-256 digest.\",  # This is for build systems which require deterministic signatures.\n        0x0104: \"RSASSA-PKCS1-v1_5 with SHA2-512 digest.\",  # This is for build systems which require deterministic signatures.\n        0x0201: \"ECDSA with SHA2-256 digest\",\n        0x0202: \"ECDSA with SHA2-512 digest\",\n        0x0301: \"DSA with SHA2-256 digest\",\n    }\n\n    __no_magic = False\n\n    def __init__(\n        self,\n        filename: str,\n        raw: bool = False,\n        magic_file: Union[str, None] = None,\n        skip_analysis: bool = False,\n        testzip: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        This class can access to all elements in an APK file\n\n        Examples:\n\n            &gt;&gt;&gt; APK(\"myfile.apk\")\n            &gt;&gt;&gt; APK(read(\"myfile.apk\"), raw=True)\n\n        :param filename: specify the path of the file, or raw data\n        :param raw: specify if the filename is a path or raw data (optional)\n        :param magic_file: specify the magic file (not used anymore - legacy only)\n        :param skip_analysis: Skip the analysis, e.g. no manifest files are read. (default: `False`)\n        :param testzip: Test the APK for integrity, e.g. if the ZIP file is broken. Throw an exception on failure (default `False`)\n        \"\"\"\n        if magic_file:\n            logger.warning(\n                \"You set magic_file but this parameter is actually unused. You should remove it.\"\n            )\n\n        self.filename = filename\n\n        self.xml = {}\n        self.axml = {}\n        self.arsc = {}\n\n        self.package = \"\"\n        self.androidversion = {}\n        self.permissions = []\n        self.uses_permissions = []\n        self.declared_permissions = {}\n        self.valid_apk = False\n\n        self._is_signed_v2 = None\n        self._is_signed_v3 = None\n        self._v2_blocks = {}\n        self._v2_signing_data = None\n        self._v3_signing_data = None\n\n        self._files = {}\n        self.files_crc32 = {}\n\n        if raw is True:\n            self.__raw = filename\n            self._sha256 = hashlib.sha256(self.__raw).hexdigest()\n            # Set the filename to something sane\n            self.filename = \"raw_apk_sha256:{}\".format(self._sha256)\n            self.zip = ZipEntry.parse(io.BytesIO(self.__raw), True)\n        else:\n            self.zip = ZipEntry.parse(filename, False)\n            self.__raw = self.zip.zip.getvalue()\n\n        if testzip:\n            logger.info(\n                \"Testing zip file integrity, this might take a while...\"\n            )\n            # Test the zipfile for integrity before continuing.\n            # This process might be slow, as the whole file is read.\n            # Therefore it is possible to enable it as a separate feature.\n            #\n            # A short benchmark showed, that testing the zip takes about 10 times longer!\n            # e.g. normal zip loading (skip_analysis=True) takes about 0.01s, where\n            # testzip takes 0.1s!\n            test_zip = zipfile.ZipFile(io.BytesIO(self.__raw), mode=\"r\")\n            ret = test_zip.testzip()\n            if ret is not None:\n                # we could print the filename here, but there are zip which are so broken\n                # That the filename is either very very long or does not make any sense.\n                # Thus we do not do it, the user might find out by using other tools.\n                raise BrokenAPKError(\n                    \"The APK is probably broken: testzip returned an error.\"\n                )\n\n        if not skip_analysis:\n            self._apk_analysis()\n\n    @staticmethod\n    def _ns(name):\n        \"\"\"\n        return the name including the Android namespace URI\n        \"\"\"\n        return NS_ANDROID + name\n\n    def _apk_analysis(self):\n        \"\"\"\n        Run analysis on the APK file.\n\n        This method is usually called by __init__ except if skip_analysis is False.\n        It will then parse the `AndroidManifest.xml` and set all fields in the APK class which can be\n        extracted from the Manifest.\n        \"\"\"\n        i = \"AndroidManifest.xml\"\n        logger.info(\"Starting analysis on {}\".format(i))\n        try:\n            manifest_data = self.zip.read(i)\n        except KeyError:\n            logger.warning(\"Missing AndroidManifest.xml. Is this an APK file?\")\n        else:\n            ap = AXMLPrinter(manifest_data)\n\n            if not ap.is_valid():\n                logger.error(\n                    \"Error while parsing AndroidManifest.xml - is the file valid?\"\n                )\n                return\n\n            self.axml[i] = ap\n            self.xml[i] = self.axml[i].get_xml_obj()\n\n            if self.axml[i].is_packed():\n                logger.warning(\n                    \"XML Seems to be packed, operations on the AndroidManifest.xml might fail.\"\n                )\n\n            if self.xml[i] is not None:\n                if self.xml[i].tag != \"manifest\":\n                    logger.error(\n                        \"AndroidManifest.xml does not start with a &lt;manifest&gt; tag! Is this a valid APK?\"\n                    )\n                    return\n\n                self.package = self.get_attribute_value(\"manifest\", \"package\")\n                self.androidversion[\"Code\"] = self.get_attribute_value(\n                    \"manifest\", \"versionCode\"\n                )\n                self.androidversion[\"Name\"] = self.get_attribute_value(\n                    \"manifest\", \"versionName\"\n                )\n                permission = list(\n                    self.get_all_attribute_value(\"uses-permission\", \"name\")\n                )\n                self.permissions = list(set(self.permissions + permission))\n\n                for uses_permission in self.find_tags(\"uses-permission\"):\n                    self.uses_permissions.append(\n                        [\n                            self.get_value_from_tag(uses_permission, \"name\"),\n                            self._get_permission_maxsdk(uses_permission),\n                        ]\n                    )\n\n                # getting details of the declared permissions\n                for d_perm_item in self.find_tags('permission'):\n                    d_perm_name = self._get_res_string_value(\n                        str(self.get_value_from_tag(d_perm_item, \"name\"))\n                    )\n                    d_perm_label = self._get_res_string_value(\n                        str(self.get_value_from_tag(d_perm_item, \"label\"))\n                    )\n                    d_perm_description = self._get_res_string_value(\n                        str(\n                            self.get_value_from_tag(d_perm_item, \"description\")\n                        )\n                    )\n                    d_perm_permissionGroup = self._get_res_string_value(\n                        str(\n                            self.get_value_from_tag(\n                                d_perm_item, \"permissionGroup\"\n                            )\n                        )\n                    )\n                    d_perm_protectionLevel = self._get_res_string_value(\n                        str(\n                            self.get_value_from_tag(\n                                d_perm_item, \"protectionLevel\"\n                            )\n                        )\n                    )\n\n                    d_perm_details = {\n                        \"label\": d_perm_label,\n                        \"description\": d_perm_description,\n                        \"permissionGroup\": d_perm_permissionGroup,\n                        \"protectionLevel\": d_perm_protectionLevel,\n                    }\n                    self.declared_permissions[d_perm_name] = d_perm_details\n\n                self.valid_apk = True\n                logger.info(\"APK file was successfully validated!\")\n\n        self.permission_module = androconf.load_api_specific_resource_module(\n            \"aosp_permissions\", self.get_target_sdk_version()\n        )\n        self.permission_module_min_sdk = (\n            androconf.load_api_specific_resource_module(\n                \"aosp_permissions\", self.get_min_sdk_version()\n            )\n        )\n\n    def __getstate__(self):\n        \"\"\"\n        Function for pickling APK Objects.\n\n        We remove the zip from the Object, as it is not pickable\n        And it does not make any sense to pickle it anyways.\n\n        :returns: the picklable APK Object without zip.\n        \"\"\"\n        # Upon pickling, we need to remove the ZipFile\n        x = self.__dict__\n        x['axml'] = str(x['axml'])\n        x['xml'] = str(x['xml'])\n        del x['zip']\n\n        return x\n\n    def __setstate__(self, state):\n        \"\"\"\n        Load a pickled APK Object and restore the state\n\n        We load the zip file back by reading __raw from the Object.\n\n        :param state: pickled state\n        \"\"\"\n        self.__dict__ = state\n\n        self.zip = zipfile.ZipFile(io.BytesIO(self.get_raw()), mode=\"r\")\n\n    def _get_res_string_value(self, string):\n        if not string.startswith('@string/'):\n            return string\n        string_key = string[9:]\n\n        res_parser = self.get_android_resources()\n        if not res_parser:\n            return ''\n        string_value = ''\n        for package_name in res_parser.get_packages_names():\n            extracted_values = res_parser.get_string(package_name, string_key)\n            if extracted_values:\n                string_value = extracted_values[1]\n                break\n        return string_value\n\n    def _get_permission_maxsdk(self, item):\n        maxSdkVersion = None\n        try:\n            maxSdkVersion = int(self.get_value_from_tag(item, \"maxSdkVersion\"))\n        except ValueError:\n            logger.warning(\n                str(maxSdkVersion)\n                + ' is not a valid value for &lt;uses-permission&gt; maxSdkVersion'\n            )\n        except TypeError:\n            pass\n        return maxSdkVersion\n\n    def is_valid_APK(self) -&gt; bool:\n        \"\"\"\n        Return `True` if the APK is valid, `False` otherwise.\n        An APK is seen as valid, if the `AndroidManifest.xml` could be successful parsed.\n        This does not mean that the APK has a valid signature nor that the APK\n        can be installed on an Android system.\n\n        :returns: `True` if the APK is valid, `False` otherwise.\n        \"\"\"\n        return self.valid_apk\n\n    def get_filename(self) -&gt; str:\n        \"\"\"\n        Return the filename of the APK\n\n        :returns: filename\n        \"\"\"\n        return self.filename\n\n    def get_app_name(self, locale=None) -&gt; str:\n        \"\"\"\n        Return the appname of the APK\n        This name is read from the `AndroidManifest.xml`\n        using the application `android:label`.\n        If no label exists, the `android:label` of the main activity is used.\n\n        If there is also no main activity label, an empty string is returned.\n\n        :returns: the appname of the APK\n        \"\"\"\n\n        app_name = self.get_attribute_value('application', 'label')\n        if app_name is None:\n            activities = self.get_main_activities()\n            main_activity_name = None\n            if len(activities) &gt; 0:\n                main_activity_name = activities.pop()\n\n            # FIXME: would need to use _format_value inside get_attribute_value for each returned name!\n            # For example, as the activity name might be foobar.foo.bar but inside the activity it is only .bar\n            app_name = self.get_attribute_value(\n                'activity', 'label', name=main_activity_name\n            )\n\n        if app_name is None:\n            # No App name set\n            # TODO return packagename instead?\n            logger.warning(\n                \"It looks like that no app name is set for the main activity!\"\n            )\n            return \"\"\n\n        if app_name.startswith(\"@\"):\n            res_parser = self.get_android_resources()\n            if not res_parser:\n                # TODO: What should be the correct return value here?\n                return app_name\n\n            res_id, package = res_parser.parse_id(app_name)\n\n            # If the package name is the same as the APK package,\n            # we should be able to resolve the ID.\n            if package and package != self.get_package():\n                if package == 'android':\n                    # TODO: we can not resolve this, as we lack framework-res.apk\n                    # one exception would be when parsing framework-res.apk directly.\n                    logger.warning(\n                        \"Resource ID with android package name encountered! \"\n                        \"Will not resolve, framework-res.apk would be required.\"\n                    )\n                    return app_name\n                else:\n                    # TODO should look this up, might be in the resources\n                    logger.warning(\n                        \"Resource ID with Package name '{}' encountered! Will not resolve\".format(\n                            package\n                        )\n                    )\n                    return app_name\n\n            try:\n                config = (\n                    ARSCResTableConfig(None, locale=locale)\n                    if locale\n                    else ARSCResTableConfig.default_config()\n                )\n                app_name = res_parser.get_resolved_res_configs(res_id, config)[\n                    0\n                ][1]\n            except Exception as e:\n                logger.warning(\"Exception selecting app name: %s\" % e)\n        return app_name\n\n    def get_app_icon(self, max_dpi: int = 65536) -&gt; Union[str, None]:\n        \"\"\"\n        Return the first icon file name, which density is not greater than max_dpi,\n        unless exact icon resolution is set in the manifest, in which case\n        return the exact file.\n\n        This information is read from the `AndroidManifest.xml`\n\n        From &lt;https://developer.android.com/guide/practices/screens_support.html&gt;\n        and &lt;https://developer.android.com/ndk/reference/group___configuration.html&gt;\n\n        * DEFAULT                             0dpi\n        * ldpi (low)                        120dpi\n        * mdpi (medium)                     160dpi\n        * TV                                213dpi\n        * hdpi (high)                       240dpi\n        * xhdpi (extra-high)                320dpi\n        * xxhdpi (extra-extra-high)         480dpi\n        * xxxhdpi (extra-extra-extra-high)  640dpi\n        * anydpi                          65534dpi (0xFFFE)\n        * nodpi                           65535dpi (0xFFFF)\n\n        There is a difference between nodpi and anydpi:\n        nodpi will be used if no other density is specified. Or the density does not match.\n        nodpi is the fallback for everything else. If there is a resource that matches the DPI,\n        this is used.\n        anydpi is also valid for all densities but in this case, anydpi will overrule all other files!\n        Therefore anydpi is usually used with vector graphics and with constraints on the API level.\n        For example adaptive icons are usually marked as anydpi.\n\n        When it comes now to selecting an icon, there is the following flow:\n\n        1. is there an anydpi icon?\n        2. is there an icon for the dpi of the device?\n        3. is there a nodpi icon?\n        4. (only on very old devices) is there a icon with dpi 0 (the default)\n\n        For more information read here: &lt;https://stackoverflow.com/a/34370735/446140&gt;\n\n        :returns: the first icon file name, or None if no resources or app icon exists.\n        \"\"\"\n        main_activity_name = self.get_main_activity()\n\n        app_icon = self.get_attribute_value(\n            'activity', 'icon', name=main_activity_name\n        )\n\n        if not app_icon:\n            app_icon = self.get_attribute_value('application', 'icon')\n\n        res_parser = self.get_android_resources()\n        if not res_parser:\n            # Can not do anything below this point to resolve...\n            return None\n\n        if not app_icon:\n            res_id = res_parser.get_res_id_by_key(\n                self.package, 'mipmap', 'ic_launcher'\n            )\n            if res_id:\n                app_icon = \"@%x\" % res_id\n\n        if not app_icon:\n            res_id = res_parser.get_res_id_by_key(\n                self.package, 'drawable', 'ic_launcher'\n            )\n            if res_id:\n                app_icon = \"@%x\" % res_id\n\n        if not app_icon:\n            # If the icon can not be found, return now\n            return None\n\n        if app_icon.startswith(\"@\"):\n            app_icon_id = app_icon[1:]\n            app_icon_id = app_icon_id.split(':')[-1]\n            res_id = int(app_icon_id, 16)\n            candidates = res_parser.get_resolved_res_configs(res_id)\n\n            app_icon = None\n            current_dpi = -1\n\n            try:\n                for config, file_name in candidates:\n                    dpi = config.get_density()\n                    if current_dpi &lt; dpi &lt;= max_dpi:\n                        app_icon = file_name\n                        current_dpi = dpi\n            except Exception as e:\n                logger.warning(\"Exception selecting app icon: %s\" % e)\n\n        return app_icon\n\n    def get_package(self) -&gt; str:\n        \"\"\"\n        Return the name of the package\n\n        This information is read from the `AndroidManifest.xml`\n\n        :returns: the name of the package\n        \"\"\"\n        return self.package\n\n    def get_androidversion_code(self) -&gt; str:\n        \"\"\"\n        Return the android version code\n\n        This information is read from the `AndroidManifest.xml`\n\n        :returns: the android version code\n        \"\"\"\n        return self.androidversion[\"Code\"]\n\n    def get_androidversion_name(self) -&gt; str:\n        \"\"\"\n        Return the android version name\n\n        This information is read from the `AndroidManifest.xml`\n\n        :returns: the android version name\n        \"\"\"\n        return self.androidversion[\"Name\"]\n\n    def get_files(self) -&gt; list[str]:\n        \"\"\"\n        Return the file names inside the APK.\n\n        :returns: a list of filename strings inside the APK\n        \"\"\"\n        return self.zip.namelist()\n\n    def _get_file_magic_name(self, buffer: bytes) -&gt; str:\n        \"\"\"\n        Return the filetype guessed for a buffer\n        :param buffer: bytes\n\n        :returns: guessed filetype, or \"Unknown\" if not resolved\n        \"\"\"\n        default = \"Unknown\"\n\n        # Faster way, test once, return default.\n        if self.__no_magic:\n            return default\n\n        try:\n            # Magic is optional\n            import magic\n        except ImportError:\n            self.__no_magic = True\n            logger.warning(\"No Magic library was found on your system.\")\n            return default\n        except TypeError as e:\n            self.__no_magic = True\n            logger.warning(\n                \"It looks like you have the magic python package installed but not the magic library itself!\"\n            )\n            logger.warning(\"Error from magic library: %s\", e)\n            logger.warning(\n                \"Please follow the installation instructions at https://github.com/ahupp/python-magic/#installation\"\n            )\n            logger.warning(\n                \"You can also install the 'python-magic-bin' package on Windows and MacOS\"\n            )\n            return default\n\n        try:\n            # There are several implementations of magic,\n            # unfortunately all called magic\n            # We use this one: https://github.com/ahupp/python-magic/\n            # You can also use python-magic-bin on Windows or MacOS\n            getattr(magic, \"MagicException\")\n        except AttributeError:\n            self.__no_magic = True\n            logger.warning(\n                \"Not the correct Magic library was found on your \"\n                \"system. Please install python-magic or python-magic-bin!\"\n            )\n            return default\n\n        try:\n            # 1024 byte are usually enough to test the magic\n            ftype = magic.from_buffer(buffer[:1024])\n        except magic.MagicException as e:\n            logger.exception(\"Error getting the magic type: %s\", e)\n            return default\n\n        if not ftype:\n            return default\n        else:\n            return self._patch_magic(buffer, ftype)\n\n    @property\n    def files(self) -&gt; dict[str, str]:\n        \"\"\"\n        Returns a dictionary of filenames and detected magic type\n\n        :returns: dictionary of files and their mime type\n        \"\"\"\n        return self.get_files_types()\n\n    def get_files_types(self) -&gt; dict[str, str]:\n        \"\"\"\n        Return the files inside the APK with their associated types (by using [python-magic](https://pypi.org/project/python-magic/))\n\n        At the same time, the CRC32 are calculated for the files.\n\n        :returns: the files inside the APK with their associated types\n        \"\"\"\n        if self._files == {}:\n            # Generate File Types / CRC List\n            for i in self.get_files():\n                buffer = self._get_crc32(i)\n                self._files[i] = self._get_file_magic_name(buffer)\n\n        return self._files\n\n    def _patch_magic(self, buffer, orig):\n        \"\"\"\n        Overwrite some probably wrong detections by mime libraries\n\n        :param buffer: bytes of the file to detect\n        :param orig: guess by mime libary\n        :returns: corrected guess\n        \"\"\"\n        if (\n            (\"Zip\" in orig)\n            or ('(JAR)' in orig)\n            and androconf.is_android_raw(buffer) == 'APK'\n        ):\n            return \"Android application package file\"\n\n        return orig\n\n    def _get_crc32(self, filename):\n        \"\"\"\n        Calculates and compares the CRC32 and returns the raw buffer.\n\n        The CRC32 is added to [files_crc32][androguard.core.apk.APK.files_crc32] dictionary, if not present.\n\n        :param filename: filename inside the zipfile\n        :rtype: bytes\n        \"\"\"\n        buffer = self.zip.read(filename)\n        if filename not in self.files_crc32:\n            self.files_crc32[filename] = crc32(buffer)\n            if (\n                self.files_crc32[filename]\n                != self.zip.infolist()[filename].crc32_of_uncompressed_data\n            ):\n                logger.error(\n                    \"File '{}' has different CRC32 after unpacking! \"\n                    \"Declared: {:08x}, Calculated: {:08x}\".format(\n                        filename,\n                        self.zip.infolist()[\n                            filename\n                        ].crc32_of_uncompressed_data,\n                        self.files_crc32[filename],\n                    )\n                )\n        return buffer\n\n    def get_files_crc32(self) -&gt; dict[str, int]:\n        \"\"\"\n        Calculates and returns a dictionary of filenames and CRC32\n\n        :returns: dict of filename: CRC32\n        \"\"\"\n        if self.files_crc32 == {}:\n            for i in self.get_files():\n                self._get_crc32(i)\n\n        return self.files_crc32\n\n    def get_files_information(self) -&gt; Iterator[tuple[str, str, int]]:\n        \"\"\"\n        Return the files inside the APK with their associated types and crc32\n\n        :returns: the files inside the APK with their associated types and crc32\n        \"\"\"\n        for k in self.get_files():\n            yield k, self.get_files_types()[k], self.get_files_crc32()[k]\n\n    def get_raw(self) -&gt; bytes:\n        \"\"\"\n        Return raw bytes of the APK\n\n        :returns: bytes of the APK\n        \"\"\"\n\n        if self.__raw:\n            return self.__raw\n        else:\n            with open(self.filename, 'rb') as f:\n                self.__raw = bytearray(f.read())\n            return self.__raw\n\n    def get_file(self, filename: str) -&gt; bytes:\n        \"\"\"\n        Return the raw data of the specified filename\n        inside the APK\n\n        :param filename: the filename to get\n        :raises FileNotPresent: if filename not found inside the apk\n        :returns: bytes of the specified filename\n        \"\"\"\n        try:\n            return self.zip.read(filename)\n        except KeyError:\n            raise FileNotPresent(filename)\n\n    def get_dex(self) -&gt; bytes:\n        \"\"\"\n        Return the raw data of the classes dex file\n\n        This will give you the data of the file called `classes.dex`\n        inside the APK. If the APK has multiple DEX files, you need to use [get_all_dex][androguard.core.apk.APK.get_all_dex].\n\n        :raises FileNotPresent: if classes.dex is not found\n        :returns: the raw data of the classes dex file\n        \"\"\"\n        try:\n            return self.get_file(\"classes.dex\")\n        except FileNotPresent:\n            # TODO is this a good idea to return an empty string?\n            return b\"\"\n\n    def get_dex_names(self) -&gt; list[str]:\n        \"\"\"\n        Return the names of all DEX files found in the APK.\n        This method only accounts for \"offical\" dex files, i.e. all files\n        in the root directory of the APK named `classes.dex` or `classes[0-9]+.dex`\n\n        :returns: the names of all DEX files found in the APK\n        \"\"\"\n        dexre = re.compile(r\"^classes(\\d*).dex$\")\n        return filter(lambda x: dexre.match(x), self.get_files())\n\n    def get_all_dex(self) -&gt; Iterator[bytes]:\n        \"\"\"\n        Return the raw bytes data of all classes dex files\n\n        :returns: the raw bytes data of all classes dex files\n        \"\"\"\n        for dex_name in self.get_dex_names():\n            yield self.get_file(dex_name)\n\n    def is_multidex(self) -&gt; bool:\n        \"\"\"\n        Test if the APK has multiple DEX files\n\n        :returns: True if multiple dex found, otherwise False\n        \"\"\"\n        dexre = re.compile(r\"^classes(\\d+)?.dex$\")\n        return (\n            len(\n                [\n                    instance\n                    for instance in self.get_files()\n                    if dexre.search(instance)\n                ]\n            )\n            &gt; 1\n        )\n\n    def _format_value(self, value):\n        \"\"\"\n        Format a value with packagename, if not already set.\n        For example, the name `'.foobar'` will be transformed into `'package.name.foobar'`.\n\n        Names which do not contain any dots are assumed to be packagename-less as well:\n        `foobar` will also transform into `package.name.foobar`.\n\n        :param value: string value to format with the packaname\n        :returns: the formatted package name\n        \"\"\"\n        if value and self.package:\n            v_dot = value.find(\".\")\n            if v_dot == 0:\n                # Dot at the start\n                value = self.package + value\n            elif v_dot == -1:\n                # Not a single dot\n                value = self.package + \".\" + value\n        return value\n\n    def get_all_attribute_value(\n        self,\n        tag_name: str,\n        attribute: str,\n        format_value: bool = True,\n        **attribute_filter,\n    ) -&gt; Iterator[str]:\n        \"\"\"\n        Yields all the attribute values in xml files which match with the tag name and the specific attribute\n\n        :param str tag_name: specify the tag name\n        :param str attribute: specify the attribute\n        :param bool format_value: specify if the value needs to be formatted with packagename\n\n        :returns: the attribute values\n        \"\"\"\n        tags = self.find_tags(tag_name, **attribute_filter)\n        for tag in tags:\n            value = tag.get(self._ns(attribute)) or tag.get(attribute)\n            if value is not None:\n                if format_value:\n                    yield self._format_value(value)\n                else:\n                    yield value\n\n    def get_attribute_value(\n        self,\n        tag_name: str,\n        attribute: str,\n        format_value: bool = False,\n        **attribute_filter,\n    ) -&gt; str:\n        \"\"\"\n        Return the attribute value in xml files which matches the tag name and the specific attribute\n\n        :param str tag_name: specify the tag name\n        :param str attribute: specify the attribute\n        :param bool format_value: specify if the value needs to be formatted with packagename\n\n        :returns: the attribute value\n        \"\"\"\n\n        for value in self.get_all_attribute_value(\n            tag_name, attribute, format_value, **attribute_filter\n        ):\n            if value is not None:\n                return value\n\n    def get_value_from_tag(\n        self, tag: Element, attribute: str\n    ) -&gt; Union[str, None]:\n        \"\"\"\n        Return the value of the android prefixed attribute in a specific tag.\n\n        This function will always try to get the attribute with a `android:` prefix first,\n        and will try to return the attribute without the prefix, if the attribute could not be found.\n        This is useful for some broken `AndroidManifest.xml`, where no android namespace is set,\n        but could also indicate malicious activity (i.e. wrongly repackaged files).\n        A warning is printed if the attribute is found without a namespace prefix.\n\n        If you require to get the exact result you need to query the tag directly:\n\n        Example:\n\n            &gt;&gt;&gt; from lxml.etree import Element\n            &gt;&gt;&gt; tag = Element('bar', nsmap={'android': 'http://schemas.android.com/apk/res/android'})\n            &gt;&gt;&gt; tag.set('{http://schemas.android.com/apk/res/android}foobar', 'barfoo')\n            &gt;&gt;&gt; tag.set('name', 'baz')\n            # Assume that `a` is some APK object\n            &gt;&gt;&gt; a.get_value_from_tag(tag, 'name')\n            'baz'\n            &gt;&gt;&gt; tag.get('name')\n            'baz'\n            &gt;&gt;&gt; tag.get('foobar')\n            None\n            &gt;&gt;&gt; a.get_value_from_tag(tag, 'foobar')\n            'barfoo'\n\n        :param lxml.etree.Element tag: specify the tag element\n        :param str attribute: specify the attribute name\n        :returns: the attribute's value, or None if the attribute is not present\n        \"\"\"\n\n        # TODO: figure out if both android:name and name tag exist which one to give preference:\n        # currently we give preference for the namespace one and fallback to the un-namespaced\n        value = tag.get(self._ns(attribute))\n        if value is None:\n            value = tag.get(attribute)\n\n            if value:\n                # If value is still None, the attribute could not be found, thus is not present\n                logger.warning(\n                    \"Failed to get the attribute '{}' on tag '{}' with namespace. \"\n                    \"But found the same attribute without namespace!\".format(\n                        attribute, tag.tag\n                    )\n                )\n        return value\n\n    def find_tags(self, tag_name: str, **attribute_filter) -&gt; list[str]:\n        \"\"\"\n        Return a list of all the matched tags in all available xml\n\n        :param tag_name: specify the tag name\n\n        :returns: the matched tags\n        \"\"\"\n        all_tags = [\n            self.find_tags_from_xml(i, tag_name, **attribute_filter)\n            for i in self.xml\n        ]\n        return [tag for tag_list in all_tags for tag in tag_list]\n\n    def find_tags_from_xml(\n        self, xml_name: str, tag_name: str, **attribute_filter\n    ) -&gt; list[str]:\n        \"\"\"\n        Return a list of all the matched tags in a specific xml\n\n        :param str xml_name: specify from which xml to pick the tag from\n        :param str tag_name: specify the tag name\n\n        :returns: the matched tags\n        \"\"\"\n        xml = self.xml[xml_name]\n        if xml is None:\n            return []\n        if xml.tag == tag_name:\n            if self.is_tag_matched(xml.tag, **attribute_filter):\n                return [xml]\n            return []\n        tags = set()\n        tags.update(xml.findall(\".//\" + tag_name))\n\n        # https://github.com/androguard/androguard/pull/1053\n        # permission declared using tag &lt;android:uses-permission...\n        tags.update(xml.findall(\".//\" + NS_ANDROID + tag_name))\n        return [\n            tag for tag in tags if self.is_tag_matched(tag, **attribute_filter)\n        ]\n\n    def is_tag_matched(self, tag: lxml.etree.Element, **attribute_filter) -&gt; bool:\n        r\"\"\"\n        Return `True` if the attributes matches in attribute filter.\n\n        An attribute filter is a dictionary containing: {attribute_name: value}.\n        This function will return `True` if and only if all attributes have the same value.\n        This function allows to set the dictionary via kwargs, thus you can filter like this:\n\n        Example:\n\n            &gt;&gt;&gt; a.is_tag_matched(tag, name=\"foobar\", other=\"barfoo\")\n\n        This function uses a fallback for attribute searching. It will by default use\n        the namespace variant but fall back to the non-namespace variant.\n        Thus specifiying `{\"name\": \"foobar\"}` will match on `&lt;bla name=\"foobar\" \\&gt;`\n        as well as on `&lt;bla android:name=\"foobar\" \\&gt;`.\n\n        :param tag: specify the tag element\n        :param attribute_filter: specify the attribute filter as dictionary\n\n        :returns: `True` if the attributes matches in attribute filter, else `False`\n        \"\"\"\n        if len(attribute_filter) &lt;= 0:\n            return True\n        for attr, value in attribute_filter.items():\n            _value = self.get_value_from_tag(tag, attr)\n            if _value != value:\n                return False\n        return True\n\n    def get_main_activities(self) -&gt; set[str]:\n        \"\"\"\n        Return names of the main activities\n\n        These values are read from the `AndroidManifest.xml`\n\n        :returns: names of the main activities\n        \"\"\"\n        x = set()\n        y = set()\n\n        for i in self.xml:\n            if self.xml[i] is None:\n                continue\n            activities_and_aliases = self.xml[i].findall(\n                \".//activity\"\n            ) + self.xml[i].findall(\".//activity-alias\")\n\n            for item in activities_and_aliases:\n                # Some applications have more than one MAIN activity.\n                # For example: paid and free content\n                activityEnabled = item.get(self._ns(\"enabled\"))\n                if activityEnabled == \"false\":\n                    continue\n\n                for sitem in item.findall(\".//action\"):\n                    val = sitem.get(self._ns(\"name\"))\n                    if val == \"android.intent.action.MAIN\":\n                        activity = item.get(self._ns(\"name\"))\n                        if activity is not None:\n                            x.add(item.get(self._ns(\"name\")))\n                        else:\n                            logger.warning('Main activity without name')\n\n                for sitem in item.findall(\".//category\"):\n                    val = sitem.get(self._ns(\"name\"))\n                    if val == \"android.intent.category.LAUNCHER\":\n                        activity = item.get(self._ns(\"name\"))\n                        if activity is not None:\n                            y.add(item.get(self._ns(\"name\")))\n                        else:\n                            logger.warning('Launcher activity without name')\n\n        return x.intersection(y)\n\n    def get_main_activity(self) -&gt; Union[str, None]:\n        \"\"\"\n        Return the name of the main activity\n\n        This value is read from the `AndroidManifest.xml`\n\n        :returns: the name of the main activity\n        \"\"\"\n        activities = self.get_main_activities()\n        if len(activities) == 1:\n            return self._format_value(activities.pop())\n        elif len(activities) &gt; 1:\n            main_activities = {self._format_value(ma) for ma in activities}\n            # sorted is necessary\n            # 9fc7d3e8225f6b377f9181a92c551814317b77e1aa0df4c6d508d24b18f0f633\n            good_main_activities = sorted(\n                main_activities.intersection(self.get_activities())\n            )\n            if good_main_activities:\n                return good_main_activities[0]\n            return sorted(main_activities)[0]\n        return None\n\n    def get_activities(self) -&gt; list[str]:\n        \"\"\"\n        Return the `android:name` attribute of all activities\n\n        :returns: the list of `android:name` attribute of all activities\n        \"\"\"\n        return list(self.get_all_attribute_value(\"activity\", \"name\"))\n\n    def get_activity_aliases(self) -&gt; list[dict[str, str]]:\n        \"\"\"\n        Return the `android:name` and `android:targetActivity` attribute of all activity aliases.\n\n        :returns: the list of `android:name` and `android:targetActivity` attribute of all activitiy aliases\n        \"\"\"\n        ali = []\n        for alias in self.find_tags('activity-alias'):\n            activity_alias = {}\n            for attribute in ['name', 'targetActivity']:\n                value = alias.get(attribute) or alias.get(self._ns(attribute))\n                if not value:\n                    continue\n                activity_alias[attribute] = self._format_value(value)\n            if activity_alias:\n                ali.append(activity_alias)\n        return ali\n\n    def get_services(self) -&gt; list[str]:\n        \"\"\"\n        Return the `android:name` attribute of all services\n\n        :returns: the list of the `android:name` attribute of all services\n        \"\"\"\n        return list(self.get_all_attribute_value(\"service\", \"name\"))\n\n    def get_receivers(self) -&gt; list[str]:\n        \"\"\"\n        Return the `android:name` attribute of all receivers\n\n        :returns: the list of the `android:name` attribute of all receivers\n        \"\"\"\n        return list(self.get_all_attribute_value(\"receiver\", \"name\"))\n\n    def get_providers(self) -&gt; list[str]:\n        \"\"\"\n        Return the `android:name` attribute of all providers\n\n        :returns: the list of the `android:name` attribute of all providers\n        \"\"\"\n        return list(self.get_all_attribute_value(\"provider\", \"name\"))\n\n    def get_res_value(self, name: str) -&gt; str:\n        \"\"\"\n        Return the literal value with a resource id\n\n        :returns: the literal value with a resource id\n        \"\"\"\n\n        res_parser = self.get_android_resources()\n        if not res_parser:\n            return name\n\n        res_id = res_parser.parse_id(name)[0]\n        try:\n            value = res_parser.get_resolved_res_configs(\n                res_id, ARSCResTableConfig.default_config()\n            )[0][1]\n        except Exception as e:\n            logger.warning(\"Exception get resolved resource id: %s\" % e)\n            return name\n\n        return value\n\n    def get_intent_filters(\n        self, itemtype: str, name: str\n    ) -&gt; dict[str, list[str]]:\n        \"\"\"\n        Find intent filters for a given item and name.\n\n        Intent filter are attached to activities, services or receivers.\n        You can search for the intent filters of such items and get a dictionary of all\n        attached actions and intent categories.\n\n        :param itemtype: the type of parent item to look for, e.g. `activity`,  `service` or `receiver`\n        :param name: the `android:name` of the parent item, e.g. activity name\n        :returns: a dictionary with the keys `action` and `category` containing the `android:name` of those items\n        \"\"\"\n        attributes = {\n            \"action\": [\"name\"],\n            \"category\": [\"name\"],\n            \"data\": [\n                'scheme',\n                'host',\n                'port',\n                'path',\n                'pathPattern',\n                'pathPrefix',\n                'mimeType',\n            ],\n        }\n\n        d = {}\n        for element in attributes.keys():\n            d[element] = []\n\n        for i in self.xml:\n            # TODO: this can probably be solved using a single xpath\n            for item in self.xml[i].findall(\".//\" + itemtype):\n                if self._format_value(item.get(self._ns(\"name\"))) == name:\n                    for sitem in item.findall(\".//intent-filter\"):\n                        for element in d.keys():\n                            for ssitem in sitem.findall(element):\n                                if element == 'data':  # multiple attributes\n                                    values = {}\n                                    for attribute in attributes[element]:\n                                        value = ssitem.get(self._ns(attribute))\n                                        if value:\n                                            if value.startswith('@'):\n                                                value = self.get_res_value(\n                                                    value\n                                                )\n                                            values[attribute] = value\n\n                                    if values:\n                                        d[element].append(values)\n                                else:\n                                    for attribute in attributes[element]:\n                                        value = ssitem.get(self._ns(attribute))\n                                        if value.startswith('@'):\n                                            value = self.get_res_value(value)\n\n                                        if value not in d[element]:\n                                            d[element].append(value)\n\n        for element in list(d.keys()):\n            if not d[element]:\n                del d[element]\n\n        return d\n\n    def get_permissions(self) -&gt; list[str]:\n        \"\"\"\n        Return permissions names declared in the `AndroidManifest.xml`.\n\n        It is possible that permissions are returned multiple times,\n        as this function does not filter the permissions, i.e. it shows you\n        exactly what was defined in the `AndroidManifest.xml`.\n\n        Implied permissions, which are granted automatically, are not returned\n        here. Use [get_uses_implied_permission_list][androguard.core.apk.APK.get_uses_implied_permission_list] if you need a list\n        of implied permissions.\n\n        :returns: A list of permissions as strings\n        \"\"\"\n        return self.permissions\n\n    def get_uses_implied_permission_list(self) -&gt; list[str]:\n        \"\"\"\n        Return all permissions implied by the target SDK or other permissions.\n\n        :returns: list of all permissions implied by the target SDK or other permissions as strings\n        \"\"\"\n        target_sdk_version = self.get_effective_target_sdk_version()\n\n        READ_CALL_LOG = 'android.permission.READ_CALL_LOG'\n        READ_CONTACTS = 'android.permission.READ_CONTACTS'\n        READ_EXTERNAL_STORAGE = 'android.permission.READ_EXTERNAL_STORAGE'\n        READ_PHONE_STATE = 'android.permission.READ_PHONE_STATE'\n        WRITE_CALL_LOG = 'android.permission.WRITE_CALL_LOG'\n        WRITE_CONTACTS = 'android.permission.WRITE_CONTACTS'\n        WRITE_EXTERNAL_STORAGE = 'android.permission.WRITE_EXTERNAL_STORAGE'\n\n        implied = []\n\n        implied_WRITE_EXTERNAL_STORAGE = False\n        if target_sdk_version &lt; 4:\n            if WRITE_EXTERNAL_STORAGE not in self.permissions:\n                implied.append([WRITE_EXTERNAL_STORAGE, None])\n                implied_WRITE_EXTERNAL_STORAGE = True\n            if READ_PHONE_STATE not in self.permissions:\n                implied.append([READ_PHONE_STATE, None])\n\n        if (\n            WRITE_EXTERNAL_STORAGE in self.permissions\n            or implied_WRITE_EXTERNAL_STORAGE\n        ) and READ_EXTERNAL_STORAGE not in self.permissions:\n            maxSdkVersion = None\n            for name, version in self.uses_permissions:\n                if name == WRITE_EXTERNAL_STORAGE:\n                    maxSdkVersion = version\n                    break\n            implied.append([READ_EXTERNAL_STORAGE, maxSdkVersion])\n\n        if target_sdk_version &lt; 16:\n            if (\n                READ_CONTACTS in self.permissions\n                and READ_CALL_LOG not in self.permissions\n            ):\n                implied.append([READ_CALL_LOG, None])\n            if (\n                WRITE_CONTACTS in self.permissions\n                and WRITE_CALL_LOG not in self.permissions\n            ):\n                implied.append([WRITE_CALL_LOG, None])\n\n        return implied\n\n    def _update_permission_protection_level(\n        self, protection_level, sdk_version\n    ):\n        if not sdk_version or int(sdk_version) &lt;= 15:\n            return protection_level.replace('Or', '|').lower()\n        return protection_level\n\n    def _fill_deprecated_permissions(self, permissions):\n        min_sdk = self.get_min_sdk_version()\n        target_sdk = self.get_target_sdk_version()\n        filled_permissions = permissions.copy()\n        for permission in filled_permissions:\n            protection_level, label, description = filled_permissions[\n                permission\n            ]\n            if (\n                not label or not description\n            ) and permission in self.permission_module_min_sdk:\n                x = self.permission_module_min_sdk[permission]\n                protection_level = self._update_permission_protection_level(\n                    x['protectionLevel'], min_sdk\n                )\n                filled_permissions[permission] = [\n                    protection_level,\n                    x['label'],\n                    x['description'],\n                ]\n            else:\n                filled_permissions[permission] = [\n                    self._update_permission_protection_level(\n                        protection_level, target_sdk\n                    ),\n                    label,\n                    description,\n                ]\n        return filled_permissions\n\n    def get_details_permissions(self) -&gt; dict[str, list[str]]:\n        \"\"\"\n        Return permissions with details.\n\n        This can only return details about the permission, if the permission is\n        defined in the AOSP.\n\n        :returns: permissions with details: dict of `{permission: [protectionLevel, label, description]}`\n        \"\"\"\n        l = {}\n\n        for i in self.permissions:\n            if i in self.permission_module:\n                x = self.permission_module[i]\n                l[i] = [x[\"protectionLevel\"], x[\"label\"], x[\"description\"]]\n            elif i in self.declared_permissions:\n                protectionLevel_hex = self.declared_permissions[i][\n                    \"protectionLevel\"\n                ]\n                protectionLevel = protection_flags_to_attributes[\n                    protectionLevel_hex\n                ]\n                l[i] = [\n                    protectionLevel,\n                    \"Unknown permission from android reference\",\n                    \"Unknown permission from android reference\",\n                ]\n            else:\n                # Is there a valid case not belonging to the above two?\n                logger.info(f\"Unknown permission {i}\")\n        return self._fill_deprecated_permissions(l)\n\n    def get_requested_aosp_permissions(self) -&gt; list[str]:\n        \"\"\"\n        Returns requested permissions declared within AOSP project.\n\n        This includes several other permissions as well, which are in the platform apps.\n\n        :returns: requested permissions\n        \"\"\"\n        aosp_permissions = []\n        all_permissions = self.get_permissions()\n        for perm in all_permissions:\n            if perm in list(self.permission_module.keys()):\n                aosp_permissions.append(perm)\n        return aosp_permissions\n\n    def get_requested_aosp_permissions_details(self) -&gt; dict[str, list[str]]:\n        \"\"\"\n        Returns requested aosp permissions with details.\n\n        :returns: requested aosp permissions\n        \"\"\"\n        l = {}\n        for i in self.permissions:\n            try:\n                l[i] = self.permission_module[i]\n            except KeyError:\n                # if we have not found permission do nothing\n                continue\n        return l\n\n    def get_requested_third_party_permissions(self) -&gt; list[str]:\n        \"\"\"\n        Returns list of requested permissions not declared within AOSP project.\n\n        :returns: requested permissions\n        \"\"\"\n        third_party_permissions = []\n        all_permissions = self.get_permissions()\n        for perm in all_permissions:\n            if perm not in list(self.permission_module.keys()):\n                third_party_permissions.append(perm)\n        return third_party_permissions\n\n    def get_declared_permissions(self) -&gt; list[str]:\n        \"\"\"\n        Returns list of the declared permissions.\n\n        :returns: list of declared permissions\n        \"\"\"\n        return list(self.declared_permissions.keys())\n\n    def get_declared_permissions_details(self) -&gt; dict[str, list[str]]:\n        \"\"\"\n        Returns declared permissions with the details.\n\n        :returns: declared permissions\n        \"\"\"\n        return self.declared_permissions\n\n    def get_max_sdk_version(self) -&gt; str:\n        \"\"\"\n        Return the `android:maxSdkVersion` attribute\n\n        :returns: the `android:maxSdkVersion` attribute\n        \"\"\"\n        return self.get_attribute_value(\"uses-sdk\", \"maxSdkVersion\")\n\n    def get_min_sdk_version(self) -&gt; str:\n        \"\"\"\n          Return the `android:minSdkVersion` attribute\n\n          :returns: the `android:minSdkVersion` attribute\n        \"\"\"\n        return self.get_attribute_value(\"uses-sdk\", \"minSdkVersion\")\n\n    def get_target_sdk_version(self) -&gt; str:\n        \"\"\"\n        Return the `android:targetSdkVersion` attribute\n\n        :returns: the `android:targetSdkVersion` attribute\n        \"\"\"\n        return self.get_attribute_value(\"uses-sdk\", \"targetSdkVersion\")\n\n    def get_effective_target_sdk_version(self) -&gt; int:\n        \"\"\"\n        Return the effective `targetSdkVersion`, always returns int &gt; 0.\n\n        If the `targetSdkVersion` is not set, it defaults to 1.  This is\n        set based on defaults as defined in:\n        &lt;https://developer.android.com/guide/topics/manifest/uses-sdk-element.html&gt;\n\n        :returns: the effective `targetSdkVersion`\n        \"\"\"\n        target_sdk_version = self.get_target_sdk_version()\n        if not target_sdk_version:\n            target_sdk_version = self.get_min_sdk_version()\n        try:\n            return int(target_sdk_version)\n        except (ValueError, TypeError):\n            return 1\n\n    def get_libraries(self) -&gt; list[str]:\n        \"\"\"\n        Return the `android:name` attributes for libraries\n\n        :returns: the `android:name` attributes\n        \"\"\"\n        return list(self.get_all_attribute_value(\"uses-library\", \"name\"))\n\n    def get_features(self) -&gt; list[str]:\n        \"\"\"\n        Return a list of all `android:names` found for the tag `uses-feature`\n        in the `AndroidManifest.xml`\n\n        :returns: the `android:names` found\n        \"\"\"\n        return list(self.get_all_attribute_value(\"uses-feature\", \"name\"))\n\n    def is_wearable(self) -&gt; bool:\n        \"\"\"\n        Checks if this application is build for wearables by\n        checking if it uses the feature 'android.hardware.type.watch'\n        See: https://developer.android.com/training/wearables/apps/creating.html for more information.\n\n        Not every app is setting this feature (not even the example Google provides),\n        so it might be wise to not 100% rely on this feature.\n\n        :returns: `True` if wearable, `False` otherwise\n        \"\"\"\n        return 'android.hardware.type.watch' in self.get_features()\n\n    def is_leanback(self) -&gt; bool:\n        \"\"\"\n        Checks if this application is build for TV (Leanback support)\n        by checkin if it uses the feature 'android.software.leanback'\n\n        :returns: `True` if leanback feature is used, `False` otherwise\n        \"\"\"\n        return 'android.software.leanback' in self.get_features()\n\n    def is_androidtv(self) -&gt; bool:\n        \"\"\"\n        Checks if this application does not require a touchscreen,\n        as this is the rule to get into the TV section of the Play Store\n        See: https://developer.android.com/training/tv/start/start.html for more information.\n\n        :returns: `True` if 'android.hardware.touchscreen' is not required, `False` otherwise\n        \"\"\"\n        return (\n            self.get_attribute_value(\n                'uses-feature',\n                'name',\n                required=\"false\",\n                name=\"android.hardware.touchscreen\",\n            )\n            == \"android.hardware.touchscreen\"\n        )\n\n    def get_certificate_der(\n        self, filename: str, max_sdk_version: int = None\n    ) -&gt; Union[bytes, None]:\n        \"\"\"\n        Return the DER coded X.509 certificate from the signature file.\n        If minSdkVersion is prior to Android N only the first SignerInfo is used.\n        If signed attributes are present, they are taken into account\n        Note that unsupported critical extensions and key usage are not verified!\n        [V1SchemeVerifier.java](https://android.googlesource.com/platform/tools/apksig/+/refs/tags/platform-tools-34.0.5/src/main/java/com/android/apksig/internal/apk/v1/V1SchemeVerifier.java#668)\n\n        :param filename: Signature filename in APK\n        :param max_sdk_version: An optional integer parameter for the max sdk version\n        :returns: DER coded X.509 certificate as binary or None\n        \"\"\"\n\n        # Get the signature\n        pkcs7message = self.get_file(filename)\n        # Get the .SF\n        sf_filename = os.path.splitext(filename)[0] + '.SF'\n        sf_object = self.get_file(sf_filename)\n        # Load the signature\n        signed_data = cms.ContentInfo.load(pkcs7message)\n        # Locate the SignerInfo structure\n        signer_infos = signed_data['content']['signer_infos']\n        if not signer_infos:\n            logger.error(\n                'No signer information found in the PKCS7 object. The APK may not be properly signed.'\n            )\n            return None\n\n        # Prior to Android N, Android attempts to verify only the first SignerInfo. From N onwards, Android attempts\n        # to verify all SignerInfos and then picks the first verified SignerInfo.\n        min_sdk_version = self.get_min_sdk_version()\n        if (\n            min_sdk_version is None or int(min_sdk_version) &lt; 24\n        ):  # AndroidSdkVersion.N\n            logger.info(\n                f\"minSdkVersion: {min_sdk_version} is less than 24. Getting the first signerInfo only!\"\n            )\n            unverified_signer_infos_to_try = [signer_infos[0]]\n        else:\n            unverified_signer_infos_to_try = signer_infos\n\n        # Extract certificates from the PKCS7 object\n        certificates = signed_data['content']['certificates']\n        return_certificate = None\n        list_certificates_verified = []\n        for signer_info in unverified_signer_infos_to_try:\n            try:\n                matching_certificate_verified = (\n                    self.verify_signer_info_against_sig_file(\n                        signed_data,\n                        certificates,\n                        signer_info,\n                        sf_object,\n                        max_sdk_version,\n                    )\n                )\n            except (ValueError, TypeError, OSError, InvalidSignature) as e:\n                logger.error(\n                    f\"The following exception was raised while verifying the certificate: {e}\"\n                )\n                return (\n                    None  # the validation stops due to the exception raised!\n                )\n            if matching_certificate_verified is not None:\n                list_certificates_verified.append(\n                    matching_certificate_verified\n                )\n        if not list_certificates_verified:\n            logger.error(\n                f\"minSdkVersion: {min_sdk_version}, # of SignerInfos: {len(unverified_signer_infos_to_try)}. None Verified!\"\n            )\n        else:\n            return_certificate = list_certificates_verified[0]\n        return return_certificate\n\n    def verify_signer_info_against_sig_file(\n        self,\n        signed_data: asn1crypto.cms.ContentInfo,\n        certificates: asn1crypto.cms.CertificateSet,\n        signer_info: asn1crypto.cms.SignerInfo,\n        sf_object: str,\n        max_sdk_version: Union[int, None],\n    ) -&gt; Union[bytes, None]:\n        matching_certificate = self.find_certificate(certificates, signer_info)\n        matching_certificate_verified = None\n        digest_algorithm, crypto_hash_algorithm = self.get_hash_algorithm(\n            signer_info\n        )\n        if matching_certificate is None:\n            raise ValueError(\n                \"Signing certificate referenced in SignerInfo not found in SignedData\"\n            )\n        else:\n            if signer_info['signed_attrs'].native:\n                logger.info(\"Signed Attributes detected!\")\n                signed_attrs = signer_info['signed_attrs']\n                signed_attrs_dict = OrderedDict()\n                for attr in signed_attrs:\n                    if attr['type'].dotted in signed_attrs_dict:\n                        raise ValueError(\n                            f\"Duplicate signed attribute: {attr['type'].dotted}\"\n                        )\n                    signed_attrs_dict[attr['type'].dotted] = attr['values']\n\n                # Check content type attribute (for Android N and newer)\n                if max_sdk_version is None or int(max_sdk_version) &gt;= 24:\n                    content_type_oid = (\n                        '1.2.840.113549.1.9.3'  # OID for contentType\n                    )\n                    if content_type_oid not in signed_attrs_dict:\n                        raise ValueError(\n                            \"No Content Type in signed attributes\"\n                        )\n                    content_type = signed_attrs_dict[content_type_oid][\n                        0\n                    ].native\n                    if (\n                        content_type\n                        != signed_data['content']['encap_content_info'][\n                            'content_type'\n                        ].native\n                    ):\n                        logger.error(\n                            \"Content Type mismatch. Continuing to next SignerInfo, if any.\"\n                        )\n                        return None\n\n                # Check message digest attribute\n                message_digest_oid = (\n                    '1.2.840.113549.1.9.4'  # OID for messageDigest\n                )\n                if message_digest_oid not in signed_attrs_dict:\n                    raise ValueError(\"No content digest in signed attributes\")\n                expected_signature_file_digest = signed_attrs_dict[\n                    message_digest_oid\n                ][0].native\n                hash_algo = digest_algorithm()\n                hash_algo.update(sf_object)\n                actual_digest = hash_algo.digest()\n\n                # Compare digests\n                if actual_digest != expected_signature_file_digest:\n                    logger.error(\n                        \"Digest mismatch. Continuing to next SignerInfo, if any.\"\n                    )\n                    return None\n\n                signed_attrs_dump = signed_attrs.dump()\n                # Modify the first byte to 0x31 for UNIVERSAL SET\n                signed_attrs_dump = b'\\x31' + signed_attrs_dump[1:]\n                matching_certificate_verified = self.verify_signature(\n                    signer_info,\n                    matching_certificate,\n                    signed_attrs_dump,\n                    crypto_hash_algorithm,\n                )\n            else:\n                matching_certificate_verified = self.verify_signature(\n                    signer_info,\n                    matching_certificate,\n                    sf_object,\n                    crypto_hash_algorithm,\n                )\n        return matching_certificate_verified\n\n    @staticmethod\n    def verify_signature(\n        signer_info: asn1crypto.cms.SignerInfo,\n        matching_certificate,\n        signed_data,\n        crypto_hash_algorithm\n    ) -&gt; bytes:\n        matching_certificate_verified = None\n        signature = signer_info['signature'].native\n\n        # Load the certificate using asn1crypto as it can handle more cases (v1-only-with-rsa-1024-cert-not-der.apk)\n        cert = x509.Certificate.load(matching_certificate.chosen.dump())\n        public_key_info = cert.public_key\n\n        # Convert the ASN.1 public key to a cryptography-compatible object\n        public_key_der = public_key_info.dump()\n        public_key = serialization.load_der_public_key(\n            public_key_der, backend=default_backend()\n        )\n\n        try:\n            # RSA Key\n            if isinstance(public_key, rsa.RSAPublicKey):\n                public_key.verify(\n                    signature,\n                    signed_data,\n                    padding.PKCS1v15(),\n                    crypto_hash_algorithm(),\n                )\n\n            # DSA Key\n            elif isinstance(public_key, dsa.DSAPublicKey):\n                public_key.verify(\n                    signature, signed_data, crypto_hash_algorithm()\n                )\n\n            # EC Key\n            elif isinstance(public_key, ec.EllipticCurvePublicKey):\n                public_key.verify(\n                    signature, signed_data, ec.ECDSA(crypto_hash_algorithm())\n                )\n\n            else:\n                raise ValueError(\n                    f\"Unsupported key algorithm: {public_key.__class__.__name__.lower()}\"\n                )\n\n            # If verification succeeds, return the certificate\n            matching_certificate_verified = matching_certificate.chosen.dump()\n\n        except InvalidSignature:\n            logger.info(\n                f\"The public key of the certificate: {hashlib.sha256(matching_certificate.chosen.dump()).hexdigest()} \"\n                f\"is not associated with the signature!\"\n            )\n\n        return matching_certificate_verified\n\n    @staticmethod\n    def get_hash_algorithm(signer_info: asn1crypto.cms.SignerInfo) -&gt; dict[str, hashes.HashAlgorithm]:\n        # Determine the hash algorithm from the SignerInfo\n        digest_algorithm = signer_info['digest_algorithm']['algorithm'].native\n        # Map the digest algorithm to a hash function\n        hash_algorithms = {\n            'md5': (md5, hashes.MD5),\n            'sha1': (sha1, hashes.SHA1),\n            'sha224': (sha224, hashes.SHA224),\n            'sha256': (sha256, hashes.SHA256),\n            'sha384': (sha384, hashes.SHA384),\n            'sha512': (sha512, hashes.SHA512),\n        }\n        if digest_algorithm not in hash_algorithms:\n            raise ValueError(f\"Unsupported hash algorithm: {digest_algorithm}\")\n        return hash_algorithms[digest_algorithm]\n\n    def find_certificate(\n        self,\n        signed_data_certificates: asn1crypto.cms.CertificateSet,\n        signer_info: asn1crypto.cms.SignerInfo) -&gt; Union[asn1crypto.x509.Certificate, None]:\n        \"\"\"\n        From the bag of certs, obtain the certificate referenced by the `asn1crypto.cms.SignerInfo`.\n\n        :param signed_data_certificates: List of certificates in the SignedData.\n        :param signer_info: `SignerInfo` object containing the issuer and serial number reference.\n\n        :returns: The matching certificate if found, otherwise None.\n        \"\"\"\n        matching_certificate = None\n        issuer_and_serial_number = signer_info['sid']\n        issuer_str = self.canonical_name(\n            issuer_and_serial_number.chosen['issuer']\n        )\n        serial_number = issuer_and_serial_number.native['serial_number']\n\n        # # Create a x509.Name object for the issuer in the SignerInfo\n        # issuer_name = x509.Name.build(issuer)\n        # issuer_str = self.canonical_name(issuer_name)\n\n        for cert in signed_data_certificates:\n            if cert.name == 'certificate':\n                cert_issuer = self.canonical_name(\n                    cert.chosen['tbs_certificate']['issuer']\n                )\n                cert_serial_number = cert.native['tbs_certificate'][\n                    'serial_number'\n                ]\n\n                # Compare the canonical string representations of the issuers and the serial numbers\n                if (\n                    cert_issuer == issuer_str\n                    and cert_serial_number == serial_number\n                ):\n                    matching_certificate = cert\n                    break\n\n        return matching_certificate\n\n    def get_certificate(self, filename: str) -&gt; Union[asn1crypto.x509.Certificate, None]:\n        \"\"\"\n        Return a X.509 certificate object by giving the name in the apk file\n\n        :param filename: filename of the signature file in the APK\n        :returns: the certificate object\n        \"\"\"\n        cert = self.get_certificate_der(filename)\n        if cert:\n            certificate = asn1crypto.x509.Certificate.load(cert)\n        else:\n            certificate = None\n        return certificate\n\n    def canonical_name(self, name: asn1crypto.x509.Name, android: bool = False) -&gt; str:\n        \"\"\"\n        ```\n         * Method is dual-licensed under the Apache License 2.0 and GPLv3+.\n         * The original author has granted permission to use this code snippet under the\n         * Apache License 2.0 for inclusion in this project.\n         * https://github.com/obfusk/x509_canonical_name.py/blob/master/x509_canonical_name.py\n        ```\n\n        Returns canonical representation of `asn1crypto.x509.Name` as str (with raw control characters\n        in places those are not stripped by normalisation).\n        \"\"\"\n        # return \",\".join(\"+\".join(f\"{t}:{v}\" for _, t, v in avas) for avas in self.comparison_name(name))\n        return \",\".join(\n            \"+\".join(f\"{t}={v}\" for t, v in avas)\n            for avas in self.comparison_name(name, android=android)\n        )\n\n    def comparison_name(\n        self, name: x509.Name, *, android: bool = False\n    ) -&gt; List[List[Tuple[str, str]]]:\n        \"\"\"\n        ```\n         * Method is dual-licensed under the Apache License 2.0 and GPLv3+.\n         * The original author has granted permission to use this code snippet under the\n         * Apache License 2.0 for inclusion in this project.\n         * https://github.com/obfusk/x509_canonical_name.py/blob/master/x509_canonical_name.py\n        ```\n\n        Canonical representation of x509.Name as nested list.\n\n        Returns a list of RDNs which are a list of AVAs which are a (type, value)\n        tuple, where type is the standard name or dotted OID, and value is the\n        normalised string representation of the value.\n        \"\"\"\n\n        return [\n            [(t, nv) for _, t, nv, _ in avas]\n            for avas in self.x509_ordered_name(name, android=android)\n        ]\n\n    @staticmethod\n    def x509_ordered_name(\n        name: x509.Name,\n        *,  # type: ignore[no-any-unimported]\n        android: bool = False,\n    ) -&gt; List[List[Tuple[int, str, str, str]]]:\n        \"\"\"\n        ```\n         * Method is dual-licensed under the Apache License 2.0 and GPLv3+.\n         * The original author has granted permission to use this code snippet under the\n         * Apache License 2.0 for inclusion in this project.\n         * https://github.com/obfusk/x509_canonical_name.py/blob/master/x509_canonical_name.py\n        ```\n\n        Representation of `x509.Name` as nested list, in canonical ordering (but also\n        including non-canonical pre-normalised string values).\n\n        Returns a list of RDNs which are a list of AVAs which are a (oid, type,\n        normalised_value, esc_value) tuple, where oid is 0 for standard names and 1\n        for dotted OIDs, type is the standard name or dotted OID, normalised_value\n        is the normalised string representation of the value, and esc_value is the\n        string value before normalisation (but after escaping).\n\n        NB: control characters are not escaped, only characters in \",+&lt;&gt;;\\\"\\\\\" and\n        \"#\" at the start (before \"whitespace\" trimming) are.\n\n        [X500Principal.getName](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/security/auth/x500/X500Principal.html#getName(java.lang.String))\n        [AVA.java](https://github.com/openjdk/jdk/blob/jdk-21%2B35/src/java.base/share/classes/sun/security/x509/AVA.java#L805)\n        [RDN.java (472)](https://github.com/openjdk/jdk/blob/jdk-21%2B35/src/java.base/share/classes/sun/security/x509/RDN.java#L472)\n        [RDN.java (481)](https://android.googlesource.com/platform/libcore/+/refs/heads/android14-release/ojluni/src/main/java/sun/security/x509/RDN.java#481)\n        \"\"\"\n\n        def key(\n            ava: Tuple[int, str, str, str]\n        ) -&gt; Tuple[int, Union[str, List[int]], str]:\n            o, t, nv, _ = ava\n            if android and o:\n                return o, [int(x) for x in t.split(\".\")], nv\n            return o, t, nv\n\n        DS, U8, PS = (\n            x509.DirectoryString,\n            x509.UTF8String,\n            x509.PrintableString,\n        )\n        oids = {\n            \"2.5.4.3\": (\"common_name\", \"cn\"),\n            \"2.5.4.6\": (\"country_name\", \"c\"),\n            \"2.5.4.7\": (\"locality_name\", \"l\"),\n            \"2.5.4.8\": (\"state_or_province_name\", \"st\"),\n            \"2.5.4.9\": (\"street_address\", \"street\"),\n            \"2.5.4.10\": (\"organization_name\", \"o\"),\n            \"2.5.4.11\": (\"organizational_unit_name\", \"ou\"),\n            \"0.9.2342.19200300.100.1.1\": (\"user_id\", \"uid\"),\n            \"0.9.2342.19200300.100.1.25\": (\"domain_component\", \"dc\"),\n        }\n        esc = {ord(c): f\"\\\\{c}\" for c in \",+&lt;&gt;;\\\"\\\\\"}\n        cws = \"\".join(\n            chr(i) for i in range(32 + 1)\n        )  # control (but not esc) and whitespace\n        data = []\n        for rdn in reversed(name.chosen):\n            avas = []\n            for ava in rdn:\n                at, av = ava[\"type\"], ava[\"value\"]\n                if at.dotted in oids:\n                    o, t = 0, oids[at.dotted][1]  # order standard before OID\n                else:\n                    o, t = 1, at.dotted\n                if o or not (\n                    isinstance(av, DS) and isinstance(av.chosen, (U8, PS))\n                ):\n                    ev = nv = \"#\" + binascii.hexlify(av.dump()).decode()\n                else:\n                    ev = (av.native or \"\").translate(esc)\n                    if ev.startswith(\"#\"):\n                        ev = \"\\\\\" + ev\n                    nv = unicodedata.normalize(\n                        \"NFKD\",\n                        re.sub(r\" +\", \" \", ev).strip(cws).upper().lower(),\n                    )\n                avas.append((o, t, nv, ev))\n            data.append(sorted(avas, key=key))\n        return data\n\n    def new_zip(\n        self,\n        filename: str,\n        deleted_files: Union[str, None] = None,\n        new_files: dict = {},\n    ) -&gt; None:\n        \"\"\"\n        Create a new zip file\n\n        :param filename: the output filename of the zip\n        :param deleted_files: a regex pattern to remove specific file, or `None`\n        :param new_files: a dictionnary of new files (key:filename, value:content of the file)\n        \"\"\"\n        zout = zipfile.ZipFile(filename, 'w')\n\n        for item in self.zip.infolist():\n            # Block one: deleted_files, or deleted_files and new_files\n            if deleted_files is not None:\n                if re.match(deleted_files, item) is None:\n                    # if the regex of deleted_files doesn't match the filename\n                    if new_files is not False:\n                        if item in new_files:\n                            # and if the filename is in new_files\n                            zout.writestr(item, new_files[item])\n                            continue\n                    # Otherwise, write the original file.\n                    buffer = self.zip.read(item)\n                    zout.writestr(item, buffer)\n            # Block two: deleted_files is None, new_files is not empty\n            elif new_files is not False:\n                if item in new_files:\n                    zout.writestr(item, new_files[item])\n                else:\n                    buffer = self.zip.read(item)\n                    zout.writestr(item, buffer)\n            # Block three: deleted_files is None, new_files is empty.\n            # Just write out the default zip\n            else:\n                buffer = self.zip.read(item)\n                zout.writestr(item, buffer)\n        zout.close()\n\n    def get_android_manifest_axml(self) -&gt; Union[AXMLPrinter, None]:\n        \"\"\"\n        Return the [AXMLPrinter][androguard.core.axml.AXMLPrinter] object which corresponds to the `AndroidManifest.xml` file\n\n        :returns: the `AXMLPrinter` object\n        \"\"\"\n        try:\n            return self.axml[\"AndroidManifest.xml\"]\n        except KeyError:\n            return None\n\n    def get_android_manifest_xml(self) -&gt; Union[lxml.etree.Element, None]:\n        \"\"\"\n        Return the parsed xml object which corresponds to the `AndroidManifest.xml` file\n\n        :returns: the parsed xml object\n        \"\"\"\n        try:\n            return self.xml[\"AndroidManifest.xml\"]\n        except KeyError:\n            return None\n\n    def get_android_resources(self) -&gt; Union[ARSCParser, None]:\n        \"\"\"\n        Return the [ARSCParser][androguard.core.axml.ARSCParser] object which corresponds to the `resources.arsc` file\n\n        :returns: the `ARSCParser` object\n        \"\"\"\n        try:\n            return self.arsc[\"resources.arsc\"]\n        except KeyError:\n            if \"resources.arsc\" not in self.zip.namelist():\n                # There is a rare case, that no resource file is supplied.\n                # Maybe it was added manually, thus we check here\n                return None\n            self.arsc[\"resources.arsc\"] = ARSCParser(\n                self.zip.read(\"resources.arsc\")\n            )\n            return self.arsc[\"resources.arsc\"]\n\n    def is_signed(self) -&gt; bool:\n        \"\"\"\n        Returns true if any of v1, v2, or v3 signatures were found.\n\n        :returns: True if any of v1, v2, or v3 signatures were found, else False\n        \"\"\"\n        return (\n            self.is_signed_v1() or self.is_signed_v2() or self.is_signed_v3()\n        )\n\n    def is_signed_v1(self) -&gt; bool:\n        \"\"\"\n        Returns `True` if a v1 / JAR signature was found.\n\n        Returning `True` does not mean that the file is properly signed!\n        It just says that there is a signature file which needs to be validated.\n\n        :returns: `True` if a v1 / JAR signature was found, else `False`\n        \"\"\"\n        return self.get_signature_name() is not None\n\n    def is_signed_v2(self) -&gt; bool:\n        \"\"\"\n        Returns `True` of a v2 / APK signature was found.\n\n        Returning `True` does not mean that the file is properly signed!\n        It just says that there is a signature file which needs to be validated.\n\n        :returns: `True` of a v2 / APK signature was found, else `False`\n        \"\"\"\n        if self._is_signed_v2 is None:\n            self.parse_v2_v3_signature()\n\n        return self._is_signed_v2\n\n    def is_signed_v3(self) -&gt; bool:\n        \"\"\"\n        Returns `True` of a v3 / APK signature was found.\n\n        Returning `True` does not mean that the file is properly signed!\n        It just says that there is a signature file which needs to be validated.\n\n        :returns: `True` of a v3 / APK signature was found, else `False`\n        \"\"\"\n        if self._is_signed_v3 is None:\n            self.parse_v2_v3_signature()\n\n        return self._is_signed_v3\n\n    def read_uint32_le(self, io_stream) -&gt; int:\n        \"\"\"read a `uint32_le` from `io_stream`\n\n        :param io_stream: the stream to get a `uint32_le` from\n        :return: the `uint32_le` value\n        \"\"\"\n        (value,) = unpack('&lt;I', io_stream.read(4))\n        return value\n\n    def parse_signatures_or_digests(\n        self, digest_bytes: bytes\n    ) -&gt; list[tuple[int, bytes]]:\n        \"\"\"Parse digests\n\n        :param digest_bytes: the digests bytes\n        :returns: a list of tuple where the first element is the `algorithm_id` and the second is the digest bytes\n        \"\"\"\n\n        if not len(digest_bytes):\n            return []\n\n        digests = []\n        block = io.BytesIO(digest_bytes)\n\n        data_len = self.read_uint32_le(block)\n        while block.tell() &lt; data_len:\n\n            algorithm_id = self.read_uint32_le(block)\n            digest_len = self.read_uint32_le(block)\n            digest = block.read(digest_len)\n\n            digests.append((algorithm_id, digest))\n\n        return digests\n\n    def parse_v2_v3_signature(self) -&gt; None:\n        # Need to find an v2 Block in the APK.\n        # The Google Docs gives you the following rule:\n        # * go to the end of the ZIP File\n        # * search for the End of Central directory\n        # * then jump to the beginning of the central directory\n        # * Read now the magic of the signing block\n        # * before the magic there is the size_of_block, so we can jump to\n        # the beginning.\n        # * There should be again the size_of_block\n        # * Now we can read the Key-Values\n        # * IDs with an unknown value should be ignored.\n        f = io.BytesIO(self.get_raw())\n\n        size_central = None\n        offset_central = None\n\n        # Go to the end\n        f.seek(-1, io.SEEK_END)\n        # we know the minimal length for the central dir is 16+4+2\n        f.seek(-20, io.SEEK_CUR)\n\n        while f.tell() &gt; 0:\n            f.seek(-1, io.SEEK_CUR)\n            (r,) = unpack('&lt;4s', f.read(4))\n            if r == self._PK_END_OF_CENTRAL_DIR:\n                # Read central dir\n                (\n                    this_disk,\n                    disk_central,\n                    this_entries,\n                    total_entries,\n                    size_central,\n                    offset_central,\n                ) = unpack('&lt;HHHHII', f.read(16))\n                # TODO according to the standard we need to check if the\n                # end of central directory is the last item in the zip file\n                # TODO We also need to check if the central dir is exactly\n                # before the end of central dir...\n\n                # These things should not happen for APKs\n                if this_disk != 0:\n                    logger.warning(\n                        \"This is a multi disk ZIP! Attempting to process its signature anyway!\"\n                    )\n                if disk_central != 0:\n                    logger.warning(\n                        \"This is a multi disk ZIP! Attempting to process its signature anyway!\"\n                    )\n                break\n            f.seek(-4, io.SEEK_CUR)\n\n        if not offset_central:\n            return\n\n        f.seek(offset_central)\n        (r,) = unpack('&lt;4s', f.read(4))\n        f.seek(-4, io.SEEK_CUR)\n        if r != self._PK_CENTRAL_DIR:\n            raise BrokenAPKError(\"No Central Dir at specified offset\")\n\n        # Go back and check if we have a magic\n        end_offset = f.tell()\n        f.seek(-24, io.SEEK_CUR)\n        size_of_block, magic = unpack('&lt;Q16s', f.read(24))\n\n        self._is_signed_v2 = False\n        self._is_signed_v3 = False\n\n        if magic != self._APK_SIG_MAGIC:\n            return\n\n        # go back size_of_blocks + 8 and read size_of_block again\n        f.seek(-(size_of_block + 8), io.SEEK_CUR)\n        (size_of_block_start,) = unpack(\"&lt;Q\", f.read(8))\n        if size_of_block_start != size_of_block:\n            raise BrokenAPKError(\"Sizes at beginning and end does not match!\")\n\n        # Store all blocks\n        while f.tell() &lt; end_offset - 24:\n            size, key = unpack('&lt;QI', f.read(12))\n            value = f.read(size - 4)\n            if key in self._v2_blocks:\n                # TODO: Store the duplicate V2 Signature blocks and offer a way to show them\n                # https://github.com/androguard/androguard/issues/1030\n                logger.warning(\n                    \"Duplicate block ID in APK Signing Block: {}\".format(key)\n                )\n            else:\n                self._v2_blocks[key] = value\n\n        # Test if a signature is found\n        if self._APK_SIG_KEY_V2_SIGNATURE in self._v2_blocks:\n            self._is_signed_v2 = True\n\n        if self._APK_SIG_KEY_V3_SIGNATURE in self._v2_blocks:\n            self._is_signed_v3 = True\n\n    def parse_v3_signing_block(self) -&gt; None:\n        \"\"\"\n        Parse the V2 signing block and extract all features\n        \"\"\"\n\n        self._v3_signing_data = []\n\n        # calling is_signed_v3 should also load the signature, if any\n        if not self.is_signed_v3():\n            return\n\n        block_bytes = self._v2_blocks[self._APK_SIG_KEY_V3_SIGNATURE]\n        block = io.BytesIO(block_bytes)\n        view = block.getvalue()\n\n        # V3 signature Block data format:\n        #\n        # * signer:\n        #    * signed data:\n        #        * digests:\n        #            * signature algorithm ID (uint32)\n        #            * digest (length-prefixed)\n        #        * certificates\n        #        * minSDK\n        #        * maxSDK\n        #        * additional attributes\n        #    * minSDK\n        #    * maxSDK\n        #    * signatures\n        #    * publickey\n        size_sequence = self.read_uint32_le(block)\n        if size_sequence + 4 != len(block_bytes):\n            raise BrokenAPKError(\n                \"size of sequence and blocksize does not match\"\n            )\n\n        while block.tell() &lt; len(block_bytes):\n            off_signer = block.tell()\n            size_signer = self.read_uint32_le(block)\n\n            # read whole signed data, since we might to parse\n            # content within the signed data, and mess up offset\n            len_signed_data = self.read_uint32_le(block)\n            signed_data_bytes = block.read(len_signed_data)\n            signed_data = io.BytesIO(signed_data_bytes)\n\n            # Digests\n            len_digests = self.read_uint32_le(signed_data)\n            raw_digests = signed_data.read(len_digests)\n            digests = self.parse_signatures_or_digests(raw_digests)\n\n            # Certs\n            certs = []\n            len_certs = self.read_uint32_le(signed_data)\n            start_certs = signed_data.tell()\n            while signed_data.tell() &lt; start_certs + len_certs:\n\n                len_cert = self.read_uint32_le(signed_data)\n                cert = signed_data.read(len_cert)\n                certs.append(cert)\n\n            # versions\n            signed_data_min_sdk = self.read_uint32_le(signed_data)\n            signed_data_max_sdk = self.read_uint32_le(signed_data)\n\n            # Addional attributes\n            len_attr = self.read_uint32_le(signed_data)\n            attr = signed_data.read(len_attr)\n\n            signed_data_object = APKV3SignedData()\n            signed_data_object._bytes = signed_data_bytes\n            signed_data_object.digests = digests\n            signed_data_object.certificates = certs\n            signed_data_object.additional_attributes = attr\n            signed_data_object.minSDK = signed_data_min_sdk\n            signed_data_object.maxSDK = signed_data_max_sdk\n\n            # versions (should be the same as signed data's versions)\n            signer_min_sdk = self.read_uint32_le(block)\n            signer_max_sdk = self.read_uint32_le(block)\n\n            # Signatures\n            len_sigs = self.read_uint32_le(block)\n            raw_sigs = block.read(len_sigs)\n            sigs = self.parse_signatures_or_digests(raw_sigs)\n\n            # PublicKey\n            len_publickey = self.read_uint32_le(block)\n            publickey = block.read(len_publickey)\n\n            signer = APKV3Signer()\n            signer._bytes = view[off_signer : off_signer + size_signer]\n            signer.signed_data = signed_data_object\n            signer.signatures = sigs\n            signer.public_key = publickey\n            signer.minSDK = signer_min_sdk\n            signer.maxSDK = signer_max_sdk\n\n            self._v3_signing_data.append(signer)\n\n    def parse_v2_signing_block(self) -&gt; None:\n        \"\"\"\n        Parse the V2 signing block and extract all features\n        \"\"\"\n\n        self._v2_signing_data = []\n\n        # calling is_signed_v2 should also load the signature\n        if not self.is_signed_v2():\n            return\n\n        block_bytes = self._v2_blocks[self._APK_SIG_KEY_V2_SIGNATURE]\n        block = io.BytesIO(block_bytes)\n        view = block.getvalue()\n\n        # V2 signature Block data format:\n        #\n        # * signer:\n        #    * signed data:\n        #        * digests:\n        #            * signature algorithm ID (uint32)\n        #            * digest (length-prefixed)\n        #        * certificates\n        #        * additional attributes\n        #    * signatures\n        #    * publickey\n\n        size_sequence = self.read_uint32_le(block)\n        if size_sequence + 4 != len(block_bytes):\n            raise BrokenAPKError(\n                \"size of sequence and blocksize does not match\"\n            )\n\n        while block.tell() &lt; len(block_bytes):\n            off_signer = block.tell()\n            size_signer = self.read_uint32_le(block)\n\n            # read whole signed data, since we might to parse\n            # content within the signed data, and mess up offset\n            len_signed_data = self.read_uint32_le(block)\n            signed_data_bytes = block.read(len_signed_data)\n            signed_data = io.BytesIO(signed_data_bytes)\n\n            # Digests\n            len_digests = self.read_uint32_le(signed_data)\n            raw_digests = signed_data.read(len_digests)\n            digests = self.parse_signatures_or_digests(raw_digests)\n\n            # Certs\n            certs = []\n            len_certs = self.read_uint32_le(signed_data)\n            start_certs = signed_data.tell()\n            while signed_data.tell() &lt; start_certs + len_certs:\n                len_cert = self.read_uint32_le(signed_data)\n                cert = signed_data.read(len_cert)\n                certs.append(cert)\n\n            # Additional attributes\n            len_attr = self.read_uint32_le(signed_data)\n            attributes = signed_data.read(len_attr)\n\n            signed_data_object = APKV2SignedData()\n            signed_data_object._bytes = signed_data_bytes\n            signed_data_object.digests = digests\n            signed_data_object.certificates = certs\n            signed_data_object.additional_attributes = attributes\n\n            # Signatures\n            len_sigs = self.read_uint32_le(block)\n            raw_sigs = block.read(len_sigs)\n            sigs = self.parse_signatures_or_digests(raw_sigs)\n\n            # PublicKey\n            len_publickey = self.read_uint32_le(block)\n            publickey = block.read(len_publickey)\n\n            signer = APKV2Signer()\n            signer._bytes = view[off_signer : off_signer + size_signer]\n            signer.signed_data = signed_data_object\n            signer.signatures = sigs\n            signer.public_key = publickey\n\n            self._v2_signing_data.append(signer)\n\n    def get_public_keys_der_v3(self) -&gt; list[bytes]:\n        \"\"\"\n        Return a list of DER coded X.509 public keys from the v3 signature block\n\n        :returns: the list of public key bytes\n        \"\"\"\n\n        if self._v3_signing_data == None:\n            self.parse_v3_signing_block()\n\n        public_keys = []\n\n        for signer in self._v3_signing_data:\n            public_keys.append(signer.public_key)\n\n        return public_keys\n\n    def get_public_keys_der_v2(self) -&gt; list[bytes]:\n        \"\"\"\n        Return a list of DER coded X.509 public keys from the v3 signature block\n\n        :returns: the list of public key bytes\n        \"\"\"\n\n        if self._v2_signing_data == None:\n            self.parse_v2_signing_block()\n\n        public_keys = []\n\n        for signer in self._v2_signing_data:\n            public_keys.append(signer.public_key)\n\n        return public_keys\n\n    def get_certificates_der_v3(self) -&gt; list[bytes]:\n        \"\"\"\n        Return a list of DER coded X.509 certificates from the v3 signature block\n\n        :returns: the list of public key bytes\n        \"\"\"\n\n        if self._v3_signing_data == None:\n            self.parse_v3_signing_block()\n\n        certs = []\n        for signed_data in [\n            signer.signed_data for signer in self._v3_signing_data\n        ]:\n            for cert in signed_data.certificates:\n                certs.append(cert)\n\n        return certs\n\n    def get_certificates_der_v2(self) -&gt; list[bytes]:\n        \"\"\"\n        Return a list of DER coded X.509 certificates from the v3 signature block\n\n        :returns: the list of public key bytes\n        \"\"\"\n\n        if self._v2_signing_data == None:\n            self.parse_v2_signing_block()\n\n        certs = []\n        for signed_data in [\n            signer.signed_data for signer in self._v2_signing_data\n        ]:\n            for cert in signed_data.certificates:\n                certs.append(cert)\n\n        return certs\n\n    def get_public_keys_v3(self) -&gt; list[asn1crypto.keys.PublicKeyInfo]:\n        \"\"\"\n        Return a list of `asn1crypto.keys.PublicKeyInfo` which are found\n        in the v3 signing block.\n\n        :returns: a list of the found `asn1crypto.keys.PublicKeyInfo`\n        \"\"\"\n        return [\n            keys.PublicKeyInfo.load(pkey)\n            for pkey in self.get_public_keys_der_v3()\n        ]\n\n    def get_public_keys_v2(self) -&gt; list[asn1crypto.keys.PublicKeyInfo]:\n        \"\"\"\n        Return a list of `asn1crypto.keys.PublicKeyInfo` which are found\n        in the v2 signing block.\n\n        :returns: a list of the found `asn1crypto.keys.PublicKeyInfo`\n        \"\"\"\n        return [\n            keys.PublicKeyInfo.load(pkey)\n            for pkey in self.get_public_keys_der_v2()\n        ]\n\n    def get_certificates_v3(self) -&gt; list[asn1crypto.x509.Certificate]:\n        \"\"\"\n        Return a list of `asn1crypto.x509.Certificate` which are found\n        in the v3 signing block.\n        Note that we simply extract all certificates regardless of the signer.\n        Therefore this is just a list of all certificates found in all signers.\n\n        :returns: a list of the found `asn1crypto.x509.Certificate`\n        \"\"\"\n        return [\n            x509.Certificate.load(cert)\n            for cert in self.get_certificates_der_v3()\n        ]\n\n    def get_certificates_v2(self) -&gt; list[asn1crypto.x509.Certificate]:\n        \"\"\"\n        Return a list of `asn1crypto.x509.Certificate` which are found\n        in the v2 signing block.\n        Note that we simply extract all certificates regardless of the signer.\n        Therefore this is just a list of all certificates found in all signers.\n\n        :returns: a list of the found `asn1crypto.x509.Certificate`\n        \"\"\"\n        return [\n            x509.Certificate.load(cert)\n            for cert in self.get_certificates_der_v2()\n        ]\n\n    def get_certificates_v1(self) -&gt; list[Union[x509.Certificate, None]]:\n        \"\"\"\n        Return a list of verified `asn1crypto.x509.Certificate` which are found\n        in the META-INF folder (v1 signing).\n        \"\"\"\n        certs = []\n        for x in self.get_signature_names():\n            cc = self.get_certificate_der(x)\n            if cc is not None:\n                certs.append(x509.Certificate.load(cc))\n        return certs\n\n    def get_certificates(self) -&gt; list[asn1crypto.x509.Certificate]:\n        \"\"\"\n        Return a list of unique `asn1crypto.x509.Certificate` which are found\n        in v1, v2 and v3 signing\n        Note that we simply extract all certificates regardless of the signer.\n        Therefore this is just a list of all certificates found in all signers.\n        Exception is v1, for which the certificate returned is verified.\n\n        :returns: a list of the found `asn1crypto.x509.Certificate`\n        \"\"\"\n        fps = []\n        certs = []\n        for x in (\n            self.get_certificates_v1()\n            + self.get_certificates_v2()\n            + self.get_certificates_v3()\n        ):\n            if x.sha256 not in fps:\n                fps.append(x.sha256)\n                certs.append(x)\n        return certs\n\n    def get_signature_name(self) -&gt; Union[str, None]:\n        \"\"\"\n        Return the name of the first signature file found.\n\n        :returns: the name of the first signature file, or `None` if not signed\n        \"\"\"\n        if self.get_signature_names():\n            return self.get_signature_names()[0]\n        else:\n            # Unsigned APK\n            return None\n\n    def get_signature_names(self) -&gt; list[str]:\n        \"\"\"\n        Return a list of the signature file names (v1 Signature / JAR\n        Signature)\n\n        :returns: List of filenames matching a Signature\n        \"\"\"\n        signature_expr = re.compile(r\"^(META-INF/)(.*)(\\.RSA|\\.EC|\\.DSA)$\")\n        signatures = []\n\n        for i in self.get_files():\n            if signature_expr.search(i):\n                if \"{}.SF\".format(i.rsplit(\".\", 1)[0]) in self.get_files():\n                    signatures.append(i)\n                else:\n                    logger.warning(\n                        \"v1 signature file {} missing .SF file - Partial signature!\".format(\n                            i\n                        )\n                    )\n\n        return signatures\n\n    def get_signature(self) -&gt; Union[str, None]:\n        \"\"\"\n        Return the data of the first signature file found (v1 Signature / JAR\n        Signature)\n\n        :returns: First signature name or None if not signed\n        \"\"\"\n        if self.get_signatures():\n            return self.get_signatures()[0]\n        else:\n            return None\n\n    def get_signatures(self) -&gt; list[bytes]:\n        \"\"\"\n        Return a list of the data of the signature files.\n        Only v1 / JAR Signing.\n\n        :returns: list of bytes\n        \"\"\"\n        signature_expr = re.compile(r\"^(META-INF/)(.*)(\\.RSA|\\.EC|\\.DSA)$\")\n        signature_datas = []\n\n        for i in self.get_files():\n            if signature_expr.search(i):\n                signature_datas.append(self.get_file(i))\n\n        return signature_datas\n\n    def show(self) -&gt; None:\n        self.get_files_types()\n\n        print(\"FILES: \")\n        for i in self.get_files():\n            try:\n                print(\"\\t\", i, self._files[i], \"%x\" % self.files_crc32[i])\n            except KeyError:\n                print(\"\\t\", i, \"%x\" % self.files_crc32[i])\n\n        print(\"DECLARED PERMISSIONS:\")\n        declared_permissions = self.get_declared_permissions()\n        for i in declared_permissions:\n            print(\"\\t\", i)\n\n        print(\"REQUESTED PERMISSIONS:\")\n        requested_permissions = self.get_permissions()\n        for i in requested_permissions:\n            print(\"\\t\", i)\n\n        print(\"MAIN ACTIVITY: \", self.get_main_activity())\n\n        print(\"ACTIVITIES: \")\n        activities = self.get_activities()\n        for i in activities:\n            filters = self.get_intent_filters(\"activity\", i)\n            print(\"\\t\", i, filters or \"\")\n\n        print(\"SERVICES: \")\n        services = self.get_services()\n        for i in services:\n            filters = self.get_intent_filters(\"service\", i)\n            print(\"\\t\", i, filters or \"\")\n\n        print(\"RECEIVERS: \")\n        receivers = self.get_receivers()\n        for i in receivers:\n            filters = self.get_intent_filters(\"receiver\", i)\n            print(\"\\t\", i, filters or \"\")\n\n        print(\"PROVIDERS: \", self.get_providers())\n\n        if self.is_signed_v1():\n            print(\"CERTIFICATES v1:\")\n            for c in self.get_signature_names():\n                show_Certificate(self.get_certificate(c))\n\n        if self.is_signed_v2():\n            print(\"CERTIFICATES v2:\")\n            for c in self.get_certificates_v2():\n                show_Certificate(c)\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.files","title":"<code>files</code>  <code>property</code>","text":"<p>Returns a dictionary of filenames and detected magic type</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dictionary of files and their mime type</p>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.__getstate__","title":"<code>__getstate__()</code>","text":"<p>Function for pickling APK Objects.</p> <p>We remove the zip from the Object, as it is not pickable And it does not make any sense to pickle it anyways.</p> <p>Returns:</p> Type Description <p>the picklable APK Object without zip.</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def __getstate__(self):\n    \"\"\"\n    Function for pickling APK Objects.\n\n    We remove the zip from the Object, as it is not pickable\n    And it does not make any sense to pickle it anyways.\n\n    :returns: the picklable APK Object without zip.\n    \"\"\"\n    # Upon pickling, we need to remove the ZipFile\n    x = self.__dict__\n    x['axml'] = str(x['axml'])\n    x['xml'] = str(x['xml'])\n    del x['zip']\n\n    return x\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.__init__","title":"<code>__init__(filename, raw=False, magic_file=None, skip_analysis=False, testzip=False)</code>","text":"<p>This class can access to all elements in an APK file</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; APK(\"myfile.apk\")\n&gt;&gt;&gt; APK(read(\"myfile.apk\"), raw=True)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>specify the path of the file, or raw data</p> required <code>raw</code> <code>bool</code> <p>specify if the filename is a path or raw data (optional)</p> <code>False</code> <code>magic_file</code> <code>Union[str, None]</code> <p>specify the magic file (not used anymore - legacy only)</p> <code>None</code> <code>skip_analysis</code> <code>bool</code> <p>Skip the analysis, e.g. no manifest files are read. (default: <code>False</code>)</p> <code>False</code> <code>testzip</code> <code>bool</code> <p>Test the APK for integrity, e.g. if the ZIP file is broken. Throw an exception on failure (default <code>False</code>)</p> <code>False</code> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def __init__(\n    self,\n    filename: str,\n    raw: bool = False,\n    magic_file: Union[str, None] = None,\n    skip_analysis: bool = False,\n    testzip: bool = False,\n) -&gt; None:\n    \"\"\"\n    This class can access to all elements in an APK file\n\n    Examples:\n\n        &gt;&gt;&gt; APK(\"myfile.apk\")\n        &gt;&gt;&gt; APK(read(\"myfile.apk\"), raw=True)\n\n    :param filename: specify the path of the file, or raw data\n    :param raw: specify if the filename is a path or raw data (optional)\n    :param magic_file: specify the magic file (not used anymore - legacy only)\n    :param skip_analysis: Skip the analysis, e.g. no manifest files are read. (default: `False`)\n    :param testzip: Test the APK for integrity, e.g. if the ZIP file is broken. Throw an exception on failure (default `False`)\n    \"\"\"\n    if magic_file:\n        logger.warning(\n            \"You set magic_file but this parameter is actually unused. You should remove it.\"\n        )\n\n    self.filename = filename\n\n    self.xml = {}\n    self.axml = {}\n    self.arsc = {}\n\n    self.package = \"\"\n    self.androidversion = {}\n    self.permissions = []\n    self.uses_permissions = []\n    self.declared_permissions = {}\n    self.valid_apk = False\n\n    self._is_signed_v2 = None\n    self._is_signed_v3 = None\n    self._v2_blocks = {}\n    self._v2_signing_data = None\n    self._v3_signing_data = None\n\n    self._files = {}\n    self.files_crc32 = {}\n\n    if raw is True:\n        self.__raw = filename\n        self._sha256 = hashlib.sha256(self.__raw).hexdigest()\n        # Set the filename to something sane\n        self.filename = \"raw_apk_sha256:{}\".format(self._sha256)\n        self.zip = ZipEntry.parse(io.BytesIO(self.__raw), True)\n    else:\n        self.zip = ZipEntry.parse(filename, False)\n        self.__raw = self.zip.zip.getvalue()\n\n    if testzip:\n        logger.info(\n            \"Testing zip file integrity, this might take a while...\"\n        )\n        # Test the zipfile for integrity before continuing.\n        # This process might be slow, as the whole file is read.\n        # Therefore it is possible to enable it as a separate feature.\n        #\n        # A short benchmark showed, that testing the zip takes about 10 times longer!\n        # e.g. normal zip loading (skip_analysis=True) takes about 0.01s, where\n        # testzip takes 0.1s!\n        test_zip = zipfile.ZipFile(io.BytesIO(self.__raw), mode=\"r\")\n        ret = test_zip.testzip()\n        if ret is not None:\n            # we could print the filename here, but there are zip which are so broken\n            # That the filename is either very very long or does not make any sense.\n            # Thus we do not do it, the user might find out by using other tools.\n            raise BrokenAPKError(\n                \"The APK is probably broken: testzip returned an error.\"\n            )\n\n    if not skip_analysis:\n        self._apk_analysis()\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.__setstate__","title":"<code>__setstate__(state)</code>","text":"<p>Load a pickled APK Object and restore the state</p> <p>We load the zip file back by reading __raw from the Object.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <p>pickled state</p> required Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def __setstate__(self, state):\n    \"\"\"\n    Load a pickled APK Object and restore the state\n\n    We load the zip file back by reading __raw from the Object.\n\n    :param state: pickled state\n    \"\"\"\n    self.__dict__ = state\n\n    self.zip = zipfile.ZipFile(io.BytesIO(self.get_raw()), mode=\"r\")\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.canonical_name","title":"<code>canonical_name(name, android=False)</code>","text":"<pre><code> * Method is dual-licensed under the Apache License 2.0 and GPLv3+.\n * The original author has granted permission to use this code snippet under the\n * Apache License 2.0 for inclusion in this project.\n * https://github.com/obfusk/x509_canonical_name.py/blob/master/x509_canonical_name.py\n</code></pre> <p>Returns canonical representation of <code>asn1crypto.x509.Name</code> as str (with raw control characters in places those are not stripped by normalisation).</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def canonical_name(self, name: asn1crypto.x509.Name, android: bool = False) -&gt; str:\n    \"\"\"\n    ```\n     * Method is dual-licensed under the Apache License 2.0 and GPLv3+.\n     * The original author has granted permission to use this code snippet under the\n     * Apache License 2.0 for inclusion in this project.\n     * https://github.com/obfusk/x509_canonical_name.py/blob/master/x509_canonical_name.py\n    ```\n\n    Returns canonical representation of `asn1crypto.x509.Name` as str (with raw control characters\n    in places those are not stripped by normalisation).\n    \"\"\"\n    # return \",\".join(\"+\".join(f\"{t}:{v}\" for _, t, v in avas) for avas in self.comparison_name(name))\n    return \",\".join(\n        \"+\".join(f\"{t}={v}\" for t, v in avas)\n        for avas in self.comparison_name(name, android=android)\n    )\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.comparison_name","title":"<code>comparison_name(name, *, android=False)</code>","text":"<pre><code> * Method is dual-licensed under the Apache License 2.0 and GPLv3+.\n * The original author has granted permission to use this code snippet under the\n * Apache License 2.0 for inclusion in this project.\n * https://github.com/obfusk/x509_canonical_name.py/blob/master/x509_canonical_name.py\n</code></pre> <p>Canonical representation of x509.Name as nested list.</p> <p>Returns a list of RDNs which are a list of AVAs which are a (type, value) tuple, where type is the standard name or dotted OID, and value is the normalised string representation of the value.</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def comparison_name(\n    self, name: x509.Name, *, android: bool = False\n) -&gt; List[List[Tuple[str, str]]]:\n    \"\"\"\n    ```\n     * Method is dual-licensed under the Apache License 2.0 and GPLv3+.\n     * The original author has granted permission to use this code snippet under the\n     * Apache License 2.0 for inclusion in this project.\n     * https://github.com/obfusk/x509_canonical_name.py/blob/master/x509_canonical_name.py\n    ```\n\n    Canonical representation of x509.Name as nested list.\n\n    Returns a list of RDNs which are a list of AVAs which are a (type, value)\n    tuple, where type is the standard name or dotted OID, and value is the\n    normalised string representation of the value.\n    \"\"\"\n\n    return [\n        [(t, nv) for _, t, nv, _ in avas]\n        for avas in self.x509_ordered_name(name, android=android)\n    ]\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.find_certificate","title":"<code>find_certificate(signed_data_certificates, signer_info)</code>","text":"<p>From the bag of certs, obtain the certificate referenced by the <code>asn1crypto.cms.SignerInfo</code>.</p> <p>Parameters:</p> Name Type Description Default <code>signed_data_certificates</code> <code>CertificateSet</code> <p>List of certificates in the SignedData.</p> required <code>signer_info</code> <code>SignerInfo</code> <p><code>SignerInfo</code> object containing the issuer and serial number reference.</p> required <p>Returns:</p> Type Description <code>Union[Certificate, None]</code> <p>The matching certificate if found, otherwise None.</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def find_certificate(\n    self,\n    signed_data_certificates: asn1crypto.cms.CertificateSet,\n    signer_info: asn1crypto.cms.SignerInfo) -&gt; Union[asn1crypto.x509.Certificate, None]:\n    \"\"\"\n    From the bag of certs, obtain the certificate referenced by the `asn1crypto.cms.SignerInfo`.\n\n    :param signed_data_certificates: List of certificates in the SignedData.\n    :param signer_info: `SignerInfo` object containing the issuer and serial number reference.\n\n    :returns: The matching certificate if found, otherwise None.\n    \"\"\"\n    matching_certificate = None\n    issuer_and_serial_number = signer_info['sid']\n    issuer_str = self.canonical_name(\n        issuer_and_serial_number.chosen['issuer']\n    )\n    serial_number = issuer_and_serial_number.native['serial_number']\n\n    # # Create a x509.Name object for the issuer in the SignerInfo\n    # issuer_name = x509.Name.build(issuer)\n    # issuer_str = self.canonical_name(issuer_name)\n\n    for cert in signed_data_certificates:\n        if cert.name == 'certificate':\n            cert_issuer = self.canonical_name(\n                cert.chosen['tbs_certificate']['issuer']\n            )\n            cert_serial_number = cert.native['tbs_certificate'][\n                'serial_number'\n            ]\n\n            # Compare the canonical string representations of the issuers and the serial numbers\n            if (\n                cert_issuer == issuer_str\n                and cert_serial_number == serial_number\n            ):\n                matching_certificate = cert\n                break\n\n    return matching_certificate\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.find_tags","title":"<code>find_tags(tag_name, **attribute_filter)</code>","text":"<p>Return a list of all the matched tags in all available xml</p> <p>Parameters:</p> Name Type Description Default <code>tag_name</code> <code>str</code> <p>specify the tag name</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>the matched tags</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def find_tags(self, tag_name: str, **attribute_filter) -&gt; list[str]:\n    \"\"\"\n    Return a list of all the matched tags in all available xml\n\n    :param tag_name: specify the tag name\n\n    :returns: the matched tags\n    \"\"\"\n    all_tags = [\n        self.find_tags_from_xml(i, tag_name, **attribute_filter)\n        for i in self.xml\n    ]\n    return [tag for tag_list in all_tags for tag in tag_list]\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.find_tags_from_xml","title":"<code>find_tags_from_xml(xml_name, tag_name, **attribute_filter)</code>","text":"<p>Return a list of all the matched tags in a specific xml</p> <p>Parameters:</p> Name Type Description Default <code>xml_name</code> <code>str</code> <p>specify from which xml to pick the tag from</p> required <code>tag_name</code> <code>str</code> <p>specify the tag name</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>the matched tags</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def find_tags_from_xml(\n    self, xml_name: str, tag_name: str, **attribute_filter\n) -&gt; list[str]:\n    \"\"\"\n    Return a list of all the matched tags in a specific xml\n\n    :param str xml_name: specify from which xml to pick the tag from\n    :param str tag_name: specify the tag name\n\n    :returns: the matched tags\n    \"\"\"\n    xml = self.xml[xml_name]\n    if xml is None:\n        return []\n    if xml.tag == tag_name:\n        if self.is_tag_matched(xml.tag, **attribute_filter):\n            return [xml]\n        return []\n    tags = set()\n    tags.update(xml.findall(\".//\" + tag_name))\n\n    # https://github.com/androguard/androguard/pull/1053\n    # permission declared using tag &lt;android:uses-permission...\n    tags.update(xml.findall(\".//\" + NS_ANDROID + tag_name))\n    return [\n        tag for tag in tags if self.is_tag_matched(tag, **attribute_filter)\n    ]\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_activities","title":"<code>get_activities()</code>","text":"<p>Return the <code>android:name</code> attribute of all activities</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>the list of <code>android:name</code> attribute of all activities</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_activities(self) -&gt; list[str]:\n    \"\"\"\n    Return the `android:name` attribute of all activities\n\n    :returns: the list of `android:name` attribute of all activities\n    \"\"\"\n    return list(self.get_all_attribute_value(\"activity\", \"name\"))\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_activity_aliases","title":"<code>get_activity_aliases()</code>","text":"<p>Return the <code>android:name</code> and <code>android:targetActivity</code> attribute of all activity aliases.</p> <p>Returns:</p> Type Description <code>list[dict[str, str]]</code> <p>the list of <code>android:name</code> and <code>android:targetActivity</code> attribute of all activitiy aliases</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_activity_aliases(self) -&gt; list[dict[str, str]]:\n    \"\"\"\n    Return the `android:name` and `android:targetActivity` attribute of all activity aliases.\n\n    :returns: the list of `android:name` and `android:targetActivity` attribute of all activitiy aliases\n    \"\"\"\n    ali = []\n    for alias in self.find_tags('activity-alias'):\n        activity_alias = {}\n        for attribute in ['name', 'targetActivity']:\n            value = alias.get(attribute) or alias.get(self._ns(attribute))\n            if not value:\n                continue\n            activity_alias[attribute] = self._format_value(value)\n        if activity_alias:\n            ali.append(activity_alias)\n    return ali\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_all_attribute_value","title":"<code>get_all_attribute_value(tag_name, attribute, format_value=True, **attribute_filter)</code>","text":"<p>Yields all the attribute values in xml files which match with the tag name and the specific attribute</p> <p>Parameters:</p> Name Type Description Default <code>tag_name</code> <code>str</code> <p>specify the tag name</p> required <code>attribute</code> <code>str</code> <p>specify the attribute</p> required <code>format_value</code> <code>bool</code> <p>specify if the value needs to be formatted with packagename</p> <code>True</code> <p>Returns:</p> Type Description <code>Iterator[str]</code> <p>the attribute values</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_all_attribute_value(\n    self,\n    tag_name: str,\n    attribute: str,\n    format_value: bool = True,\n    **attribute_filter,\n) -&gt; Iterator[str]:\n    \"\"\"\n    Yields all the attribute values in xml files which match with the tag name and the specific attribute\n\n    :param str tag_name: specify the tag name\n    :param str attribute: specify the attribute\n    :param bool format_value: specify if the value needs to be formatted with packagename\n\n    :returns: the attribute values\n    \"\"\"\n    tags = self.find_tags(tag_name, **attribute_filter)\n    for tag in tags:\n        value = tag.get(self._ns(attribute)) or tag.get(attribute)\n        if value is not None:\n            if format_value:\n                yield self._format_value(value)\n            else:\n                yield value\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_all_dex","title":"<code>get_all_dex()</code>","text":"<p>Return the raw bytes data of all classes dex files</p> <p>Returns:</p> Type Description <code>Iterator[bytes]</code> <p>the raw bytes data of all classes dex files</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_all_dex(self) -&gt; Iterator[bytes]:\n    \"\"\"\n    Return the raw bytes data of all classes dex files\n\n    :returns: the raw bytes data of all classes dex files\n    \"\"\"\n    for dex_name in self.get_dex_names():\n        yield self.get_file(dex_name)\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_android_manifest_axml","title":"<code>get_android_manifest_axml()</code>","text":"<p>Return the AXMLPrinter object which corresponds to the <code>AndroidManifest.xml</code> file</p> <p>Returns:</p> Type Description <code>Union[AXMLPrinter, None]</code> <p>the <code>AXMLPrinter</code> object</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_android_manifest_axml(self) -&gt; Union[AXMLPrinter, None]:\n    \"\"\"\n    Return the [AXMLPrinter][androguard.core.axml.AXMLPrinter] object which corresponds to the `AndroidManifest.xml` file\n\n    :returns: the `AXMLPrinter` object\n    \"\"\"\n    try:\n        return self.axml[\"AndroidManifest.xml\"]\n    except KeyError:\n        return None\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_android_manifest_xml","title":"<code>get_android_manifest_xml()</code>","text":"<p>Return the parsed xml object which corresponds to the <code>AndroidManifest.xml</code> file</p> <p>Returns:</p> Type Description <code>Union[Element, None]</code> <p>the parsed xml object</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_android_manifest_xml(self) -&gt; Union[lxml.etree.Element, None]:\n    \"\"\"\n    Return the parsed xml object which corresponds to the `AndroidManifest.xml` file\n\n    :returns: the parsed xml object\n    \"\"\"\n    try:\n        return self.xml[\"AndroidManifest.xml\"]\n    except KeyError:\n        return None\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_android_resources","title":"<code>get_android_resources()</code>","text":"<p>Return the ARSCParser object which corresponds to the <code>resources.arsc</code> file</p> <p>Returns:</p> Type Description <code>Union[ARSCParser, None]</code> <p>the <code>ARSCParser</code> object</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_android_resources(self) -&gt; Union[ARSCParser, None]:\n    \"\"\"\n    Return the [ARSCParser][androguard.core.axml.ARSCParser] object which corresponds to the `resources.arsc` file\n\n    :returns: the `ARSCParser` object\n    \"\"\"\n    try:\n        return self.arsc[\"resources.arsc\"]\n    except KeyError:\n        if \"resources.arsc\" not in self.zip.namelist():\n            # There is a rare case, that no resource file is supplied.\n            # Maybe it was added manually, thus we check here\n            return None\n        self.arsc[\"resources.arsc\"] = ARSCParser(\n            self.zip.read(\"resources.arsc\")\n        )\n        return self.arsc[\"resources.arsc\"]\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_androidversion_code","title":"<code>get_androidversion_code()</code>","text":"<p>Return the android version code</p> <p>This information is read from the <code>AndroidManifest.xml</code></p> <p>Returns:</p> Type Description <code>str</code> <p>the android version code</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_androidversion_code(self) -&gt; str:\n    \"\"\"\n    Return the android version code\n\n    This information is read from the `AndroidManifest.xml`\n\n    :returns: the android version code\n    \"\"\"\n    return self.androidversion[\"Code\"]\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_androidversion_name","title":"<code>get_androidversion_name()</code>","text":"<p>Return the android version name</p> <p>This information is read from the <code>AndroidManifest.xml</code></p> <p>Returns:</p> Type Description <code>str</code> <p>the android version name</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_androidversion_name(self) -&gt; str:\n    \"\"\"\n    Return the android version name\n\n    This information is read from the `AndroidManifest.xml`\n\n    :returns: the android version name\n    \"\"\"\n    return self.androidversion[\"Name\"]\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_app_icon","title":"<code>get_app_icon(max_dpi=65536)</code>","text":"<p>Return the first icon file name, which density is not greater than max_dpi, unless exact icon resolution is set in the manifest, in which case return the exact file.</p> <p>This information is read from the <code>AndroidManifest.xml</code></p> <p>From https://developer.android.com/guide/practices/screens_support.html and https://developer.android.com/ndk/reference/group___configuration.html</p> <ul> <li>DEFAULT                             0dpi</li> <li>ldpi (low)                        120dpi</li> <li>mdpi (medium)                     160dpi</li> <li>TV                                213dpi</li> <li>hdpi (high)                       240dpi</li> <li>xhdpi (extra-high)                320dpi</li> <li>xxhdpi (extra-extra-high)         480dpi</li> <li>xxxhdpi (extra-extra-extra-high)  640dpi</li> <li>anydpi                          65534dpi (0xFFFE)</li> <li>nodpi                           65535dpi (0xFFFF)</li> </ul> <p>There is a difference between nodpi and anydpi: nodpi will be used if no other density is specified. Or the density does not match. nodpi is the fallback for everything else. If there is a resource that matches the DPI, this is used. anydpi is also valid for all densities but in this case, anydpi will overrule all other files! Therefore anydpi is usually used with vector graphics and with constraints on the API level. For example adaptive icons are usually marked as anydpi.</p> <p>When it comes now to selecting an icon, there is the following flow:</p> <ol> <li>is there an anydpi icon?</li> <li>is there an icon for the dpi of the device?</li> <li>is there a nodpi icon?</li> <li>(only on very old devices) is there a icon with dpi 0 (the default)</li> </ol> <p>For more information read here: https://stackoverflow.com/a/34370735/446140</p> <p>Returns:</p> Type Description <code>Union[str, None]</code> <p>the first icon file name, or None if no resources or app icon exists.</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_app_icon(self, max_dpi: int = 65536) -&gt; Union[str, None]:\n    \"\"\"\n    Return the first icon file name, which density is not greater than max_dpi,\n    unless exact icon resolution is set in the manifest, in which case\n    return the exact file.\n\n    This information is read from the `AndroidManifest.xml`\n\n    From &lt;https://developer.android.com/guide/practices/screens_support.html&gt;\n    and &lt;https://developer.android.com/ndk/reference/group___configuration.html&gt;\n\n    * DEFAULT                             0dpi\n    * ldpi (low)                        120dpi\n    * mdpi (medium)                     160dpi\n    * TV                                213dpi\n    * hdpi (high)                       240dpi\n    * xhdpi (extra-high)                320dpi\n    * xxhdpi (extra-extra-high)         480dpi\n    * xxxhdpi (extra-extra-extra-high)  640dpi\n    * anydpi                          65534dpi (0xFFFE)\n    * nodpi                           65535dpi (0xFFFF)\n\n    There is a difference between nodpi and anydpi:\n    nodpi will be used if no other density is specified. Or the density does not match.\n    nodpi is the fallback for everything else. If there is a resource that matches the DPI,\n    this is used.\n    anydpi is also valid for all densities but in this case, anydpi will overrule all other files!\n    Therefore anydpi is usually used with vector graphics and with constraints on the API level.\n    For example adaptive icons are usually marked as anydpi.\n\n    When it comes now to selecting an icon, there is the following flow:\n\n    1. is there an anydpi icon?\n    2. is there an icon for the dpi of the device?\n    3. is there a nodpi icon?\n    4. (only on very old devices) is there a icon with dpi 0 (the default)\n\n    For more information read here: &lt;https://stackoverflow.com/a/34370735/446140&gt;\n\n    :returns: the first icon file name, or None if no resources or app icon exists.\n    \"\"\"\n    main_activity_name = self.get_main_activity()\n\n    app_icon = self.get_attribute_value(\n        'activity', 'icon', name=main_activity_name\n    )\n\n    if not app_icon:\n        app_icon = self.get_attribute_value('application', 'icon')\n\n    res_parser = self.get_android_resources()\n    if not res_parser:\n        # Can not do anything below this point to resolve...\n        return None\n\n    if not app_icon:\n        res_id = res_parser.get_res_id_by_key(\n            self.package, 'mipmap', 'ic_launcher'\n        )\n        if res_id:\n            app_icon = \"@%x\" % res_id\n\n    if not app_icon:\n        res_id = res_parser.get_res_id_by_key(\n            self.package, 'drawable', 'ic_launcher'\n        )\n        if res_id:\n            app_icon = \"@%x\" % res_id\n\n    if not app_icon:\n        # If the icon can not be found, return now\n        return None\n\n    if app_icon.startswith(\"@\"):\n        app_icon_id = app_icon[1:]\n        app_icon_id = app_icon_id.split(':')[-1]\n        res_id = int(app_icon_id, 16)\n        candidates = res_parser.get_resolved_res_configs(res_id)\n\n        app_icon = None\n        current_dpi = -1\n\n        try:\n            for config, file_name in candidates:\n                dpi = config.get_density()\n                if current_dpi &lt; dpi &lt;= max_dpi:\n                    app_icon = file_name\n                    current_dpi = dpi\n        except Exception as e:\n            logger.warning(\"Exception selecting app icon: %s\" % e)\n\n    return app_icon\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_app_name","title":"<code>get_app_name(locale=None)</code>","text":"<p>Return the appname of the APK This name is read from the <code>AndroidManifest.xml</code> using the application <code>android:label</code>. If no label exists, the <code>android:label</code> of the main activity is used.</p> <p>If there is also no main activity label, an empty string is returned.</p> <p>Returns:</p> Type Description <code>str</code> <p>the appname of the APK</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_app_name(self, locale=None) -&gt; str:\n    \"\"\"\n    Return the appname of the APK\n    This name is read from the `AndroidManifest.xml`\n    using the application `android:label`.\n    If no label exists, the `android:label` of the main activity is used.\n\n    If there is also no main activity label, an empty string is returned.\n\n    :returns: the appname of the APK\n    \"\"\"\n\n    app_name = self.get_attribute_value('application', 'label')\n    if app_name is None:\n        activities = self.get_main_activities()\n        main_activity_name = None\n        if len(activities) &gt; 0:\n            main_activity_name = activities.pop()\n\n        # FIXME: would need to use _format_value inside get_attribute_value for each returned name!\n        # For example, as the activity name might be foobar.foo.bar but inside the activity it is only .bar\n        app_name = self.get_attribute_value(\n            'activity', 'label', name=main_activity_name\n        )\n\n    if app_name is None:\n        # No App name set\n        # TODO return packagename instead?\n        logger.warning(\n            \"It looks like that no app name is set for the main activity!\"\n        )\n        return \"\"\n\n    if app_name.startswith(\"@\"):\n        res_parser = self.get_android_resources()\n        if not res_parser:\n            # TODO: What should be the correct return value here?\n            return app_name\n\n        res_id, package = res_parser.parse_id(app_name)\n\n        # If the package name is the same as the APK package,\n        # we should be able to resolve the ID.\n        if package and package != self.get_package():\n            if package == 'android':\n                # TODO: we can not resolve this, as we lack framework-res.apk\n                # one exception would be when parsing framework-res.apk directly.\n                logger.warning(\n                    \"Resource ID with android package name encountered! \"\n                    \"Will not resolve, framework-res.apk would be required.\"\n                )\n                return app_name\n            else:\n                # TODO should look this up, might be in the resources\n                logger.warning(\n                    \"Resource ID with Package name '{}' encountered! Will not resolve\".format(\n                        package\n                    )\n                )\n                return app_name\n\n        try:\n            config = (\n                ARSCResTableConfig(None, locale=locale)\n                if locale\n                else ARSCResTableConfig.default_config()\n            )\n            app_name = res_parser.get_resolved_res_configs(res_id, config)[\n                0\n            ][1]\n        except Exception as e:\n            logger.warning(\"Exception selecting app name: %s\" % e)\n    return app_name\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_attribute_value","title":"<code>get_attribute_value(tag_name, attribute, format_value=False, **attribute_filter)</code>","text":"<p>Return the attribute value in xml files which matches the tag name and the specific attribute</p> <p>Parameters:</p> Name Type Description Default <code>tag_name</code> <code>str</code> <p>specify the tag name</p> required <code>attribute</code> <code>str</code> <p>specify the attribute</p> required <code>format_value</code> <code>bool</code> <p>specify if the value needs to be formatted with packagename</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>the attribute value</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_attribute_value(\n    self,\n    tag_name: str,\n    attribute: str,\n    format_value: bool = False,\n    **attribute_filter,\n) -&gt; str:\n    \"\"\"\n    Return the attribute value in xml files which matches the tag name and the specific attribute\n\n    :param str tag_name: specify the tag name\n    :param str attribute: specify the attribute\n    :param bool format_value: specify if the value needs to be formatted with packagename\n\n    :returns: the attribute value\n    \"\"\"\n\n    for value in self.get_all_attribute_value(\n        tag_name, attribute, format_value, **attribute_filter\n    ):\n        if value is not None:\n            return value\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_certificate","title":"<code>get_certificate(filename)</code>","text":"<p>Return a X.509 certificate object by giving the name in the apk file</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>filename of the signature file in the APK</p> required <p>Returns:</p> Type Description <code>Union[Certificate, None]</code> <p>the certificate object</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_certificate(self, filename: str) -&gt; Union[asn1crypto.x509.Certificate, None]:\n    \"\"\"\n    Return a X.509 certificate object by giving the name in the apk file\n\n    :param filename: filename of the signature file in the APK\n    :returns: the certificate object\n    \"\"\"\n    cert = self.get_certificate_der(filename)\n    if cert:\n        certificate = asn1crypto.x509.Certificate.load(cert)\n    else:\n        certificate = None\n    return certificate\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_certificate_der","title":"<code>get_certificate_der(filename, max_sdk_version=None)</code>","text":"<p>Return the DER coded X.509 certificate from the signature file. If minSdkVersion is prior to Android N only the first SignerInfo is used. If signed attributes are present, they are taken into account Note that unsupported critical extensions and key usage are not verified! V1SchemeVerifier.java</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Signature filename in APK</p> required <code>max_sdk_version</code> <code>int</code> <p>An optional integer parameter for the max sdk version</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[bytes, None]</code> <p>DER coded X.509 certificate as binary or None</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_certificate_der(\n    self, filename: str, max_sdk_version: int = None\n) -&gt; Union[bytes, None]:\n    \"\"\"\n    Return the DER coded X.509 certificate from the signature file.\n    If minSdkVersion is prior to Android N only the first SignerInfo is used.\n    If signed attributes are present, they are taken into account\n    Note that unsupported critical extensions and key usage are not verified!\n    [V1SchemeVerifier.java](https://android.googlesource.com/platform/tools/apksig/+/refs/tags/platform-tools-34.0.5/src/main/java/com/android/apksig/internal/apk/v1/V1SchemeVerifier.java#668)\n\n    :param filename: Signature filename in APK\n    :param max_sdk_version: An optional integer parameter for the max sdk version\n    :returns: DER coded X.509 certificate as binary or None\n    \"\"\"\n\n    # Get the signature\n    pkcs7message = self.get_file(filename)\n    # Get the .SF\n    sf_filename = os.path.splitext(filename)[0] + '.SF'\n    sf_object = self.get_file(sf_filename)\n    # Load the signature\n    signed_data = cms.ContentInfo.load(pkcs7message)\n    # Locate the SignerInfo structure\n    signer_infos = signed_data['content']['signer_infos']\n    if not signer_infos:\n        logger.error(\n            'No signer information found in the PKCS7 object. The APK may not be properly signed.'\n        )\n        return None\n\n    # Prior to Android N, Android attempts to verify only the first SignerInfo. From N onwards, Android attempts\n    # to verify all SignerInfos and then picks the first verified SignerInfo.\n    min_sdk_version = self.get_min_sdk_version()\n    if (\n        min_sdk_version is None or int(min_sdk_version) &lt; 24\n    ):  # AndroidSdkVersion.N\n        logger.info(\n            f\"minSdkVersion: {min_sdk_version} is less than 24. Getting the first signerInfo only!\"\n        )\n        unverified_signer_infos_to_try = [signer_infos[0]]\n    else:\n        unverified_signer_infos_to_try = signer_infos\n\n    # Extract certificates from the PKCS7 object\n    certificates = signed_data['content']['certificates']\n    return_certificate = None\n    list_certificates_verified = []\n    for signer_info in unverified_signer_infos_to_try:\n        try:\n            matching_certificate_verified = (\n                self.verify_signer_info_against_sig_file(\n                    signed_data,\n                    certificates,\n                    signer_info,\n                    sf_object,\n                    max_sdk_version,\n                )\n            )\n        except (ValueError, TypeError, OSError, InvalidSignature) as e:\n            logger.error(\n                f\"The following exception was raised while verifying the certificate: {e}\"\n            )\n            return (\n                None  # the validation stops due to the exception raised!\n            )\n        if matching_certificate_verified is not None:\n            list_certificates_verified.append(\n                matching_certificate_verified\n            )\n    if not list_certificates_verified:\n        logger.error(\n            f\"minSdkVersion: {min_sdk_version}, # of SignerInfos: {len(unverified_signer_infos_to_try)}. None Verified!\"\n        )\n    else:\n        return_certificate = list_certificates_verified[0]\n    return return_certificate\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_certificates","title":"<code>get_certificates()</code>","text":"<p>Return a list of unique <code>asn1crypto.x509.Certificate</code> which are found in v1, v2 and v3 signing Note that we simply extract all certificates regardless of the signer. Therefore this is just a list of all certificates found in all signers. Exception is v1, for which the certificate returned is verified.</p> <p>Returns:</p> Type Description <code>list[Certificate]</code> <p>a list of the found <code>asn1crypto.x509.Certificate</code></p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_certificates(self) -&gt; list[asn1crypto.x509.Certificate]:\n    \"\"\"\n    Return a list of unique `asn1crypto.x509.Certificate` which are found\n    in v1, v2 and v3 signing\n    Note that we simply extract all certificates regardless of the signer.\n    Therefore this is just a list of all certificates found in all signers.\n    Exception is v1, for which the certificate returned is verified.\n\n    :returns: a list of the found `asn1crypto.x509.Certificate`\n    \"\"\"\n    fps = []\n    certs = []\n    for x in (\n        self.get_certificates_v1()\n        + self.get_certificates_v2()\n        + self.get_certificates_v3()\n    ):\n        if x.sha256 not in fps:\n            fps.append(x.sha256)\n            certs.append(x)\n    return certs\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_certificates_der_v2","title":"<code>get_certificates_der_v2()</code>","text":"<p>Return a list of DER coded X.509 certificates from the v3 signature block</p> <p>Returns:</p> Type Description <code>list[bytes]</code> <p>the list of public key bytes</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_certificates_der_v2(self) -&gt; list[bytes]:\n    \"\"\"\n    Return a list of DER coded X.509 certificates from the v3 signature block\n\n    :returns: the list of public key bytes\n    \"\"\"\n\n    if self._v2_signing_data == None:\n        self.parse_v2_signing_block()\n\n    certs = []\n    for signed_data in [\n        signer.signed_data for signer in self._v2_signing_data\n    ]:\n        for cert in signed_data.certificates:\n            certs.append(cert)\n\n    return certs\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_certificates_der_v3","title":"<code>get_certificates_der_v3()</code>","text":"<p>Return a list of DER coded X.509 certificates from the v3 signature block</p> <p>Returns:</p> Type Description <code>list[bytes]</code> <p>the list of public key bytes</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_certificates_der_v3(self) -&gt; list[bytes]:\n    \"\"\"\n    Return a list of DER coded X.509 certificates from the v3 signature block\n\n    :returns: the list of public key bytes\n    \"\"\"\n\n    if self._v3_signing_data == None:\n        self.parse_v3_signing_block()\n\n    certs = []\n    for signed_data in [\n        signer.signed_data for signer in self._v3_signing_data\n    ]:\n        for cert in signed_data.certificates:\n            certs.append(cert)\n\n    return certs\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_certificates_v1","title":"<code>get_certificates_v1()</code>","text":"<p>Return a list of verified <code>asn1crypto.x509.Certificate</code> which are found in the META-INF folder (v1 signing).</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_certificates_v1(self) -&gt; list[Union[x509.Certificate, None]]:\n    \"\"\"\n    Return a list of verified `asn1crypto.x509.Certificate` which are found\n    in the META-INF folder (v1 signing).\n    \"\"\"\n    certs = []\n    for x in self.get_signature_names():\n        cc = self.get_certificate_der(x)\n        if cc is not None:\n            certs.append(x509.Certificate.load(cc))\n    return certs\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_certificates_v2","title":"<code>get_certificates_v2()</code>","text":"<p>Return a list of <code>asn1crypto.x509.Certificate</code> which are found in the v2 signing block. Note that we simply extract all certificates regardless of the signer. Therefore this is just a list of all certificates found in all signers.</p> <p>Returns:</p> Type Description <code>list[Certificate]</code> <p>a list of the found <code>asn1crypto.x509.Certificate</code></p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_certificates_v2(self) -&gt; list[asn1crypto.x509.Certificate]:\n    \"\"\"\n    Return a list of `asn1crypto.x509.Certificate` which are found\n    in the v2 signing block.\n    Note that we simply extract all certificates regardless of the signer.\n    Therefore this is just a list of all certificates found in all signers.\n\n    :returns: a list of the found `asn1crypto.x509.Certificate`\n    \"\"\"\n    return [\n        x509.Certificate.load(cert)\n        for cert in self.get_certificates_der_v2()\n    ]\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_certificates_v3","title":"<code>get_certificates_v3()</code>","text":"<p>Return a list of <code>asn1crypto.x509.Certificate</code> which are found in the v3 signing block. Note that we simply extract all certificates regardless of the signer. Therefore this is just a list of all certificates found in all signers.</p> <p>Returns:</p> Type Description <code>list[Certificate]</code> <p>a list of the found <code>asn1crypto.x509.Certificate</code></p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_certificates_v3(self) -&gt; list[asn1crypto.x509.Certificate]:\n    \"\"\"\n    Return a list of `asn1crypto.x509.Certificate` which are found\n    in the v3 signing block.\n    Note that we simply extract all certificates regardless of the signer.\n    Therefore this is just a list of all certificates found in all signers.\n\n    :returns: a list of the found `asn1crypto.x509.Certificate`\n    \"\"\"\n    return [\n        x509.Certificate.load(cert)\n        for cert in self.get_certificates_der_v3()\n    ]\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_declared_permissions","title":"<code>get_declared_permissions()</code>","text":"<p>Returns list of the declared permissions.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list of declared permissions</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_declared_permissions(self) -&gt; list[str]:\n    \"\"\"\n    Returns list of the declared permissions.\n\n    :returns: list of declared permissions\n    \"\"\"\n    return list(self.declared_permissions.keys())\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_declared_permissions_details","title":"<code>get_declared_permissions_details()</code>","text":"<p>Returns declared permissions with the details.</p> <p>Returns:</p> Type Description <code>dict[str, list[str]]</code> <p>declared permissions</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_declared_permissions_details(self) -&gt; dict[str, list[str]]:\n    \"\"\"\n    Returns declared permissions with the details.\n\n    :returns: declared permissions\n    \"\"\"\n    return self.declared_permissions\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_details_permissions","title":"<code>get_details_permissions()</code>","text":"<p>Return permissions with details.</p> <p>This can only return details about the permission, if the permission is defined in the AOSP.</p> <p>Returns:</p> Type Description <code>dict[str, list[str]]</code> <p>permissions with details: dict of <code>{permission: [protectionLevel, label, description]}</code></p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_details_permissions(self) -&gt; dict[str, list[str]]:\n    \"\"\"\n    Return permissions with details.\n\n    This can only return details about the permission, if the permission is\n    defined in the AOSP.\n\n    :returns: permissions with details: dict of `{permission: [protectionLevel, label, description]}`\n    \"\"\"\n    l = {}\n\n    for i in self.permissions:\n        if i in self.permission_module:\n            x = self.permission_module[i]\n            l[i] = [x[\"protectionLevel\"], x[\"label\"], x[\"description\"]]\n        elif i in self.declared_permissions:\n            protectionLevel_hex = self.declared_permissions[i][\n                \"protectionLevel\"\n            ]\n            protectionLevel = protection_flags_to_attributes[\n                protectionLevel_hex\n            ]\n            l[i] = [\n                protectionLevel,\n                \"Unknown permission from android reference\",\n                \"Unknown permission from android reference\",\n            ]\n        else:\n            # Is there a valid case not belonging to the above two?\n            logger.info(f\"Unknown permission {i}\")\n    return self._fill_deprecated_permissions(l)\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_dex","title":"<code>get_dex()</code>","text":"<p>Return the raw data of the classes dex file</p> <p>This will give you the data of the file called <code>classes.dex</code> inside the APK. If the APK has multiple DEX files, you need to use get_all_dex.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>the raw data of the classes dex file</p> <p>Raises:</p> Type Description <code>FileNotPresent</code> <p>if classes.dex is not found</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_dex(self) -&gt; bytes:\n    \"\"\"\n    Return the raw data of the classes dex file\n\n    This will give you the data of the file called `classes.dex`\n    inside the APK. If the APK has multiple DEX files, you need to use [get_all_dex][androguard.core.apk.APK.get_all_dex].\n\n    :raises FileNotPresent: if classes.dex is not found\n    :returns: the raw data of the classes dex file\n    \"\"\"\n    try:\n        return self.get_file(\"classes.dex\")\n    except FileNotPresent:\n        # TODO is this a good idea to return an empty string?\n        return b\"\"\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_dex_names","title":"<code>get_dex_names()</code>","text":"<p>Return the names of all DEX files found in the APK. This method only accounts for \"offical\" dex files, i.e. all files in the root directory of the APK named <code>classes.dex</code> or <code>classes[0-9]+.dex</code></p> <p>Returns:</p> Type Description <code>list[str]</code> <p>the names of all DEX files found in the APK</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_dex_names(self) -&gt; list[str]:\n    \"\"\"\n    Return the names of all DEX files found in the APK.\n    This method only accounts for \"offical\" dex files, i.e. all files\n    in the root directory of the APK named `classes.dex` or `classes[0-9]+.dex`\n\n    :returns: the names of all DEX files found in the APK\n    \"\"\"\n    dexre = re.compile(r\"^classes(\\d*).dex$\")\n    return filter(lambda x: dexre.match(x), self.get_files())\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_effective_target_sdk_version","title":"<code>get_effective_target_sdk_version()</code>","text":"<p>Return the effective <code>targetSdkVersion</code>, always returns int &gt; 0.</p> <p>If the <code>targetSdkVersion</code> is not set, it defaults to 1.  This is set based on defaults as defined in: https://developer.android.com/guide/topics/manifest/uses-sdk-element.html</p> <p>Returns:</p> Type Description <code>int</code> <p>the effective <code>targetSdkVersion</code></p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_effective_target_sdk_version(self) -&gt; int:\n    \"\"\"\n    Return the effective `targetSdkVersion`, always returns int &gt; 0.\n\n    If the `targetSdkVersion` is not set, it defaults to 1.  This is\n    set based on defaults as defined in:\n    &lt;https://developer.android.com/guide/topics/manifest/uses-sdk-element.html&gt;\n\n    :returns: the effective `targetSdkVersion`\n    \"\"\"\n    target_sdk_version = self.get_target_sdk_version()\n    if not target_sdk_version:\n        target_sdk_version = self.get_min_sdk_version()\n    try:\n        return int(target_sdk_version)\n    except (ValueError, TypeError):\n        return 1\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_features","title":"<code>get_features()</code>","text":"<p>Return a list of all <code>android:names</code> found for the tag <code>uses-feature</code> in the <code>AndroidManifest.xml</code></p> <p>Returns:</p> Type Description <code>list[str]</code> <p>the <code>android:names</code> found</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_features(self) -&gt; list[str]:\n    \"\"\"\n    Return a list of all `android:names` found for the tag `uses-feature`\n    in the `AndroidManifest.xml`\n\n    :returns: the `android:names` found\n    \"\"\"\n    return list(self.get_all_attribute_value(\"uses-feature\", \"name\"))\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_file","title":"<code>get_file(filename)</code>","text":"<p>Return the raw data of the specified filename inside the APK</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>the filename to get</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>bytes of the specified filename</p> <p>Raises:</p> Type Description <code>FileNotPresent</code> <p>if filename not found inside the apk</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_file(self, filename: str) -&gt; bytes:\n    \"\"\"\n    Return the raw data of the specified filename\n    inside the APK\n\n    :param filename: the filename to get\n    :raises FileNotPresent: if filename not found inside the apk\n    :returns: bytes of the specified filename\n    \"\"\"\n    try:\n        return self.zip.read(filename)\n    except KeyError:\n        raise FileNotPresent(filename)\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_filename","title":"<code>get_filename()</code>","text":"<p>Return the filename of the APK</p> <p>Returns:</p> Type Description <code>str</code> <p>filename</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_filename(self) -&gt; str:\n    \"\"\"\n    Return the filename of the APK\n\n    :returns: filename\n    \"\"\"\n    return self.filename\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_files","title":"<code>get_files()</code>","text":"<p>Return the file names inside the APK.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>a list of filename strings inside the APK</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_files(self) -&gt; list[str]:\n    \"\"\"\n    Return the file names inside the APK.\n\n    :returns: a list of filename strings inside the APK\n    \"\"\"\n    return self.zip.namelist()\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_files_crc32","title":"<code>get_files_crc32()</code>","text":"<p>Calculates and returns a dictionary of filenames and CRC32</p> <p>Returns:</p> Type Description <code>dict[str, int]</code> <p>dict of filename: CRC32</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_files_crc32(self) -&gt; dict[str, int]:\n    \"\"\"\n    Calculates and returns a dictionary of filenames and CRC32\n\n    :returns: dict of filename: CRC32\n    \"\"\"\n    if self.files_crc32 == {}:\n        for i in self.get_files():\n            self._get_crc32(i)\n\n    return self.files_crc32\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_files_information","title":"<code>get_files_information()</code>","text":"<p>Return the files inside the APK with their associated types and crc32</p> <p>Returns:</p> Type Description <code>Iterator[tuple[str, str, int]]</code> <p>the files inside the APK with their associated types and crc32</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_files_information(self) -&gt; Iterator[tuple[str, str, int]]:\n    \"\"\"\n    Return the files inside the APK with their associated types and crc32\n\n    :returns: the files inside the APK with their associated types and crc32\n    \"\"\"\n    for k in self.get_files():\n        yield k, self.get_files_types()[k], self.get_files_crc32()[k]\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_files_types","title":"<code>get_files_types()</code>","text":"<p>Return the files inside the APK with their associated types (by using python-magic)</p> <p>At the same time, the CRC32 are calculated for the files.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>the files inside the APK with their associated types</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_files_types(self) -&gt; dict[str, str]:\n    \"\"\"\n    Return the files inside the APK with their associated types (by using [python-magic](https://pypi.org/project/python-magic/))\n\n    At the same time, the CRC32 are calculated for the files.\n\n    :returns: the files inside the APK with their associated types\n    \"\"\"\n    if self._files == {}:\n        # Generate File Types / CRC List\n        for i in self.get_files():\n            buffer = self._get_crc32(i)\n            self._files[i] = self._get_file_magic_name(buffer)\n\n    return self._files\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_intent_filters","title":"<code>get_intent_filters(itemtype, name)</code>","text":"<p>Find intent filters for a given item and name.</p> <p>Intent filter are attached to activities, services or receivers. You can search for the intent filters of such items and get a dictionary of all attached actions and intent categories.</p> <p>Parameters:</p> Name Type Description Default <code>itemtype</code> <code>str</code> <p>the type of parent item to look for, e.g. <code>activity</code>,  <code>service</code> or <code>receiver</code></p> required <code>name</code> <code>str</code> <p>the <code>android:name</code> of the parent item, e.g. activity name</p> required <p>Returns:</p> Type Description <code>dict[str, list[str]]</code> <p>a dictionary with the keys <code>action</code> and <code>category</code> containing the <code>android:name</code> of those items</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_intent_filters(\n    self, itemtype: str, name: str\n) -&gt; dict[str, list[str]]:\n    \"\"\"\n    Find intent filters for a given item and name.\n\n    Intent filter are attached to activities, services or receivers.\n    You can search for the intent filters of such items and get a dictionary of all\n    attached actions and intent categories.\n\n    :param itemtype: the type of parent item to look for, e.g. `activity`,  `service` or `receiver`\n    :param name: the `android:name` of the parent item, e.g. activity name\n    :returns: a dictionary with the keys `action` and `category` containing the `android:name` of those items\n    \"\"\"\n    attributes = {\n        \"action\": [\"name\"],\n        \"category\": [\"name\"],\n        \"data\": [\n            'scheme',\n            'host',\n            'port',\n            'path',\n            'pathPattern',\n            'pathPrefix',\n            'mimeType',\n        ],\n    }\n\n    d = {}\n    for element in attributes.keys():\n        d[element] = []\n\n    for i in self.xml:\n        # TODO: this can probably be solved using a single xpath\n        for item in self.xml[i].findall(\".//\" + itemtype):\n            if self._format_value(item.get(self._ns(\"name\"))) == name:\n                for sitem in item.findall(\".//intent-filter\"):\n                    for element in d.keys():\n                        for ssitem in sitem.findall(element):\n                            if element == 'data':  # multiple attributes\n                                values = {}\n                                for attribute in attributes[element]:\n                                    value = ssitem.get(self._ns(attribute))\n                                    if value:\n                                        if value.startswith('@'):\n                                            value = self.get_res_value(\n                                                value\n                                            )\n                                        values[attribute] = value\n\n                                if values:\n                                    d[element].append(values)\n                            else:\n                                for attribute in attributes[element]:\n                                    value = ssitem.get(self._ns(attribute))\n                                    if value.startswith('@'):\n                                        value = self.get_res_value(value)\n\n                                    if value not in d[element]:\n                                        d[element].append(value)\n\n    for element in list(d.keys()):\n        if not d[element]:\n            del d[element]\n\n    return d\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_libraries","title":"<code>get_libraries()</code>","text":"<p>Return the <code>android:name</code> attributes for libraries</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>the <code>android:name</code> attributes</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_libraries(self) -&gt; list[str]:\n    \"\"\"\n    Return the `android:name` attributes for libraries\n\n    :returns: the `android:name` attributes\n    \"\"\"\n    return list(self.get_all_attribute_value(\"uses-library\", \"name\"))\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_main_activities","title":"<code>get_main_activities()</code>","text":"<p>Return names of the main activities</p> <p>These values are read from the <code>AndroidManifest.xml</code></p> <p>Returns:</p> Type Description <code>set[str]</code> <p>names of the main activities</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_main_activities(self) -&gt; set[str]:\n    \"\"\"\n    Return names of the main activities\n\n    These values are read from the `AndroidManifest.xml`\n\n    :returns: names of the main activities\n    \"\"\"\n    x = set()\n    y = set()\n\n    for i in self.xml:\n        if self.xml[i] is None:\n            continue\n        activities_and_aliases = self.xml[i].findall(\n            \".//activity\"\n        ) + self.xml[i].findall(\".//activity-alias\")\n\n        for item in activities_and_aliases:\n            # Some applications have more than one MAIN activity.\n            # For example: paid and free content\n            activityEnabled = item.get(self._ns(\"enabled\"))\n            if activityEnabled == \"false\":\n                continue\n\n            for sitem in item.findall(\".//action\"):\n                val = sitem.get(self._ns(\"name\"))\n                if val == \"android.intent.action.MAIN\":\n                    activity = item.get(self._ns(\"name\"))\n                    if activity is not None:\n                        x.add(item.get(self._ns(\"name\")))\n                    else:\n                        logger.warning('Main activity without name')\n\n            for sitem in item.findall(\".//category\"):\n                val = sitem.get(self._ns(\"name\"))\n                if val == \"android.intent.category.LAUNCHER\":\n                    activity = item.get(self._ns(\"name\"))\n                    if activity is not None:\n                        y.add(item.get(self._ns(\"name\")))\n                    else:\n                        logger.warning('Launcher activity without name')\n\n    return x.intersection(y)\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_main_activity","title":"<code>get_main_activity()</code>","text":"<p>Return the name of the main activity</p> <p>This value is read from the <code>AndroidManifest.xml</code></p> <p>Returns:</p> Type Description <code>Union[str, None]</code> <p>the name of the main activity</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_main_activity(self) -&gt; Union[str, None]:\n    \"\"\"\n    Return the name of the main activity\n\n    This value is read from the `AndroidManifest.xml`\n\n    :returns: the name of the main activity\n    \"\"\"\n    activities = self.get_main_activities()\n    if len(activities) == 1:\n        return self._format_value(activities.pop())\n    elif len(activities) &gt; 1:\n        main_activities = {self._format_value(ma) for ma in activities}\n        # sorted is necessary\n        # 9fc7d3e8225f6b377f9181a92c551814317b77e1aa0df4c6d508d24b18f0f633\n        good_main_activities = sorted(\n            main_activities.intersection(self.get_activities())\n        )\n        if good_main_activities:\n            return good_main_activities[0]\n        return sorted(main_activities)[0]\n    return None\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_max_sdk_version","title":"<code>get_max_sdk_version()</code>","text":"<p>Return the <code>android:maxSdkVersion</code> attribute</p> <p>Returns:</p> Type Description <code>str</code> <p>the <code>android:maxSdkVersion</code> attribute</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_max_sdk_version(self) -&gt; str:\n    \"\"\"\n    Return the `android:maxSdkVersion` attribute\n\n    :returns: the `android:maxSdkVersion` attribute\n    \"\"\"\n    return self.get_attribute_value(\"uses-sdk\", \"maxSdkVersion\")\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_min_sdk_version","title":"<code>get_min_sdk_version()</code>","text":"<p>Return the <code>android:minSdkVersion</code> attribute</p> <p>Returns:</p> Type Description <code>str</code> <p>the <code>android:minSdkVersion</code> attribute</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_min_sdk_version(self) -&gt; str:\n    \"\"\"\n      Return the `android:minSdkVersion` attribute\n\n      :returns: the `android:minSdkVersion` attribute\n    \"\"\"\n    return self.get_attribute_value(\"uses-sdk\", \"minSdkVersion\")\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_package","title":"<code>get_package()</code>","text":"<p>Return the name of the package</p> <p>This information is read from the <code>AndroidManifest.xml</code></p> <p>Returns:</p> Type Description <code>str</code> <p>the name of the package</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_package(self) -&gt; str:\n    \"\"\"\n    Return the name of the package\n\n    This information is read from the `AndroidManifest.xml`\n\n    :returns: the name of the package\n    \"\"\"\n    return self.package\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_permissions","title":"<code>get_permissions()</code>","text":"<p>Return permissions names declared in the <code>AndroidManifest.xml</code>.</p> <p>It is possible that permissions are returned multiple times, as this function does not filter the permissions, i.e. it shows you exactly what was defined in the <code>AndroidManifest.xml</code>.</p> <p>Implied permissions, which are granted automatically, are not returned here. Use get_uses_implied_permission_list if you need a list of implied permissions.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of permissions as strings</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_permissions(self) -&gt; list[str]:\n    \"\"\"\n    Return permissions names declared in the `AndroidManifest.xml`.\n\n    It is possible that permissions are returned multiple times,\n    as this function does not filter the permissions, i.e. it shows you\n    exactly what was defined in the `AndroidManifest.xml`.\n\n    Implied permissions, which are granted automatically, are not returned\n    here. Use [get_uses_implied_permission_list][androguard.core.apk.APK.get_uses_implied_permission_list] if you need a list\n    of implied permissions.\n\n    :returns: A list of permissions as strings\n    \"\"\"\n    return self.permissions\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_providers","title":"<code>get_providers()</code>","text":"<p>Return the <code>android:name</code> attribute of all providers</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>the list of the <code>android:name</code> attribute of all providers</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_providers(self) -&gt; list[str]:\n    \"\"\"\n    Return the `android:name` attribute of all providers\n\n    :returns: the list of the `android:name` attribute of all providers\n    \"\"\"\n    return list(self.get_all_attribute_value(\"provider\", \"name\"))\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_public_keys_der_v2","title":"<code>get_public_keys_der_v2()</code>","text":"<p>Return a list of DER coded X.509 public keys from the v3 signature block</p> <p>Returns:</p> Type Description <code>list[bytes]</code> <p>the list of public key bytes</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_public_keys_der_v2(self) -&gt; list[bytes]:\n    \"\"\"\n    Return a list of DER coded X.509 public keys from the v3 signature block\n\n    :returns: the list of public key bytes\n    \"\"\"\n\n    if self._v2_signing_data == None:\n        self.parse_v2_signing_block()\n\n    public_keys = []\n\n    for signer in self._v2_signing_data:\n        public_keys.append(signer.public_key)\n\n    return public_keys\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_public_keys_der_v3","title":"<code>get_public_keys_der_v3()</code>","text":"<p>Return a list of DER coded X.509 public keys from the v3 signature block</p> <p>Returns:</p> Type Description <code>list[bytes]</code> <p>the list of public key bytes</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_public_keys_der_v3(self) -&gt; list[bytes]:\n    \"\"\"\n    Return a list of DER coded X.509 public keys from the v3 signature block\n\n    :returns: the list of public key bytes\n    \"\"\"\n\n    if self._v3_signing_data == None:\n        self.parse_v3_signing_block()\n\n    public_keys = []\n\n    for signer in self._v3_signing_data:\n        public_keys.append(signer.public_key)\n\n    return public_keys\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_public_keys_v2","title":"<code>get_public_keys_v2()</code>","text":"<p>Return a list of <code>asn1crypto.keys.PublicKeyInfo</code> which are found in the v2 signing block.</p> <p>Returns:</p> Type Description <code>list[PublicKeyInfo]</code> <p>a list of the found <code>asn1crypto.keys.PublicKeyInfo</code></p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_public_keys_v2(self) -&gt; list[asn1crypto.keys.PublicKeyInfo]:\n    \"\"\"\n    Return a list of `asn1crypto.keys.PublicKeyInfo` which are found\n    in the v2 signing block.\n\n    :returns: a list of the found `asn1crypto.keys.PublicKeyInfo`\n    \"\"\"\n    return [\n        keys.PublicKeyInfo.load(pkey)\n        for pkey in self.get_public_keys_der_v2()\n    ]\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_public_keys_v3","title":"<code>get_public_keys_v3()</code>","text":"<p>Return a list of <code>asn1crypto.keys.PublicKeyInfo</code> which are found in the v3 signing block.</p> <p>Returns:</p> Type Description <code>list[PublicKeyInfo]</code> <p>a list of the found <code>asn1crypto.keys.PublicKeyInfo</code></p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_public_keys_v3(self) -&gt; list[asn1crypto.keys.PublicKeyInfo]:\n    \"\"\"\n    Return a list of `asn1crypto.keys.PublicKeyInfo` which are found\n    in the v3 signing block.\n\n    :returns: a list of the found `asn1crypto.keys.PublicKeyInfo`\n    \"\"\"\n    return [\n        keys.PublicKeyInfo.load(pkey)\n        for pkey in self.get_public_keys_der_v3()\n    ]\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_raw","title":"<code>get_raw()</code>","text":"<p>Return raw bytes of the APK</p> <p>Returns:</p> Type Description <code>bytes</code> <p>bytes of the APK</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_raw(self) -&gt; bytes:\n    \"\"\"\n    Return raw bytes of the APK\n\n    :returns: bytes of the APK\n    \"\"\"\n\n    if self.__raw:\n        return self.__raw\n    else:\n        with open(self.filename, 'rb') as f:\n            self.__raw = bytearray(f.read())\n        return self.__raw\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_receivers","title":"<code>get_receivers()</code>","text":"<p>Return the <code>android:name</code> attribute of all receivers</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>the list of the <code>android:name</code> attribute of all receivers</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_receivers(self) -&gt; list[str]:\n    \"\"\"\n    Return the `android:name` attribute of all receivers\n\n    :returns: the list of the `android:name` attribute of all receivers\n    \"\"\"\n    return list(self.get_all_attribute_value(\"receiver\", \"name\"))\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_requested_aosp_permissions","title":"<code>get_requested_aosp_permissions()</code>","text":"<p>Returns requested permissions declared within AOSP project.</p> <p>This includes several other permissions as well, which are in the platform apps.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>requested permissions</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_requested_aosp_permissions(self) -&gt; list[str]:\n    \"\"\"\n    Returns requested permissions declared within AOSP project.\n\n    This includes several other permissions as well, which are in the platform apps.\n\n    :returns: requested permissions\n    \"\"\"\n    aosp_permissions = []\n    all_permissions = self.get_permissions()\n    for perm in all_permissions:\n        if perm in list(self.permission_module.keys()):\n            aosp_permissions.append(perm)\n    return aosp_permissions\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_requested_aosp_permissions_details","title":"<code>get_requested_aosp_permissions_details()</code>","text":"<p>Returns requested aosp permissions with details.</p> <p>Returns:</p> Type Description <code>dict[str, list[str]]</code> <p>requested aosp permissions</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_requested_aosp_permissions_details(self) -&gt; dict[str, list[str]]:\n    \"\"\"\n    Returns requested aosp permissions with details.\n\n    :returns: requested aosp permissions\n    \"\"\"\n    l = {}\n    for i in self.permissions:\n        try:\n            l[i] = self.permission_module[i]\n        except KeyError:\n            # if we have not found permission do nothing\n            continue\n    return l\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_requested_third_party_permissions","title":"<code>get_requested_third_party_permissions()</code>","text":"<p>Returns list of requested permissions not declared within AOSP project.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>requested permissions</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_requested_third_party_permissions(self) -&gt; list[str]:\n    \"\"\"\n    Returns list of requested permissions not declared within AOSP project.\n\n    :returns: requested permissions\n    \"\"\"\n    third_party_permissions = []\n    all_permissions = self.get_permissions()\n    for perm in all_permissions:\n        if perm not in list(self.permission_module.keys()):\n            third_party_permissions.append(perm)\n    return third_party_permissions\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_res_value","title":"<code>get_res_value(name)</code>","text":"<p>Return the literal value with a resource id</p> <p>Returns:</p> Type Description <code>str</code> <p>the literal value with a resource id</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_res_value(self, name: str) -&gt; str:\n    \"\"\"\n    Return the literal value with a resource id\n\n    :returns: the literal value with a resource id\n    \"\"\"\n\n    res_parser = self.get_android_resources()\n    if not res_parser:\n        return name\n\n    res_id = res_parser.parse_id(name)[0]\n    try:\n        value = res_parser.get_resolved_res_configs(\n            res_id, ARSCResTableConfig.default_config()\n        )[0][1]\n    except Exception as e:\n        logger.warning(\"Exception get resolved resource id: %s\" % e)\n        return name\n\n    return value\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_services","title":"<code>get_services()</code>","text":"<p>Return the <code>android:name</code> attribute of all services</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>the list of the <code>android:name</code> attribute of all services</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_services(self) -&gt; list[str]:\n    \"\"\"\n    Return the `android:name` attribute of all services\n\n    :returns: the list of the `android:name` attribute of all services\n    \"\"\"\n    return list(self.get_all_attribute_value(\"service\", \"name\"))\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_signature","title":"<code>get_signature()</code>","text":"<p>Return the data of the first signature file found (v1 Signature / JAR Signature)</p> <p>Returns:</p> Type Description <code>Union[str, None]</code> <p>First signature name or None if not signed</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_signature(self) -&gt; Union[str, None]:\n    \"\"\"\n    Return the data of the first signature file found (v1 Signature / JAR\n    Signature)\n\n    :returns: First signature name or None if not signed\n    \"\"\"\n    if self.get_signatures():\n        return self.get_signatures()[0]\n    else:\n        return None\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_signature_name","title":"<code>get_signature_name()</code>","text":"<p>Return the name of the first signature file found.</p> <p>Returns:</p> Type Description <code>Union[str, None]</code> <p>the name of the first signature file, or <code>None</code> if not signed</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_signature_name(self) -&gt; Union[str, None]:\n    \"\"\"\n    Return the name of the first signature file found.\n\n    :returns: the name of the first signature file, or `None` if not signed\n    \"\"\"\n    if self.get_signature_names():\n        return self.get_signature_names()[0]\n    else:\n        # Unsigned APK\n        return None\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_signature_names","title":"<code>get_signature_names()</code>","text":"<p>Return a list of the signature file names (v1 Signature / JAR Signature)</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of filenames matching a Signature</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_signature_names(self) -&gt; list[str]:\n    \"\"\"\n    Return a list of the signature file names (v1 Signature / JAR\n    Signature)\n\n    :returns: List of filenames matching a Signature\n    \"\"\"\n    signature_expr = re.compile(r\"^(META-INF/)(.*)(\\.RSA|\\.EC|\\.DSA)$\")\n    signatures = []\n\n    for i in self.get_files():\n        if signature_expr.search(i):\n            if \"{}.SF\".format(i.rsplit(\".\", 1)[0]) in self.get_files():\n                signatures.append(i)\n            else:\n                logger.warning(\n                    \"v1 signature file {} missing .SF file - Partial signature!\".format(\n                        i\n                    )\n                )\n\n    return signatures\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_signatures","title":"<code>get_signatures()</code>","text":"<p>Return a list of the data of the signature files. Only v1 / JAR Signing.</p> <p>Returns:</p> Type Description <code>list[bytes]</code> <p>list of bytes</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_signatures(self) -&gt; list[bytes]:\n    \"\"\"\n    Return a list of the data of the signature files.\n    Only v1 / JAR Signing.\n\n    :returns: list of bytes\n    \"\"\"\n    signature_expr = re.compile(r\"^(META-INF/)(.*)(\\.RSA|\\.EC|\\.DSA)$\")\n    signature_datas = []\n\n    for i in self.get_files():\n        if signature_expr.search(i):\n            signature_datas.append(self.get_file(i))\n\n    return signature_datas\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_target_sdk_version","title":"<code>get_target_sdk_version()</code>","text":"<p>Return the <code>android:targetSdkVersion</code> attribute</p> <p>Returns:</p> Type Description <code>str</code> <p>the <code>android:targetSdkVersion</code> attribute</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_target_sdk_version(self) -&gt; str:\n    \"\"\"\n    Return the `android:targetSdkVersion` attribute\n\n    :returns: the `android:targetSdkVersion` attribute\n    \"\"\"\n    return self.get_attribute_value(\"uses-sdk\", \"targetSdkVersion\")\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_uses_implied_permission_list","title":"<code>get_uses_implied_permission_list()</code>","text":"<p>Return all permissions implied by the target SDK or other permissions.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list of all permissions implied by the target SDK or other permissions as strings</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_uses_implied_permission_list(self) -&gt; list[str]:\n    \"\"\"\n    Return all permissions implied by the target SDK or other permissions.\n\n    :returns: list of all permissions implied by the target SDK or other permissions as strings\n    \"\"\"\n    target_sdk_version = self.get_effective_target_sdk_version()\n\n    READ_CALL_LOG = 'android.permission.READ_CALL_LOG'\n    READ_CONTACTS = 'android.permission.READ_CONTACTS'\n    READ_EXTERNAL_STORAGE = 'android.permission.READ_EXTERNAL_STORAGE'\n    READ_PHONE_STATE = 'android.permission.READ_PHONE_STATE'\n    WRITE_CALL_LOG = 'android.permission.WRITE_CALL_LOG'\n    WRITE_CONTACTS = 'android.permission.WRITE_CONTACTS'\n    WRITE_EXTERNAL_STORAGE = 'android.permission.WRITE_EXTERNAL_STORAGE'\n\n    implied = []\n\n    implied_WRITE_EXTERNAL_STORAGE = False\n    if target_sdk_version &lt; 4:\n        if WRITE_EXTERNAL_STORAGE not in self.permissions:\n            implied.append([WRITE_EXTERNAL_STORAGE, None])\n            implied_WRITE_EXTERNAL_STORAGE = True\n        if READ_PHONE_STATE not in self.permissions:\n            implied.append([READ_PHONE_STATE, None])\n\n    if (\n        WRITE_EXTERNAL_STORAGE in self.permissions\n        or implied_WRITE_EXTERNAL_STORAGE\n    ) and READ_EXTERNAL_STORAGE not in self.permissions:\n        maxSdkVersion = None\n        for name, version in self.uses_permissions:\n            if name == WRITE_EXTERNAL_STORAGE:\n                maxSdkVersion = version\n                break\n        implied.append([READ_EXTERNAL_STORAGE, maxSdkVersion])\n\n    if target_sdk_version &lt; 16:\n        if (\n            READ_CONTACTS in self.permissions\n            and READ_CALL_LOG not in self.permissions\n        ):\n            implied.append([READ_CALL_LOG, None])\n        if (\n            WRITE_CONTACTS in self.permissions\n            and WRITE_CALL_LOG not in self.permissions\n        ):\n            implied.append([WRITE_CALL_LOG, None])\n\n    return implied\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.get_value_from_tag","title":"<code>get_value_from_tag(tag, attribute)</code>","text":"<p>Return the value of the android prefixed attribute in a specific tag.</p> <p>This function will always try to get the attribute with a <code>android:</code> prefix first, and will try to return the attribute without the prefix, if the attribute could not be found. This is useful for some broken <code>AndroidManifest.xml</code>, where no android namespace is set, but could also indicate malicious activity (i.e. wrongly repackaged files). A warning is printed if the attribute is found without a namespace prefix.</p> <p>If you require to get the exact result you need to query the tag directly:</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; from lxml.etree import Element\n&gt;&gt;&gt; tag = Element('bar', nsmap={'android': 'http://schemas.android.com/apk/res/android'})\n&gt;&gt;&gt; tag.set('{http://schemas.android.com/apk/res/android}foobar', 'barfoo')\n&gt;&gt;&gt; tag.set('name', 'baz')\n# Assume that `a` is some APK object\n&gt;&gt;&gt; a.get_value_from_tag(tag, 'name')\n'baz'\n&gt;&gt;&gt; tag.get('name')\n'baz'\n&gt;&gt;&gt; tag.get('foobar')\nNone\n&gt;&gt;&gt; a.get_value_from_tag(tag, 'foobar')\n'barfoo'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>lxml.etree.Element</code> <p>specify the tag element</p> required <code>attribute</code> <code>str</code> <p>specify the attribute name</p> required <p>Returns:</p> Type Description <code>Union[str, None]</code> <p>the attribute's value, or None if the attribute is not present</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_value_from_tag(\n    self, tag: Element, attribute: str\n) -&gt; Union[str, None]:\n    \"\"\"\n    Return the value of the android prefixed attribute in a specific tag.\n\n    This function will always try to get the attribute with a `android:` prefix first,\n    and will try to return the attribute without the prefix, if the attribute could not be found.\n    This is useful for some broken `AndroidManifest.xml`, where no android namespace is set,\n    but could also indicate malicious activity (i.e. wrongly repackaged files).\n    A warning is printed if the attribute is found without a namespace prefix.\n\n    If you require to get the exact result you need to query the tag directly:\n\n    Example:\n\n        &gt;&gt;&gt; from lxml.etree import Element\n        &gt;&gt;&gt; tag = Element('bar', nsmap={'android': 'http://schemas.android.com/apk/res/android'})\n        &gt;&gt;&gt; tag.set('{http://schemas.android.com/apk/res/android}foobar', 'barfoo')\n        &gt;&gt;&gt; tag.set('name', 'baz')\n        # Assume that `a` is some APK object\n        &gt;&gt;&gt; a.get_value_from_tag(tag, 'name')\n        'baz'\n        &gt;&gt;&gt; tag.get('name')\n        'baz'\n        &gt;&gt;&gt; tag.get('foobar')\n        None\n        &gt;&gt;&gt; a.get_value_from_tag(tag, 'foobar')\n        'barfoo'\n\n    :param lxml.etree.Element tag: specify the tag element\n    :param str attribute: specify the attribute name\n    :returns: the attribute's value, or None if the attribute is not present\n    \"\"\"\n\n    # TODO: figure out if both android:name and name tag exist which one to give preference:\n    # currently we give preference for the namespace one and fallback to the un-namespaced\n    value = tag.get(self._ns(attribute))\n    if value is None:\n        value = tag.get(attribute)\n\n        if value:\n            # If value is still None, the attribute could not be found, thus is not present\n            logger.warning(\n                \"Failed to get the attribute '{}' on tag '{}' with namespace. \"\n                \"But found the same attribute without namespace!\".format(\n                    attribute, tag.tag\n                )\n            )\n    return value\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.is_androidtv","title":"<code>is_androidtv()</code>","text":"<p>Checks if this application does not require a touchscreen, as this is the rule to get into the TV section of the Play Store See: https://developer.android.com/training/tv/start/start.html for more information.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if 'android.hardware.touchscreen' is not required, <code>False</code> otherwise</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def is_androidtv(self) -&gt; bool:\n    \"\"\"\n    Checks if this application does not require a touchscreen,\n    as this is the rule to get into the TV section of the Play Store\n    See: https://developer.android.com/training/tv/start/start.html for more information.\n\n    :returns: `True` if 'android.hardware.touchscreen' is not required, `False` otherwise\n    \"\"\"\n    return (\n        self.get_attribute_value(\n            'uses-feature',\n            'name',\n            required=\"false\",\n            name=\"android.hardware.touchscreen\",\n        )\n        == \"android.hardware.touchscreen\"\n    )\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.is_leanback","title":"<code>is_leanback()</code>","text":"<p>Checks if this application is build for TV (Leanback support) by checkin if it uses the feature 'android.software.leanback'</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if leanback feature is used, <code>False</code> otherwise</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def is_leanback(self) -&gt; bool:\n    \"\"\"\n    Checks if this application is build for TV (Leanback support)\n    by checkin if it uses the feature 'android.software.leanback'\n\n    :returns: `True` if leanback feature is used, `False` otherwise\n    \"\"\"\n    return 'android.software.leanback' in self.get_features()\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.is_multidex","title":"<code>is_multidex()</code>","text":"<p>Test if the APK has multiple DEX files</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if multiple dex found, otherwise False</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def is_multidex(self) -&gt; bool:\n    \"\"\"\n    Test if the APK has multiple DEX files\n\n    :returns: True if multiple dex found, otherwise False\n    \"\"\"\n    dexre = re.compile(r\"^classes(\\d+)?.dex$\")\n    return (\n        len(\n            [\n                instance\n                for instance in self.get_files()\n                if dexre.search(instance)\n            ]\n        )\n        &gt; 1\n    )\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.is_signed","title":"<code>is_signed()</code>","text":"<p>Returns true if any of v1, v2, or v3 signatures were found.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if any of v1, v2, or v3 signatures were found, else False</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def is_signed(self) -&gt; bool:\n    \"\"\"\n    Returns true if any of v1, v2, or v3 signatures were found.\n\n    :returns: True if any of v1, v2, or v3 signatures were found, else False\n    \"\"\"\n    return (\n        self.is_signed_v1() or self.is_signed_v2() or self.is_signed_v3()\n    )\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.is_signed_v1","title":"<code>is_signed_v1()</code>","text":"<p>Returns <code>True</code> if a v1 / JAR signature was found.</p> <p>Returning <code>True</code> does not mean that the file is properly signed! It just says that there is a signature file which needs to be validated.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if a v1 / JAR signature was found, else <code>False</code></p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def is_signed_v1(self) -&gt; bool:\n    \"\"\"\n    Returns `True` if a v1 / JAR signature was found.\n\n    Returning `True` does not mean that the file is properly signed!\n    It just says that there is a signature file which needs to be validated.\n\n    :returns: `True` if a v1 / JAR signature was found, else `False`\n    \"\"\"\n    return self.get_signature_name() is not None\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.is_signed_v2","title":"<code>is_signed_v2()</code>","text":"<p>Returns <code>True</code> of a v2 / APK signature was found.</p> <p>Returning <code>True</code> does not mean that the file is properly signed! It just says that there is a signature file which needs to be validated.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> of a v2 / APK signature was found, else <code>False</code></p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def is_signed_v2(self) -&gt; bool:\n    \"\"\"\n    Returns `True` of a v2 / APK signature was found.\n\n    Returning `True` does not mean that the file is properly signed!\n    It just says that there is a signature file which needs to be validated.\n\n    :returns: `True` of a v2 / APK signature was found, else `False`\n    \"\"\"\n    if self._is_signed_v2 is None:\n        self.parse_v2_v3_signature()\n\n    return self._is_signed_v2\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.is_signed_v3","title":"<code>is_signed_v3()</code>","text":"<p>Returns <code>True</code> of a v3 / APK signature was found.</p> <p>Returning <code>True</code> does not mean that the file is properly signed! It just says that there is a signature file which needs to be validated.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> of a v3 / APK signature was found, else <code>False</code></p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def is_signed_v3(self) -&gt; bool:\n    \"\"\"\n    Returns `True` of a v3 / APK signature was found.\n\n    Returning `True` does not mean that the file is properly signed!\n    It just says that there is a signature file which needs to be validated.\n\n    :returns: `True` of a v3 / APK signature was found, else `False`\n    \"\"\"\n    if self._is_signed_v3 is None:\n        self.parse_v2_v3_signature()\n\n    return self._is_signed_v3\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.is_tag_matched","title":"<code>is_tag_matched(tag, **attribute_filter)</code>","text":"<p>Return <code>True</code> if the attributes matches in attribute filter.</p> <p>An attribute filter is a dictionary containing: {attribute_name: value}. This function will return <code>True</code> if and only if all attributes have the same value. This function allows to set the dictionary via kwargs, thus you can filter like this:</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; a.is_tag_matched(tag, name=\"foobar\", other=\"barfoo\")\n</code></pre> <p>This function uses a fallback for attribute searching. It will by default use the namespace variant but fall back to the non-namespace variant. Thus specifiying <code>{\"name\": \"foobar\"}</code> will match on <code>&lt;bla name=\"foobar\" \\&gt;</code> as well as on <code>&lt;bla android:name=\"foobar\" \\&gt;</code>.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>Element</code> <p>specify the tag element</p> required <code>attribute_filter</code> <p>specify the attribute filter as dictionary</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the attributes matches in attribute filter, else <code>False</code></p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def is_tag_matched(self, tag: lxml.etree.Element, **attribute_filter) -&gt; bool:\n    r\"\"\"\n    Return `True` if the attributes matches in attribute filter.\n\n    An attribute filter is a dictionary containing: {attribute_name: value}.\n    This function will return `True` if and only if all attributes have the same value.\n    This function allows to set the dictionary via kwargs, thus you can filter like this:\n\n    Example:\n\n        &gt;&gt;&gt; a.is_tag_matched(tag, name=\"foobar\", other=\"barfoo\")\n\n    This function uses a fallback for attribute searching. It will by default use\n    the namespace variant but fall back to the non-namespace variant.\n    Thus specifiying `{\"name\": \"foobar\"}` will match on `&lt;bla name=\"foobar\" \\&gt;`\n    as well as on `&lt;bla android:name=\"foobar\" \\&gt;`.\n\n    :param tag: specify the tag element\n    :param attribute_filter: specify the attribute filter as dictionary\n\n    :returns: `True` if the attributes matches in attribute filter, else `False`\n    \"\"\"\n    if len(attribute_filter) &lt;= 0:\n        return True\n    for attr, value in attribute_filter.items():\n        _value = self.get_value_from_tag(tag, attr)\n        if _value != value:\n            return False\n    return True\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.is_valid_APK","title":"<code>is_valid_APK()</code>","text":"<p>Return <code>True</code> if the APK is valid, <code>False</code> otherwise. An APK is seen as valid, if the <code>AndroidManifest.xml</code> could be successful parsed. This does not mean that the APK has a valid signature nor that the APK can be installed on an Android system.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the APK is valid, <code>False</code> otherwise.</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def is_valid_APK(self) -&gt; bool:\n    \"\"\"\n    Return `True` if the APK is valid, `False` otherwise.\n    An APK is seen as valid, if the `AndroidManifest.xml` could be successful parsed.\n    This does not mean that the APK has a valid signature nor that the APK\n    can be installed on an Android system.\n\n    :returns: `True` if the APK is valid, `False` otherwise.\n    \"\"\"\n    return self.valid_apk\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.is_wearable","title":"<code>is_wearable()</code>","text":"<p>Checks if this application is build for wearables by checking if it uses the feature 'android.hardware.type.watch' See: https://developer.android.com/training/wearables/apps/creating.html for more information.</p> <p>Not every app is setting this feature (not even the example Google provides), so it might be wise to not 100% rely on this feature.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if wearable, <code>False</code> otherwise</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def is_wearable(self) -&gt; bool:\n    \"\"\"\n    Checks if this application is build for wearables by\n    checking if it uses the feature 'android.hardware.type.watch'\n    See: https://developer.android.com/training/wearables/apps/creating.html for more information.\n\n    Not every app is setting this feature (not even the example Google provides),\n    so it might be wise to not 100% rely on this feature.\n\n    :returns: `True` if wearable, `False` otherwise\n    \"\"\"\n    return 'android.hardware.type.watch' in self.get_features()\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.new_zip","title":"<code>new_zip(filename, deleted_files=None, new_files={})</code>","text":"<p>Create a new zip file</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>the output filename of the zip</p> required <code>deleted_files</code> <code>Union[str, None]</code> <p>a regex pattern to remove specific file, or <code>None</code></p> <code>None</code> <code>new_files</code> <code>dict</code> <p>a dictionnary of new files (key:filename, value:content of the file)</p> <code>{}</code> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def new_zip(\n    self,\n    filename: str,\n    deleted_files: Union[str, None] = None,\n    new_files: dict = {},\n) -&gt; None:\n    \"\"\"\n    Create a new zip file\n\n    :param filename: the output filename of the zip\n    :param deleted_files: a regex pattern to remove specific file, or `None`\n    :param new_files: a dictionnary of new files (key:filename, value:content of the file)\n    \"\"\"\n    zout = zipfile.ZipFile(filename, 'w')\n\n    for item in self.zip.infolist():\n        # Block one: deleted_files, or deleted_files and new_files\n        if deleted_files is not None:\n            if re.match(deleted_files, item) is None:\n                # if the regex of deleted_files doesn't match the filename\n                if new_files is not False:\n                    if item in new_files:\n                        # and if the filename is in new_files\n                        zout.writestr(item, new_files[item])\n                        continue\n                # Otherwise, write the original file.\n                buffer = self.zip.read(item)\n                zout.writestr(item, buffer)\n        # Block two: deleted_files is None, new_files is not empty\n        elif new_files is not False:\n            if item in new_files:\n                zout.writestr(item, new_files[item])\n            else:\n                buffer = self.zip.read(item)\n                zout.writestr(item, buffer)\n        # Block three: deleted_files is None, new_files is empty.\n        # Just write out the default zip\n        else:\n            buffer = self.zip.read(item)\n            zout.writestr(item, buffer)\n    zout.close()\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.parse_signatures_or_digests","title":"<code>parse_signatures_or_digests(digest_bytes)</code>","text":"<p>Parse digests</p> <p>Parameters:</p> Name Type Description Default <code>digest_bytes</code> <code>bytes</code> <p>the digests bytes</p> required <p>Returns:</p> Type Description <code>list[tuple[int, bytes]]</code> <p>a list of tuple where the first element is the <code>algorithm_id</code> and the second is the digest bytes</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def parse_signatures_or_digests(\n    self, digest_bytes: bytes\n) -&gt; list[tuple[int, bytes]]:\n    \"\"\"Parse digests\n\n    :param digest_bytes: the digests bytes\n    :returns: a list of tuple where the first element is the `algorithm_id` and the second is the digest bytes\n    \"\"\"\n\n    if not len(digest_bytes):\n        return []\n\n    digests = []\n    block = io.BytesIO(digest_bytes)\n\n    data_len = self.read_uint32_le(block)\n    while block.tell() &lt; data_len:\n\n        algorithm_id = self.read_uint32_le(block)\n        digest_len = self.read_uint32_le(block)\n        digest = block.read(digest_len)\n\n        digests.append((algorithm_id, digest))\n\n    return digests\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.parse_v2_signing_block","title":"<code>parse_v2_signing_block()</code>","text":"<p>Parse the V2 signing block and extract all features</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def parse_v2_signing_block(self) -&gt; None:\n    \"\"\"\n    Parse the V2 signing block and extract all features\n    \"\"\"\n\n    self._v2_signing_data = []\n\n    # calling is_signed_v2 should also load the signature\n    if not self.is_signed_v2():\n        return\n\n    block_bytes = self._v2_blocks[self._APK_SIG_KEY_V2_SIGNATURE]\n    block = io.BytesIO(block_bytes)\n    view = block.getvalue()\n\n    # V2 signature Block data format:\n    #\n    # * signer:\n    #    * signed data:\n    #        * digests:\n    #            * signature algorithm ID (uint32)\n    #            * digest (length-prefixed)\n    #        * certificates\n    #        * additional attributes\n    #    * signatures\n    #    * publickey\n\n    size_sequence = self.read_uint32_le(block)\n    if size_sequence + 4 != len(block_bytes):\n        raise BrokenAPKError(\n            \"size of sequence and blocksize does not match\"\n        )\n\n    while block.tell() &lt; len(block_bytes):\n        off_signer = block.tell()\n        size_signer = self.read_uint32_le(block)\n\n        # read whole signed data, since we might to parse\n        # content within the signed data, and mess up offset\n        len_signed_data = self.read_uint32_le(block)\n        signed_data_bytes = block.read(len_signed_data)\n        signed_data = io.BytesIO(signed_data_bytes)\n\n        # Digests\n        len_digests = self.read_uint32_le(signed_data)\n        raw_digests = signed_data.read(len_digests)\n        digests = self.parse_signatures_or_digests(raw_digests)\n\n        # Certs\n        certs = []\n        len_certs = self.read_uint32_le(signed_data)\n        start_certs = signed_data.tell()\n        while signed_data.tell() &lt; start_certs + len_certs:\n            len_cert = self.read_uint32_le(signed_data)\n            cert = signed_data.read(len_cert)\n            certs.append(cert)\n\n        # Additional attributes\n        len_attr = self.read_uint32_le(signed_data)\n        attributes = signed_data.read(len_attr)\n\n        signed_data_object = APKV2SignedData()\n        signed_data_object._bytes = signed_data_bytes\n        signed_data_object.digests = digests\n        signed_data_object.certificates = certs\n        signed_data_object.additional_attributes = attributes\n\n        # Signatures\n        len_sigs = self.read_uint32_le(block)\n        raw_sigs = block.read(len_sigs)\n        sigs = self.parse_signatures_or_digests(raw_sigs)\n\n        # PublicKey\n        len_publickey = self.read_uint32_le(block)\n        publickey = block.read(len_publickey)\n\n        signer = APKV2Signer()\n        signer._bytes = view[off_signer : off_signer + size_signer]\n        signer.signed_data = signed_data_object\n        signer.signatures = sigs\n        signer.public_key = publickey\n\n        self._v2_signing_data.append(signer)\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.parse_v3_signing_block","title":"<code>parse_v3_signing_block()</code>","text":"<p>Parse the V2 signing block and extract all features</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def parse_v3_signing_block(self) -&gt; None:\n    \"\"\"\n    Parse the V2 signing block and extract all features\n    \"\"\"\n\n    self._v3_signing_data = []\n\n    # calling is_signed_v3 should also load the signature, if any\n    if not self.is_signed_v3():\n        return\n\n    block_bytes = self._v2_blocks[self._APK_SIG_KEY_V3_SIGNATURE]\n    block = io.BytesIO(block_bytes)\n    view = block.getvalue()\n\n    # V3 signature Block data format:\n    #\n    # * signer:\n    #    * signed data:\n    #        * digests:\n    #            * signature algorithm ID (uint32)\n    #            * digest (length-prefixed)\n    #        * certificates\n    #        * minSDK\n    #        * maxSDK\n    #        * additional attributes\n    #    * minSDK\n    #    * maxSDK\n    #    * signatures\n    #    * publickey\n    size_sequence = self.read_uint32_le(block)\n    if size_sequence + 4 != len(block_bytes):\n        raise BrokenAPKError(\n            \"size of sequence and blocksize does not match\"\n        )\n\n    while block.tell() &lt; len(block_bytes):\n        off_signer = block.tell()\n        size_signer = self.read_uint32_le(block)\n\n        # read whole signed data, since we might to parse\n        # content within the signed data, and mess up offset\n        len_signed_data = self.read_uint32_le(block)\n        signed_data_bytes = block.read(len_signed_data)\n        signed_data = io.BytesIO(signed_data_bytes)\n\n        # Digests\n        len_digests = self.read_uint32_le(signed_data)\n        raw_digests = signed_data.read(len_digests)\n        digests = self.parse_signatures_or_digests(raw_digests)\n\n        # Certs\n        certs = []\n        len_certs = self.read_uint32_le(signed_data)\n        start_certs = signed_data.tell()\n        while signed_data.tell() &lt; start_certs + len_certs:\n\n            len_cert = self.read_uint32_le(signed_data)\n            cert = signed_data.read(len_cert)\n            certs.append(cert)\n\n        # versions\n        signed_data_min_sdk = self.read_uint32_le(signed_data)\n        signed_data_max_sdk = self.read_uint32_le(signed_data)\n\n        # Addional attributes\n        len_attr = self.read_uint32_le(signed_data)\n        attr = signed_data.read(len_attr)\n\n        signed_data_object = APKV3SignedData()\n        signed_data_object._bytes = signed_data_bytes\n        signed_data_object.digests = digests\n        signed_data_object.certificates = certs\n        signed_data_object.additional_attributes = attr\n        signed_data_object.minSDK = signed_data_min_sdk\n        signed_data_object.maxSDK = signed_data_max_sdk\n\n        # versions (should be the same as signed data's versions)\n        signer_min_sdk = self.read_uint32_le(block)\n        signer_max_sdk = self.read_uint32_le(block)\n\n        # Signatures\n        len_sigs = self.read_uint32_le(block)\n        raw_sigs = block.read(len_sigs)\n        sigs = self.parse_signatures_or_digests(raw_sigs)\n\n        # PublicKey\n        len_publickey = self.read_uint32_le(block)\n        publickey = block.read(len_publickey)\n\n        signer = APKV3Signer()\n        signer._bytes = view[off_signer : off_signer + size_signer]\n        signer.signed_data = signed_data_object\n        signer.signatures = sigs\n        signer.public_key = publickey\n        signer.minSDK = signer_min_sdk\n        signer.maxSDK = signer_max_sdk\n\n        self._v3_signing_data.append(signer)\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.read_uint32_le","title":"<code>read_uint32_le(io_stream)</code>","text":"<p>read a <code>uint32_le</code> from <code>io_stream</code></p> <p>Parameters:</p> Name Type Description Default <code>io_stream</code> <p>the stream to get a <code>uint32_le</code> from</p> required <p>Returns:</p> Type Description <code>int</code> <p>the <code>uint32_le</code> value</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def read_uint32_le(self, io_stream) -&gt; int:\n    \"\"\"read a `uint32_le` from `io_stream`\n\n    :param io_stream: the stream to get a `uint32_le` from\n    :return: the `uint32_le` value\n    \"\"\"\n    (value,) = unpack('&lt;I', io_stream.read(4))\n    return value\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APK.x509_ordered_name","title":"<code>x509_ordered_name(name, *, android=False)</code>  <code>staticmethod</code>","text":"<pre><code> * Method is dual-licensed under the Apache License 2.0 and GPLv3+.\n * The original author has granted permission to use this code snippet under the\n * Apache License 2.0 for inclusion in this project.\n * https://github.com/obfusk/x509_canonical_name.py/blob/master/x509_canonical_name.py\n</code></pre> <p>Representation of <code>x509.Name</code> as nested list, in canonical ordering (but also including non-canonical pre-normalised string values).</p> <p>Returns a list of RDNs which are a list of AVAs which are a (oid, type, normalised_value, esc_value) tuple, where oid is 0 for standard names and 1 for dotted OIDs, type is the standard name or dotted OID, normalised_value is the normalised string representation of the value, and esc_value is the string value before normalisation (but after escaping).</p> <p>NB: control characters are not escaped, only characters in \",+&lt;&gt;;\"\\\" and \"#\" at the start (before \"whitespace\" trimming) are.</p> <p>X500Principal.getName AVA.java RDN.java (472) RDN.java (481)</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>@staticmethod\ndef x509_ordered_name(\n    name: x509.Name,\n    *,  # type: ignore[no-any-unimported]\n    android: bool = False,\n) -&gt; List[List[Tuple[int, str, str, str]]]:\n    \"\"\"\n    ```\n     * Method is dual-licensed under the Apache License 2.0 and GPLv3+.\n     * The original author has granted permission to use this code snippet under the\n     * Apache License 2.0 for inclusion in this project.\n     * https://github.com/obfusk/x509_canonical_name.py/blob/master/x509_canonical_name.py\n    ```\n\n    Representation of `x509.Name` as nested list, in canonical ordering (but also\n    including non-canonical pre-normalised string values).\n\n    Returns a list of RDNs which are a list of AVAs which are a (oid, type,\n    normalised_value, esc_value) tuple, where oid is 0 for standard names and 1\n    for dotted OIDs, type is the standard name or dotted OID, normalised_value\n    is the normalised string representation of the value, and esc_value is the\n    string value before normalisation (but after escaping).\n\n    NB: control characters are not escaped, only characters in \",+&lt;&gt;;\\\"\\\\\" and\n    \"#\" at the start (before \"whitespace\" trimming) are.\n\n    [X500Principal.getName](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/javax/security/auth/x500/X500Principal.html#getName(java.lang.String))\n    [AVA.java](https://github.com/openjdk/jdk/blob/jdk-21%2B35/src/java.base/share/classes/sun/security/x509/AVA.java#L805)\n    [RDN.java (472)](https://github.com/openjdk/jdk/blob/jdk-21%2B35/src/java.base/share/classes/sun/security/x509/RDN.java#L472)\n    [RDN.java (481)](https://android.googlesource.com/platform/libcore/+/refs/heads/android14-release/ojluni/src/main/java/sun/security/x509/RDN.java#481)\n    \"\"\"\n\n    def key(\n        ava: Tuple[int, str, str, str]\n    ) -&gt; Tuple[int, Union[str, List[int]], str]:\n        o, t, nv, _ = ava\n        if android and o:\n            return o, [int(x) for x in t.split(\".\")], nv\n        return o, t, nv\n\n    DS, U8, PS = (\n        x509.DirectoryString,\n        x509.UTF8String,\n        x509.PrintableString,\n    )\n    oids = {\n        \"2.5.4.3\": (\"common_name\", \"cn\"),\n        \"2.5.4.6\": (\"country_name\", \"c\"),\n        \"2.5.4.7\": (\"locality_name\", \"l\"),\n        \"2.5.4.8\": (\"state_or_province_name\", \"st\"),\n        \"2.5.4.9\": (\"street_address\", \"street\"),\n        \"2.5.4.10\": (\"organization_name\", \"o\"),\n        \"2.5.4.11\": (\"organizational_unit_name\", \"ou\"),\n        \"0.9.2342.19200300.100.1.1\": (\"user_id\", \"uid\"),\n        \"0.9.2342.19200300.100.1.25\": (\"domain_component\", \"dc\"),\n    }\n    esc = {ord(c): f\"\\\\{c}\" for c in \",+&lt;&gt;;\\\"\\\\\"}\n    cws = \"\".join(\n        chr(i) for i in range(32 + 1)\n    )  # control (but not esc) and whitespace\n    data = []\n    for rdn in reversed(name.chosen):\n        avas = []\n        for ava in rdn:\n            at, av = ava[\"type\"], ava[\"value\"]\n            if at.dotted in oids:\n                o, t = 0, oids[at.dotted][1]  # order standard before OID\n            else:\n                o, t = 1, at.dotted\n            if o or not (\n                isinstance(av, DS) and isinstance(av.chosen, (U8, PS))\n            ):\n                ev = nv = \"#\" + binascii.hexlify(av.dump()).decode()\n            else:\n                ev = (av.native or \"\").translate(esc)\n                if ev.startswith(\"#\"):\n                    ev = \"\\\\\" + ev\n                nv = unicodedata.normalize(\n                    \"NFKD\",\n                    re.sub(r\" +\", \" \", ev).strip(cws).upper().lower(),\n                )\n            avas.append((o, t, nv, ev))\n        data.append(sorted(avas, key=key))\n    return data\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APKV2SignedData","title":"<code>APKV2SignedData</code>","text":"<p>This class holds all data associated with an APK V3 SigningBlock signed data. source : apksigning v2</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>class APKV2SignedData:\n    \"\"\"\n    This class holds all data associated with an APK V3 SigningBlock signed data.\n    source : [apksigning v2](https://source.android.com/security/apksigning/v2.html)\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._bytes = None\n        self.digests = None\n        self.certificates = None\n        self.additional_attributes = None\n\n    def __str__(self):\n\n        certs_infos = \"\"\n\n        for i,cert in enumerate(self.certificates):\n            x509_cert = asn1crypto.x509.Certificate.load(cert)\n\n            certs_infos += \"\\n\"\n            certs_infos += \" [%d]\\n\" % i\n            certs_infos += \"  - Issuer: %s\\n\" % get_certificate_name_string(\n                x509_cert.issuer, short=True\n            )\n            certs_infos += \"  - Subject: %s\\n\" % get_certificate_name_string(\n                x509_cert.subject, short=True\n            )\n            certs_infos += \"  - Serial Number: %s\\n\" % hex(\n                x509_cert.serial_number\n            )\n            certs_infos += \"  - Hash Algorithm: %s\\n\" % x509_cert.hash_algo\n            certs_infos += (\n                \"  - Signature Algorithm: %s\\n\" % x509_cert.signature_algo\n            )\n            certs_infos += (\n                \"  - Valid not before: %s\\n\"\n                % x509_cert['tbs_certificate']['validity']['not_before'].native\n            )\n            certs_infos += (\n                \"  - Valid not after: %s\"\n                % x509_cert['tbs_certificate']['validity']['not_after'].native\n            )\n\n        return \"\\n\".join(\n            [\n                'additional_attributes : {}'.format(\n                    _dump_additional_attributes(self.additional_attributes)\n                ),\n                'digests : {}'.format(\n                    _dump_digests_or_signatures(self.digests)\n                ),\n                'certificates : {}'.format(certs_infos),\n            ]\n        )\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APKV2Signer","title":"<code>APKV2Signer</code>","text":"<p>This class holds all data associated with an APK V2 SigningBlock signer. source : apksigning v2</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>class APKV2Signer:\n    \"\"\"\n    This class holds all data associated with an APK V2 SigningBlock signer.\n    source : [apksigning v2](https://source.android.com/security/apksigning/v2.html)\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._bytes = None\n        self.signed_data = None\n        self.signatures = None\n        self.public_key = None\n\n    def __str__(self):\n        return \"\\n\".join(\n            [\n                '{:s}'.format(str(self.signed_data)),\n                'signatures : {}'.format(\n                    _dump_digests_or_signatures(self.signatures)\n                ),\n                'public key : {}'.format(binascii.hexlify(self.public_key)),\n            ]\n        )\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APKV3SignedData","title":"<code>APKV3SignedData</code>","text":"<p>               Bases: <code>APKV2SignedData</code></p> <p>This class holds all data associated with an APK V3 SigningBlock signed data. source : apksigning v3</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>class APKV3SignedData(APKV2SignedData):\n    \"\"\"\n    This class holds all data associated with an APK V3 SigningBlock signed data.\n    source : [apksigning v3](https://source.android.com/security/apksigning/v3.html)\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.minSDK = None\n        self.maxSDK = None\n\n    def __str__(self):\n\n        base_str = super().__str__()\n\n        # maxSDK is set to a negative value if there is no upper bound on the sdk targeted\n        max_sdk_str = \"%d\" % self.maxSDK\n        if self.maxSDK &gt;= 0x7FFFFFFF:\n            max_sdk_str = \"0x%x\" % self.maxSDK\n\n        return \"\\n\".join(\n            [\n                'signer minSDK : {:d}'.format(self.minSDK),\n                'signer maxSDK : {:s}'.format(max_sdk_str),\n                base_str,\n            ]\n        )\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.APKV3Signer","title":"<code>APKV3Signer</code>","text":"<p>               Bases: <code>APKV2Signer</code></p> <p>This class holds all data associated with an APK V3 SigningBlock signer. source : apksigning v3</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>class APKV3Signer(APKV2Signer):\n    \"\"\"\n    This class holds all data associated with an APK V3 SigningBlock signer.\n    source : [apksigning v3](https://source.android.com/security/apksigning/v3.html)\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.minSDK = None\n        self.maxSDK = None\n\n    def __str__(self):\n\n        base_str = super().__str__()\n\n        # maxSDK is set to a negative value if there is no upper bound on the sdk targeted\n        max_sdk_str = \"%d\" % self.maxSDK\n        if self.maxSDK &gt;= 0x7FFFFFFF:\n            max_sdk_str = \"0x%x\" % self.maxSDK\n\n        return \"\\n\".join(\n            [\n                'signer minSDK : {:d}'.format(self.minSDK),\n                'signer maxSDK : {:s}'.format(max_sdk_str),\n                base_str,\n            ]\n        )\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.Error","title":"<code>Error</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for exceptions in this module.</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>class Error(Exception):\n    \"\"\"Base class for exceptions in this module.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.ensure_final_value","title":"<code>ensure_final_value(packageName, arsc, value)</code>","text":"<p>Ensure incoming value is always the value, not the resid</p> <p>androguard will sometimes return the Android \"resId\" aka Resource ID instead of the actual value.  This checks whether the value is actually a resId, then performs the Android Resource lookup as needed.</p> <p>Returns:</p> Type Description <code>str</code> <p>the final Android Resource value</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def ensure_final_value(packageName: str, arsc: ARSCParser, value: str) -&gt; str:\n    \"\"\"Ensure incoming value is always the value, not the resid\n\n    androguard will sometimes return the Android \"resId\" aka\n    Resource ID instead of the actual value.  This checks whether\n    the value is actually a resId, then performs the Android\n    Resource lookup as needed.\n\n    :returns: the final Android Resource value\n    \"\"\"\n    if value:\n        returnValue = value\n        if value[0] == '@':\n            # TODO: @packagename:DEADBEEF is not supported here!\n            try:  # can be a literal value or a resId\n                res_id = int('0x' + value[1:], 16)\n                res_id = arsc.get_id(packageName, res_id)[1]\n                returnValue = arsc.get_string(packageName, res_id)[1]\n            except (ValueError, TypeError):\n                pass\n        return returnValue\n    return ''\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.get_apkid","title":"<code>get_apkid(apkfile)</code>","text":"<p>Read (appid, versionCode, versionName) from an APK</p> <p>This first tries to do quick binary XML parsing to just get the values that are needed.  It will fallback to full androguard parsing, which is slow, if it can't find the versionName value or versionName is set to a Android String Resource (e.g. an integer hex value that starts with @).</p> <p>Returns:</p> Type Description <code>tuple[str, str, str]</code> <p>tuple of format (appid, versionCode, versionName) of a given apkfile</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if manifest is malformed</p> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def get_apkid(apkfile: str) -&gt; tuple[str, str, str]:\n    \"\"\"Read (appid, versionCode, versionName) from an APK\n\n    This first tries to do quick binary XML parsing to just get the\n    values that are needed.  It will fallback to full androguard\n    parsing, which is slow, if it can't find the versionName value or\n    versionName is set to a Android String Resource (e.g. an integer\n    hex value that starts with @).\n\n    :raises RuntimeError: if manifest is malformed\n    :returns: tuple of format (appid, versionCode, versionName) of a given apkfile\n    \"\"\"\n    logger.debug(\"GET_APKID\")\n\n    if not os.path.exists(apkfile):\n        logger.error(\"'{apkfile}' does not exist!\".format(apkfile=apkfile))\n\n    appid = None\n    versionCode = None\n    versionName = None\n    apk = ZipEntry.parse(apkfile, False)\n    manifest = apk.read('AndroidManifest.xml')\n    axml = AXMLParser(manifest)\n    count = 0\n    while axml.is_valid():\n        _type = next(axml)\n        count += 1\n        if _type == START_TAG:\n            for i in range(0, axml.getAttributeCount()):\n                name = axml.getAttributeName(i)\n                _type = axml.getAttributeValueType(i)\n                _data = axml.getAttributeValueData(i)\n                value = format_value(\n                    _type, _data, lambda _: axml.getAttributeValue(i)\n                )\n                if appid is None and name == 'package':\n                    appid = value\n                elif versionCode is None and name == 'versionCode':\n                    if value.startswith('0x'):\n                        versionCode = str(int(value, 16))\n                    else:\n                        versionCode = value\n                elif versionName is None and name == 'versionName':\n                    versionName = value\n\n            if axml.name == 'manifest':\n                break\n        elif _type == END_TAG or _type == TEXT or _type == END_DOCUMENT:\n            raise RuntimeError(\n                '{path}: &lt;manifest&gt; must be the first element in AndroidManifest.xml'.format(\n                    path=apkfile\n                )\n            )\n\n    if not versionName or versionName[0] == '@':\n        a = APK(apkfile)\n        versionName = ensure_final_value(\n            a.package, a.get_android_resources(), a.get_androidversion_name()\n        )\n    if not versionName:\n        versionName = ''  # versionName is expected to always be a str\n\n    return appid, versionCode, versionName.strip('\\0')\n</code></pre>"},{"location":"reference/androguard/core/apk/index.html#androguard.core.apk.show_Certificate","title":"<code>show_Certificate(cert, short=False)</code>","text":"<p>Print Fingerprints, Issuer and Subject of an X509 Certificate.</p> <p>Parameters:</p> Name Type Description Default <code>cert</code> <code>Certificate</code> <p><code>asn1crypto.x509.Certificate</code> to print</p> required <code>short</code> <code>bool</code> <p>Print in shortform for DN (Default: False)</p> <code>False</code> Source code in <code>androguard/core/apk/__init__.py</code> <pre><code>def show_Certificate(cert:asn1crypto.x509.Certificate, short:bool=False) -&gt; None:\n    \"\"\"\n    Print Fingerprints, Issuer and Subject of an X509 Certificate.\n\n    :param cert: `asn1crypto.x509.Certificate` to print\n    :param short: Print in shortform for DN (Default: False)\n    \"\"\"\n    print(\"SHA1 Fingerprint: {}\".format(cert.sha1_fingerprint))\n    print(\"SHA256 Fingerprint: {}\".format(cert.sha256_fingerprint))\n    print(\n        \"Issuer: {}\".format(\n            get_certificate_name_string(cert.issuer.native, short=short)\n        )\n    )\n    print(\n        \"Subject: {}\".format(\n            get_certificate_name_string(cert.subject.native, short=short)\n        )\n    )\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html","title":"axml","text":""},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCComplex","title":"<code>ARSCComplex</code>","text":"<p>This is actually a <code>ResTable_map_entry</code></p> <p>It contains a set of {name: value} mappings, which are of type <code>ResTable_map</code>. A <code>ResTable_map</code> contains two items: <code>ResTable_ref</code> and <code>Res_value</code>.</p> <p>See ResourceTypes.h 1485 for <code>ResTable_map_entry</code> and ResourceTypes.h 1498 for <code>ResTable_map</code></p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>class ARSCComplex:\n    \"\"\"\n    This is actually a `ResTable_map_entry`\n\n    It contains a set of {name: value} mappings, which are of type `ResTable_map`.\n    A `ResTable_map` contains two items: `ResTable_ref` and `Res_value`.\n\n    See [ResourceTypes.h 1485](http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#1485) for `ResTable_map_entry`\n    and [ResourceTypes.h 1498](http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#1498) for `ResTable_map`\n    \"\"\"\n\n    def __init__(\n        self,\n        buff: BinaryIO,\n        expected_end_of_chunk: int,\n        parent: Union[PackageContext, None] = None,\n    ) -&gt; None:\n        self.start = buff.tell()\n        self.parent = parent\n\n        self.id_parent = unpack('&lt;I', buff.read(4))[0]\n        self.count = unpack('&lt;I', buff.read(4))[0]\n\n        self.items = []\n        # Parse self.count number of `ResTable_map`\n        # these are structs of ResTable_ref and Res_value\n        # ResTable_ref is a uint32_t.\n        for i in range(0, self.count):\n            if buff.tell() + 4 &gt; expected_end_of_chunk:\n                print(\n                    f\"We are out of bound with this complex entry. Count: {self.count}\"\n                )\n                break\n            self.items.append(\n                (\n                    unpack('&lt;I', buff.read(4))[0],\n                    ARSCResStringPoolRef(buff, self.parent),\n                )\n            )\n\n    def __repr__(self):\n        return \"&lt;ARSCComplex idx='0x{:08x}' parent='{}' count='{}'&gt;\".format(\n            self.start, self.id_parent, self.count\n        )\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCHeader","title":"<code>ARSCHeader</code>","text":"<p>Object which contains a Resource Chunk. This is an implementation of the <code>ResChunk_header</code>.</p> <p>It will throw an ResParserError if the header could not be read successfully.</p> <p>It is not checked if the data is outside the buffer size nor if the current chunk fits into the parent chunk (if any)!</p> <p>The parameter <code>expected_type</code> can be used to immediately check the header for the type or raise a ResParserError. This is useful if you know what type of chunk must follow.</p> <p>See http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#196</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>class ARSCHeader:\n    \"\"\"\n    Object which contains a Resource Chunk.\n    This is an implementation of the `ResChunk_header`.\n\n    It will throw an [ResParserError][androguard.core.axml.ResParserError] if the header could not be read successfully.\n\n    It is not checked if the data is outside the buffer size nor if the current\n    chunk fits into the parent chunk (if any)!\n\n    The parameter `expected_type` can be used to immediately check the header for the type or raise a [ResParserError][androguard.core.axml.ResParserError].\n    This is useful if you know what type of chunk must follow.\n\n    See http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#196\n    \"\"\"\n\n    # This is the minimal size such a header must have. There might be other header data too!\n    SIZE = 2 + 2 + 4\n\n    def __init__(\n        self,\n        buff: BinaryIO,\n        expected_type: Union[int, None] = None,\n        possible_types: Union[set[int], None] = None,\n    ) -&gt; None:\n        \"\"\"\n        :raises ResParserError: if header malformed\n        :param buff: the buffer set to the position where the header starts.\n        :param int expected_type: the type of the header which is expected.\n        \"\"\"\n        self.start = buff.tell()\n        # Make sure we do not read over the buffer:\n        if buff.raw.getbuffer().nbytes &lt; self.start + self.SIZE:\n            raise ResParserError(\n                \"Can not read over the buffer size! Offset={}\".format(\n                    self.start\n                )\n            )\n\n        # Checking for dummy data between elements\n        if possible_types:\n            while True:\n                cur_pos = buff.tell()\n                self._type, self._header_size, self._size = unpack(\n                    '&lt;HHL', buff.read(self.SIZE)\n                )\n\n                # cases where packers set the EndNamespace with zero size: check we are the end and add the prefix + uri\n                if self._size &lt; self.SIZE and (\n                    buff.raw.getbuffer().nbytes\n                    == cur_pos + self._header_size + 4 + 4\n                ):\n                    self._size = 24\n\n                if cur_pos == 0 or (\n                    self._type in possible_types\n                    and self._header_size &gt;= self.SIZE\n                    and self._size &gt; self.SIZE\n                ):\n                    break\n                buff.seek(cur_pos)\n                buff.read(1)\n                logger.warning(\n                    \"Appears that dummy data are found between elements!\"\n                )\n        else:\n            self._type, self._header_size, self._size = unpack(\n                '&lt;HHL', buff.read(self.SIZE)\n            )\n\n        if expected_type and self._type != expected_type:\n            raise ResParserError(\n                \"Header type is not equal the expected type: Got 0x{:04x}, wanted 0x{:04x}\".format(\n                    self._type, expected_type\n                )\n            )\n\n        # Assert that the read data will fit into the chunk.\n        # The total size must be equal or larger than the header size\n        if self._header_size &lt; self.SIZE:\n            raise ResParserError(\n                \"declared header size is smaller than required size of {}! Offset={}\".format(\n                    self.SIZE, self.start\n                )\n            )\n        if self._size &lt; self.SIZE:\n            raise ResParserError(\n                \"declared chunk size is smaller than required size of {}! Offset={}\".format(\n                    self.SIZE, self.start\n                )\n            )\n        if self._size &lt; self._header_size:\n            raise ResParserError(\n                \"declared chunk size ({}) is smaller than header size ({})! Offset={}\".format(\n                    self._size, self._header_size, self.start\n                )\n            )\n\n    @property\n    def type(self) -&gt; int:\n        \"\"\"\n        Type identifier for this chunk\n        \"\"\"\n        return self._type\n\n    @property\n    def header_size(self) -&gt; int:\n        \"\"\"\n        Size of the chunk header (in bytes).  Adding this value to\n        the address of the chunk allows you to find its associated data\n        (if any).\n        \"\"\"\n        return self._header_size\n\n    @property\n    def size(self) -&gt; int:\n        \"\"\"\n        Total size of this chunk (in bytes).  This is the chunkSize plus\n        the size of any data associated with the chunk.  Adding this value\n        to the chunk allows you to completely skip its contents (including\n        any child chunks).  If this value is the same as chunkSize, there is\n        no data associated with the chunk.\n        \"\"\"\n        return self._size\n\n    @property\n    def end(self) -&gt; int:\n        \"\"\"\n        Get the absolute offset inside the file, where the chunk ends.\n        This is equal to `ARSCHeader.start + ARSCHeader.size`.\n        \"\"\"\n        return self.start + self.size\n\n    def __repr__(self):\n        return \"&lt;ARSCHeader idx='0x{:08x}' type='{}' header_size='{}' size='{}'&gt;\".format(\n            self.start, self.type, self.header_size, self.size\n        )\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCHeader.end","title":"<code>end</code>  <code>property</code>","text":"<p>Get the absolute offset inside the file, where the chunk ends. This is equal to <code>ARSCHeader.start + ARSCHeader.size</code>.</p>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCHeader.header_size","title":"<code>header_size</code>  <code>property</code>","text":"<p>Size of the chunk header (in bytes).  Adding this value to the address of the chunk allows you to find its associated data (if any).</p>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCHeader.size","title":"<code>size</code>  <code>property</code>","text":"<p>Total size of this chunk (in bytes).  This is the chunkSize plus the size of any data associated with the chunk.  Adding this value to the chunk allows you to completely skip its contents (including any child chunks).  If this value is the same as chunkSize, there is no data associated with the chunk.</p>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCHeader.type","title":"<code>type</code>  <code>property</code>","text":"<p>Type identifier for this chunk</p>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCHeader.__init__","title":"<code>__init__(buff, expected_type=None, possible_types=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>the buffer set to the position where the header starts.</p> required <code>expected_type</code> <code>int</code> <p>the type of the header which is expected.</p> <code>None</code> <p>Raises:</p> Type Description <code>ResParserError</code> <p>if header malformed</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def __init__(\n    self,\n    buff: BinaryIO,\n    expected_type: Union[int, None] = None,\n    possible_types: Union[set[int], None] = None,\n) -&gt; None:\n    \"\"\"\n    :raises ResParserError: if header malformed\n    :param buff: the buffer set to the position where the header starts.\n    :param int expected_type: the type of the header which is expected.\n    \"\"\"\n    self.start = buff.tell()\n    # Make sure we do not read over the buffer:\n    if buff.raw.getbuffer().nbytes &lt; self.start + self.SIZE:\n        raise ResParserError(\n            \"Can not read over the buffer size! Offset={}\".format(\n                self.start\n            )\n        )\n\n    # Checking for dummy data between elements\n    if possible_types:\n        while True:\n            cur_pos = buff.tell()\n            self._type, self._header_size, self._size = unpack(\n                '&lt;HHL', buff.read(self.SIZE)\n            )\n\n            # cases where packers set the EndNamespace with zero size: check we are the end and add the prefix + uri\n            if self._size &lt; self.SIZE and (\n                buff.raw.getbuffer().nbytes\n                == cur_pos + self._header_size + 4 + 4\n            ):\n                self._size = 24\n\n            if cur_pos == 0 or (\n                self._type in possible_types\n                and self._header_size &gt;= self.SIZE\n                and self._size &gt; self.SIZE\n            ):\n                break\n            buff.seek(cur_pos)\n            buff.read(1)\n            logger.warning(\n                \"Appears that dummy data are found between elements!\"\n            )\n    else:\n        self._type, self._header_size, self._size = unpack(\n            '&lt;HHL', buff.read(self.SIZE)\n        )\n\n    if expected_type and self._type != expected_type:\n        raise ResParserError(\n            \"Header type is not equal the expected type: Got 0x{:04x}, wanted 0x{:04x}\".format(\n                self._type, expected_type\n            )\n        )\n\n    # Assert that the read data will fit into the chunk.\n    # The total size must be equal or larger than the header size\n    if self._header_size &lt; self.SIZE:\n        raise ResParserError(\n            \"declared header size is smaller than required size of {}! Offset={}\".format(\n                self.SIZE, self.start\n            )\n        )\n    if self._size &lt; self.SIZE:\n        raise ResParserError(\n            \"declared chunk size is smaller than required size of {}! Offset={}\".format(\n                self.SIZE, self.start\n            )\n        )\n    if self._size &lt; self._header_size:\n        raise ResParserError(\n            \"declared chunk size ({}) is smaller than header size ({})! Offset={}\".format(\n                self._size, self._header_size, self.start\n            )\n        )\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCParser","title":"<code>ARSCParser</code>","text":"<p>Parser for resource.arsc files</p> <p>The ARSC File is, like the binary XML format, a chunk based format. Both formats are actually identical but use different chunks in order to store the data.</p> <p>The most outer chunk in the ARSC file is a chunk of type <code>RES_TABLE_TYPE</code>. Inside this chunk is a StringPool and at least one package.</p> <p>Each package is a chunk of type <code>RES_TABLE_PACKAGE_TYPE</code>. It contains again many more chunks.</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>class ARSCParser:\n    \"\"\"\n    Parser for resource.arsc files\n\n    The ARSC File is, like the binary XML format, a chunk based format.\n    Both formats are actually identical but use different chunks in order to store the data.\n\n    The most outer chunk in the ARSC file is a chunk of type `RES_TABLE_TYPE`.\n    Inside this chunk is a StringPool and at least one package.\n\n    Each package is a chunk of type `RES_TABLE_PACKAGE_TYPE`.\n    It contains again many more chunks.\n    \"\"\"\n\n    def __init__(self, raw_buff: bytes) -&gt; None:\n        \"\"\"\n        :param bytes raw_buff: the raw bytes of the file\n        \"\"\"\n        self.buff = io.BufferedReader(io.BytesIO(raw_buff))\n        self.buff_size = self.buff.raw.getbuffer().nbytes\n\n        if self.buff_size &lt; 8 or self.buff_size &gt; 0xFFFFFFFF:\n            raise ResParserError(\n                \"Invalid file size {} for a resources.arsc file!\".format(\n                    self.buff_size\n                )\n            )\n\n        self.analyzed = False\n        self._resolved_strings = None\n        self.packages = defaultdict(list)\n        self.values = {}\n        self.resource_values = defaultdict(defaultdict)\n        self.resource_configs = defaultdict(lambda: defaultdict(set))\n        self.resource_keys = defaultdict(lambda: defaultdict(defaultdict))\n        self.stringpool_main = None\n\n        # First, there is a ResTable_header.\n        self.header = ARSCHeader(self.buff, expected_type=RES_TABLE_TYPE)\n\n        # More sanity checks...\n        if self.header.header_size != 12:\n            logger.warning(\n                \"The ResTable_header has an unexpected header size! Expected 12 bytes, got {}.\".format(\n                    self.header.header_size\n                )\n            )\n\n        if self.header.size &gt; self.buff_size:\n            raise ResParserError(\n                \"The file seems to be truncated. Refuse to parse the file! Filesize: {}, declared size: {}\".format(\n                    self.buff_size, self.header.size\n                )\n            )\n\n        if self.header.size &lt; self.buff_size:\n            logger.warning(\n                \"The Resource file seems to have data appended to it. Filesize: {}, declared size: {}\".format(\n                    self.buff_size, self.header.size\n                )\n            )\n\n        # The ResTable_header contains the packageCount, i.e. the number of ResTable_package\n        self.packageCount = unpack('&lt;I', self.buff.read(4))[0]\n\n        # Even more sanity checks...\n        if self.packageCount &lt; 1:\n            logger.warning(\n                \"The number of packages is smaller than one. There should be at least one package!\"\n            )\n\n        logger.debug(\n            \"Parsed ResTable_header with {} package(s) inside.\".format(\n                self.packageCount\n            )\n        )\n\n        # skip to the start of the first chunk's data, skipping trailing header bytes (there should be none)\n        self.buff.seek(self.header.start + self.header.header_size)\n\n        # Now parse the data:\n        # We should find one ResStringPool_header and one or more ResTable_package chunks inside\n        while self.buff.tell() &lt;= self.header.end - ARSCHeader.SIZE:\n            res_header = ARSCHeader(self.buff)\n\n            if res_header.end &gt; self.header.end:\n                # this inner chunk crosses the boundary of the table chunk\n                logger.warning(\n                    \"Invalid chunk found! It is larger than the outer chunk: %s\",\n                    res_header,\n                )\n                break\n\n            if res_header.type == RES_STRING_POOL_TYPE:\n                # There should be only one StringPool per resource table.\n                if self.stringpool_main:\n                    logger.warning(\n                        \"Already found a ResStringPool_header, but there should be only one! Will not parse the Pool again.\"\n                    )\n                else:\n                    self.stringpool_main = StringBlock(self.buff, res_header)\n                    logger.debug(\n                        \"Found the main string pool: %s\", self.stringpool_main\n                    )\n\n            elif res_header.type == RES_TABLE_PACKAGE_TYPE:\n                if len(self.packages) &gt; self.packageCount:\n                    raise ResParserError(\n                        \"Got more packages ({}) than expected ({})\".format(\n                            len(self.packages), self.packageCount\n                        )\n                    )\n\n                current_package = ARSCResTablePackage(self.buff, res_header)\n                package_name = current_package.get_name()\n\n                # After the Header, we have the resource type symbol table\n                self.buff.seek(\n                    current_package.header.start + current_package.typeStrings\n                )\n                type_sp_header = ARSCHeader(\n                    self.buff, expected_type=RES_STRING_POOL_TYPE\n                )\n                mTableStrings = StringBlock(self.buff, type_sp_header)\n\n                # Next, we should have the resource key symbol table\n                self.buff.seek(\n                    current_package.header.start + current_package.keyStrings\n                )\n                key_sp_header = ARSCHeader(\n                    self.buff, expected_type=RES_STRING_POOL_TYPE\n                )\n                mKeyStrings = StringBlock(self.buff, key_sp_header)\n\n                # Add them to the dict of read packages\n                self.packages[package_name].append(current_package)\n                self.packages[package_name].append(mTableStrings)\n                self.packages[package_name].append(mKeyStrings)\n\n                pc = PackageContext(\n                    current_package,\n                    self.stringpool_main,\n                    mTableStrings,\n                    mKeyStrings,\n                )\n                logger.debug(\"Constructed a PackageContext: %s\", pc)\n\n                # skip to the first header in this table package chunk\n                # FIXME is this correct? We have already read the first two sections!\n                # self.buff.set_idx(res_header.start + res_header.header_size)\n                # this looks more like we want: (???)\n                # FIXME it looks like that the two string pools we have read might not be concatenated to each other,\n                # thus jumping to the sum of the sizes might not be correct...\n                next_idx = (\n                    res_header.start\n                    + res_header.header_size\n                    + type_sp_header.size\n                    + key_sp_header.size\n                )\n\n                if next_idx != self.buff.tell():\n                    # If this happens, we have a testfile ;)\n                    logger.error(\"This looks like an odd resources.arsc file!\")\n                    logger.error(\n                        \"Please report this error including the file you have parsed!\"\n                    )\n                    logger.error(\n                        \"next_idx = {}, current buffer position = {}\".format(\n                            next_idx, self.buff.tell()\n                        )\n                    )\n                    logger.error(\n                        \"Please open a issue at https://github.com/androguard/androguard/issues\"\n                    )\n                    logger.error(\"Thank you!\")\n\n                self.buff.seek(next_idx)\n\n                # Read all other headers\n                while self.buff.tell() &lt;= res_header.end - ARSCHeader.SIZE:\n                    pkg_chunk_header = ARSCHeader(self.buff)\n                    logger.debug(\"Found a header: {}\".format(pkg_chunk_header))\n                    if (\n                        pkg_chunk_header.start + pkg_chunk_header.size\n                        &gt; res_header.end\n                    ):\n                        # we are way off the package chunk; bail out\n                        break\n\n                    self.packages[package_name].append(pkg_chunk_header)\n\n                    if pkg_chunk_header.type == RES_TABLE_TYPE_SPEC_TYPE:\n                        self.packages[package_name].append(\n                            ARSCResTypeSpec(self.buff, pc)\n                        )\n\n                    elif pkg_chunk_header.type == RES_TABLE_TYPE_TYPE:\n                        # Parse a RES_TABLE_TYPE\n                        # http://androidxref.com/9.0.0_r3/xref/frameworks/base/tools/aapt2/format/binary/BinaryResourceParser.cpp#311\n                        start_of_chunk = self.buff.tell() - 8\n                        expected_end_of_chunk = (\n                            start_of_chunk + pkg_chunk_header.size\n                        )\n                        a_res_type = ARSCResType(self.buff, pc)\n                        self.packages[package_name].append(a_res_type)\n                        self.resource_configs[package_name][a_res_type].add(\n                            a_res_type.config\n                        )\n\n                        logger.debug(\"Config: {}\".format(a_res_type.config))\n\n                        entries = []\n                        FLAG_OFFSET16 = 0x02\n                        NO_ENTRY_16 = 0xFFFF\n                        NO_ENTRY_32 = 0xFFFFFFFF\n                        expected_entries_start = (\n                            start_of_chunk + a_res_type.entriesStart\n                        )\n\n                        # Helper function to convert 16-bit offset to 32-bit\n                        def offset_from16(off16):\n                            return (\n                                NO_ENTRY_16\n                                if off16 == NO_ENTRY_16\n                                else off16 * 4\n                            )\n\n                        for i in range(0, a_res_type.entryCount):\n                            current_package.mResId = (\n                                current_package.mResId &amp; 0xFFFF0000 | i\n                            )\n                            # Check if FLAG_OFFSET16 is set\n                            if a_res_type.flags &amp; FLAG_OFFSET16:\n                                # Read as 16-bit offset\n                                offset_16 = unpack('&lt;H', self.buff.read(2))[0]\n                                offset = offset_from16(offset_16)\n                                if offset == NO_ENTRY_16:\n                                    continue\n                            else:\n                                # Read as 32-bit offset\n                                offset = unpack('&lt;I', self.buff.read(4))[0]\n                                if offset == NO_ENTRY_32:\n                                    continue\n                            entries.append((offset, current_package.mResId))\n\n                        self.packages[package_name].append(entries)\n\n                        base_offset = self.buff.tell()\n                        if base_offset + ((4 - (base_offset % 4)) % 4) != expected_entries_start:\n                            # FIXME: seems like I am missing 2 bytes here in some cases, though it does not affect the result\n                            logger.warning(\n                                \"Something is off here! We are not where the entries should start.\"\n                            )\n                        base_offset = expected_entries_start\n                        for entry_offset, res_id in entries:\n                            if entry_offset != -1:\n                                ate = ARSCResTableEntry(\n                                    self.buff,\n                                    base_offset + entry_offset,\n                                    expected_end_of_chunk,\n                                    res_id,\n                                    pc,\n                                )\n                                self.packages[package_name].append(ate)\n                                if ate.is_weak():\n                                    # FIXME we are not sure how to implement the FLAG_WEAK!\n                                    # We saw the following: There is just a single Res_value after the ARSCResTableEntry\n                                    # and then comes the next ARSCHeader.\n                                    # Therefore we think this means all entries are somehow replicated?\n                                    # So we do some kind of hack here. We set the idx to the entry again...\n                                    # Now we will read all entries!\n                                    # Not sure if this is a good solution though\n                                    self.buff.seek(ate.start)\n                    elif pkg_chunk_header.type == RES_TABLE_LIBRARY_TYPE:\n                        logger.warning(\n                            \"RES_TABLE_LIBRARY_TYPE chunk is not supported\"\n                        )\n                    else:\n                        # Unknown / not-handled chunk type\n                        logger.warning(\n                            \"Unknown chunk type encountered inside RES_TABLE_PACKAGE: %s\",\n                            pkg_chunk_header,\n                        )\n\n                    # skip to the next chunk\n                    self.buff.seek(pkg_chunk_header.end)\n            else:\n                # Unknown / not-handled chunk type\n                logger.warning(\n                    \"Unknown chunk type encountered: %s\", res_header\n                )\n\n            # move to the next resource chunk\n            self.buff.seek(res_header.end)\n\n    def _analyse(self):\n        if self.analyzed:\n            return\n\n        self.analyzed = True\n\n        for package_name in self.packages:\n            self.values[package_name] = {}\n\n            nb = 3\n            while nb &lt; len(self.packages[package_name]):\n                header = self.packages[package_name][nb]\n                if isinstance(header, ARSCHeader):\n                    if header.type == RES_TABLE_TYPE_TYPE:\n                        a_res_type = self.packages[package_name][nb + 1]\n\n                        locale = a_res_type.config.get_language_and_region()\n\n                        c_value = self.values[package_name].setdefault(\n                            locale, {\"public\": []}\n                        )\n\n                        entries = self.packages[package_name][nb + 2]\n                        nb_i = 0\n                        for entry, res_id in entries:\n                            if entry != -1:\n                                ate = self.packages[package_name][\n                                    nb + 3 + nb_i\n                                ]\n\n                                self.resource_values[ate.mResId][\n                                    a_res_type.config\n                                ] = ate\n                                self.resource_keys[package_name][\n                                    a_res_type.get_type()\n                                ][ate.get_value()] = ate.mResId\n\n                                if ate.get_index() != -1:\n                                    c_value[\"public\"].append(\n                                        (\n                                            a_res_type.get_type(),\n                                            ate.get_value(),\n                                            ate.mResId,\n                                        )\n                                    )\n\n                                if a_res_type.get_type() not in c_value:\n                                    c_value[a_res_type.get_type()] = []\n\n                                if a_res_type.get_type() == \"string\":\n                                    c_value[\"string\"].append(\n                                        self.get_resource_string(ate)\n                                    )\n\n                                elif a_res_type.get_type() == \"id\":\n                                    if (\n                                        not ate.is_complex()\n                                        and not ate.is_compact()\n                                    ):\n                                        c_value[\"id\"].append(\n                                            self.get_resource_id(ate)\n                                        )\n\n                                elif a_res_type.get_type() == \"bool\":\n                                    if (\n                                        not ate.is_complex()\n                                        and not ate.is_compact()\n                                    ):\n                                        c_value[\"bool\"].append(\n                                            self.get_resource_bool(ate)\n                                        )\n\n                                elif a_res_type.get_type() == \"integer\":\n                                    if ate.is_compact():\n                                        c_value[\"integer\"].append(ate.data)\n                                    else:\n                                        c_value[\"integer\"].append(\n                                            self.get_resource_integer(ate)\n                                        )\n\n                                elif a_res_type.get_type() == \"color\":\n                                    if not ate.is_compact():\n                                        c_value[\"color\"].append(\n                                            self.get_resource_color(ate)\n                                        )\n\n                                elif a_res_type.get_type() == \"dimen\":\n                                    if not ate.is_compact():\n                                        c_value[\"dimen\"].append(\n                                            self.get_resource_dimen(ate)\n                                        )\n\n                                nb_i += 1\n                        nb += (\n                            3 + nb_i - 1\n                        )  # -1 to account for the nb+=1 on the next line\n                nb += 1\n\n    def get_resource_string(self, ate: ARSCResTableEntry) -&gt; list:\n        return [ate.get_value(), ate.get_key_data()]\n\n    def get_resource_id(self, ate: ARSCResTableEntry) -&gt; list[str]:\n        x = [ate.get_value()]\n        if ate.key.get_data() == 0:\n            x.append(\"false\")\n        elif ate.key.get_data() == 1:\n            x.append(\"true\")\n        return x\n\n    def get_resource_bool(self, ate: ARSCResTableEntry) -&gt; list[str]:\n        x = [ate.get_value()]\n        if ate.key.get_data() == 0:\n            x.append(\"false\")\n        elif ate.key.get_data() == -1:\n            x.append(\"true\")\n        return x\n\n    def get_resource_integer(self, ate: ARSCResTableEntry) -&gt; list:\n        return [ate.get_value(), ate.key.get_data()]\n\n    def get_resource_color(self, ate: ARSCResTableEntry) -&gt; list:\n        entry_data = ate.key.get_data()\n        return [\n            ate.get_value(),\n            \"#{:02x}{:02x}{:02x}{:02x}\".format(\n                ((entry_data &gt;&gt; 24) &amp; 0xFF),\n                ((entry_data &gt;&gt; 16) &amp; 0xFF),\n                ((entry_data &gt;&gt; 8) &amp; 0xFF),\n                (entry_data &amp; 0xFF),\n            ),\n        ]\n\n    def get_resource_dimen(self, ate: ARSCResTableEntry) -&gt; list:\n        try:\n            return [\n                ate.get_value(),\n                \"{}{}\".format(\n                    complexToFloat(ate.key.get_data()),\n                    DIMENSION_UNITS[ate.key.get_data() &amp; COMPLEX_UNIT_MASK],\n                ),\n            ]\n        except IndexError:\n            logger.debug(\n                \"Out of range dimension unit index for {}: {}\".format(\n                    complexToFloat(ate.key.get_data()),\n                    ate.key.get_data() &amp; COMPLEX_UNIT_MASK,\n                )\n            )\n            return [ate.get_value(), ate.key.get_data()]\n\n    # FIXME\n    def get_resource_style(self, ate: ARSCResTableEntry) -&gt; list:\n        return [\"\", \"\"]\n\n    def get_packages_names(self) -&gt; list[str]:\n        \"\"\"\n        Retrieve a list of all package names, which are available\n        in the given resources.arsc.\n        \"\"\"\n        return list(self.packages.keys())\n\n    def get_locales(self, package_name: str) -&gt; list[str]:\n        \"\"\"\n        Retrieve a list of all available locales in a given packagename.\n\n        :param package_name: the package name to get locales of\n        :returns: a list of locale strings\n        \"\"\"\n        self._analyse()\n        return list(self.values[package_name].keys())\n\n    def get_types(\n        self, package_name: str, locale: str = '\\x00\\x00'\n    ) -&gt; list[str]:\n        \"\"\"\n        Retrieve a list of all types which are available in the given\n        package and locale.\n\n        :param package_name: the package name to get types of\n        :param locale: the locale to get types of (default: '\\x00\\x00')\n        :returns: a list of type strings\n        \"\"\"\n        self._analyse()\n        return list(self.values[package_name][locale].keys())\n\n    def get_public_resources(\n        self, package_name: str, locale: str = '\\x00\\x00'\n    ) -&gt; bytes:\n        \"\"\"\n        Get the XML (as string) of all resources of type 'public'.\n\n        The public resources table contains the IDs for each item.\n\n        :param package_name: the package name to get the resources for\n        :param locale: the locale to get the resources for (default: '\\x00\\x00')\n        :returns: the public xml bytes\n        \"\"\"\n\n        self._analyse()\n\n        buff = '&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\\n'\n        buff += '&lt;resources&gt;\\n'\n\n        try:\n            for i in self.values[package_name][locale][\"public\"]:\n                buff += (\n                    '&lt;public type=\"{}\" name=\"{}\" id=\"0x{:08x}\" /&gt;\\n'.format(\n                        i[0], i[1], i[2]\n                    )\n                )\n        except KeyError:\n            pass\n\n        buff += '&lt;/resources&gt;\\n'\n\n        return buff.encode('utf-8')\n\n    def get_string_resources(\n        self, package_name: str, locale: str = '\\x00\\x00'\n    ) -&gt; bytes:\n        \"\"\"\n        Get the XML (as string) of all resources of type 'string'.\n\n        Read more about string resources:\n        &lt;https://developer.android.com/guide/topics/resources/string-resource.html&gt;\n\n        :param package_name: the package name to get the resources for\n        :param locale: the locale to get the resources for (default: '\\x00\\x00')\n        :returns: the string xml bytes\n        \"\"\"\n        self._analyse()\n\n        buff = '&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\\n'\n        buff += '&lt;resources&gt;\\n'\n\n        try:\n            for i in self.values[package_name][locale][\"string\"]:\n                if any(map(i[1].__contains__, '&lt;&amp;&gt;')):\n                    value = '&lt;![CDATA[%s]]&gt;' % i[1]\n                else:\n                    value = i[1]\n                buff += '&lt;string name=\"{}\"&gt;{}&lt;/string&gt;\\n'.format(i[0], value)\n        except KeyError:\n            pass\n\n        buff += '&lt;/resources&gt;\\n'\n\n        return buff.encode('utf-8')\n\n    def get_strings_resources(self) -&gt; bytes:\n        \"\"\"\n        Get the XML (as string) of all resources of type 'string'.\n        This is a combined variant, which has all locales and all package names\n        stored.\n\n        :returns: the string, locales, and package name xml bytes\n        \"\"\"\n        self._analyse()\n\n        buff = '&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\\n'\n\n        buff += \"&lt;packages&gt;\\n\"\n        for package_name in self.get_packages_names():\n            buff += \"&lt;package name=\\\"%s\\\"&gt;\\n\" % package_name\n\n            for locale in self.get_locales(package_name):\n                buff += \"&lt;locale value=%s&gt;\\n\" % repr(locale)\n\n                buff += '&lt;resources&gt;\\n'\n                try:\n                    for i in self.values[package_name][locale][\"string\"]:\n                        buff += '&lt;string name=\"{}\"&gt;{}&lt;/string&gt;\\n'.format(\n                            i[0], escape(i[1])\n                        )\n                except KeyError:\n                    pass\n\n                buff += '&lt;/resources&gt;\\n'\n                buff += '&lt;/locale&gt;\\n'\n\n            buff += \"&lt;/package&gt;\\n\"\n\n        buff += \"&lt;/packages&gt;\\n\"\n\n        return buff.encode('utf-8')\n\n    def get_id_resources(\n        self, package_name: str, locale: str = '\\x00\\x00'\n    ) -&gt; bytes:\n        \"\"\"\n        Get the XML (as string) of all resources of type 'id'.\n\n        Read more about ID resources:\n        &lt;https://developer.android.com/guide/topics/resources/more-resources.html#Id&gt;\n\n        :param package_name: the package name to get the resources for\n        :param locale: the locale to get the resources for (default: '\\x00\\x00')\n\n        :returns: the id resources xml bytes\n        \"\"\"\n        self._analyse()\n\n        buff = '&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\\n'\n        buff += '&lt;resources&gt;\\n'\n\n        try:\n            for i in self.values[package_name][locale][\"id\"]:\n                if len(i) == 1:\n                    buff += '&lt;item type=\"id\" name=\"%s\"/&gt;\\n' % (i[0])\n                else:\n                    buff += '&lt;item type=\"id\" name=\"{}\"&gt;{}&lt;/item&gt;\\n'.format(\n                        i[0], escape(i[1])\n                    )\n        except KeyError:\n            pass\n\n        buff += '&lt;/resources&gt;\\n'\n\n        return buff.encode('utf-8')\n\n    def get_bool_resources(\n        self, package_name: str, locale: str = '\\x00\\x00'\n    ) -&gt; bytes:\n        \"\"\"\n        Get the XML (as string) of all resources of type 'bool'.\n\n        Read more about bool resources:\n        &lt;https://developer.android.com/guide/topics/resources/more-resources.html#Bool&gt;\n\n        :param package_name: the package name to get the resources for\n        :param locale: the locale to get the resources for (default: '\\x00\\x00')\n\n        :returns: the bool resources xml bytes\n        \"\"\"\n        self._analyse()\n\n        buff = '&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\\n'\n        buff += '&lt;resources&gt;\\n'\n\n        try:\n            for i in self.values[package_name][locale][\"bool\"]:\n                buff += '&lt;bool name=\"{}\"&gt;{}&lt;/bool&gt;\\n'.format(i[0], i[1])\n        except KeyError:\n            pass\n\n        buff += '&lt;/resources&gt;\\n'\n\n        return buff.encode('utf-8')\n\n    def get_integer_resources(\n        self, package_name: str, locale: str = '\\x00\\x00'\n    ) -&gt; bytes:\n        \"\"\"\n        Get the XML (as string) of all resources of type 'integer'.\n\n        Read more about integer resources:\n        &lt;https://developer.android.com/guide/topics/resources/more-resources.html#Integer&gt;\n\n        :param package_name: the package name to get the resources for\n        :param locale: the locale to get the resources for (default: '\\x00\\x00')\n\n        :returns: the integer resources xml bytes\n        \"\"\"\n        self._analyse()\n\n        buff = '&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\\n'\n        buff += '&lt;resources&gt;\\n'\n\n        try:\n            for i in self.values[package_name][locale][\"integer\"]:\n                buff += '&lt;integer name=\"{}\"&gt;{}&lt;/integer&gt;\\n'.format(i[0], i[1])\n        except KeyError:\n            pass\n\n        buff += '&lt;/resources&gt;\\n'\n\n        return buff.encode('utf-8')\n\n    def get_color_resources(\n        self, package_name: str, locale: str = '\\x00\\x00'\n    ) -&gt; bytes:\n        \"\"\"\n        Get the XML (as string) of all resources of type 'color'.\n\n        Read more about color resources:\n        &lt;https://developer.android.com/guide/topics/resources/more-resources.html#Color&gt;\n\n        :param package_name: the package name to get the resources for\n        :param locale: the locale to get the resources for (default: '\\x00\\x00')\n\n        :returns: the color resources xml bytes\n        \"\"\"\n        self._analyse()\n\n        buff = '&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\\n'\n        buff += '&lt;resources&gt;\\n'\n\n        try:\n            for i in self.values[package_name][locale][\"color\"]:\n                buff += '&lt;color name=\"{}\"&gt;{}&lt;/color&gt;\\n'.format(i[0], i[1])\n        except KeyError:\n            pass\n\n        buff += '&lt;/resources&gt;\\n'\n\n        return buff.encode('utf-8')\n\n    def get_dimen_resources(\n        self, package_name: str, locale: str = '\\x00\\x00'\n    ) -&gt; bytes:\n        \"\"\"\n        Get the XML (as string) of all resources of type 'dimen'.\n\n        Read more about Dimension resources:\n        &lt;https://developer.android.com/guide/topics/resources/more-resources.html#Dimension&gt;\n\n        :param package_name: the package name to get the resources for\n        :param locale: the locale to get the resources for (default: '\\x00\\x00')\n\n        :returns: the dimen resource xml bytes\n        \"\"\"\n        self._analyse()\n\n        buff = '&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\\n'\n        buff += '&lt;resources&gt;\\n'\n\n        try:\n            for i in self.values[package_name][locale][\"dimen\"]:\n                buff += '&lt;dimen name=\"{}\"&gt;{}&lt;/dimen&gt;\\n'.format(i[0], i[1])\n        except KeyError:\n            pass\n\n        buff += '&lt;/resources&gt;\\n'\n\n        return buff.encode('utf-8')\n\n    def get_id(\n        self, package_name: str, rid: int, locale: str = '\\x00\\x00'\n    ) -&gt; tuple:\n        \"\"\"\n        Returns the tuple `(resource_type, resource_name, resource_id)`\n        for the given resource_id.\n\n        :param package_name: package name to query\n        :param rid: the resource_id\n        :param locale: specific locale\n        :returns: tuple of (resource_type, resource_name, resource_id)\n        \"\"\"\n        self._analyse()\n\n        try:\n            for i in self.values[package_name][locale][\"public\"]:\n                if i[2] == rid:\n                    return i\n        except KeyError:\n            pass\n        return None, None, None\n\n    class ResourceResolver:\n        \"\"\"\n        Resolves resources by ID and configuration.\n        This resolver deals with complex resources as well as with references.\n        \"\"\"\n\n        def __init__(\n            self,\n            android_resources: ARSCParser,\n            config: Union[ARSCResTableConfig, None] = None,\n        ) -&gt; None:\n            \"\"\"\n            :param ARSCParser android_resources: A resource parser\n            :param ARSCResTableConfig config: The desired configuration or None to resolve all.\n            \"\"\"\n            self.resources = android_resources\n            self.wanted_config = config\n\n        def resolve(self, res_id: int) -&gt; list[tuple[ARSCResTableConfig, str]]:\n            \"\"\"\n            the given ID into the Resource and returns a list of matching resources.\n\n            :param int res_id: numerical ID of the resource\n            :returns: a list of tuples of (ARSCResTableConfig, str)\n            \"\"\"\n            result = []\n            self._resolve_into_result(result, res_id, self.wanted_config)\n            return result\n\n        def _resolve_into_result(self, result, res_id, config):\n            # First: Get all candidates\n            configs = self.resources.get_res_configs(res_id, config)\n\n            for config, ate in configs:\n                # deconstruct them and check if more candidates are generated\n                self.put_ate_value(result, ate, config)\n\n        def put_ate_value(\n            self,\n            result: list,\n            ate: ARSCResTableEntry,\n            config: ARSCResTableConfig,\n        ) -&gt; None:\n            \"\"\"\n            Put a [ARSCResTableEntry][androguard.core.axml.ARSCResTableEntry] into the list of results\n            :param result: results array\n            :param ate:\n            :param config:\n            \"\"\"\n            if ate.is_complex():\n                complex_array = []\n                result.append((config, complex_array))\n                for _, item in ate.item.items:\n                    self.put_item_value(\n                        complex_array, item, config, ate, complex_=True\n                    )\n            elif ate.is_compact():\n                self.put_item_value(\n                    result,\n                    ate.data,\n                    config,\n                    ate,\n                    complex_=False,\n                    compact_=True,\n                )\n            else:\n                self.put_item_value(\n                    result, ate.key, config, ate, complex_=False\n                )\n\n        def put_item_value(\n            self,\n            result: list,\n            item: Union[ARSCResStringPoolRef, int],\n            config: ARSCResTableConfig,\n            parent: ARSCResTableEntry,\n            complex_: bool,\n            compact_: bool = False,\n        ) -&gt; None:\n            \"\"\"\n            Put the tuple ([ARSCResTableConfig][androguard.core.axml.ARSCResTableConfig], resolved string) into the result set\n\n            :param result: the result set\n            :param item:\n            :param config:\n            :param parent: the originating entry\n            :param complex_: True if the originating `ARSCResTableEntry` was complex\n            :param bool compact_: True if the originating `ARSCResTableEntry` was compact\n            \"\"\"\n            if isinstance(item, ARSCResStringPoolRef):\n                if item.is_reference():\n                    res_id = item.get_data()\n                    if res_id:\n                        # Infinite loop detection:\n                        # TODO should this stay here or should be detect the loop much earlier?\n                        if res_id == parent.mResId:\n                            logger.warning(\n                                \"Infinite loop detected at resource item {}. It references itself!\".format(\n                                    parent\n                                )\n                            )\n                            return\n\n                        self._resolve_into_result(\n                            result, item.get_data(), self.wanted_config\n                        )\n                else:\n                    if complex_:\n                        result.append(item.format_value())\n                    else:\n                        result.append((config, item.format_value()))\n            else:\n                if compact_:\n                    result.append(\n                        (config, parent.parent.stringpool_main.getString(item))\n                    )\n\n    def get_resolved_res_configs(\n        self, rid: int, config: Union[ARSCResTableConfig, None] = None\n    ) -&gt; list[tuple[ARSCResTableConfig, str]]:\n        \"\"\"\n        Return a list of resolved resource IDs with their corresponding configuration.\n        It has a similar return type as [get_res_configs][androguard.core.axml.ARSCParser.get_res_configs] but also handles complex entries\n        and references.\n        Also instead of returning [ARSCResTableConfig][androguard.core.axml.ARSCResTableConfig] in the tuple, the actual values are resolved.\n\n        This is the preferred way of resolving resource IDs to their resources.\n\n        :param rid: the numerical ID of the resource\n        :param config: the desired configuration or None to retrieve all\n        :return: A list of tuples of (`ARSCResTableConfig`, str)\n        \"\"\"\n        resolver = ARSCParser.ResourceResolver(self, config)\n        return resolver.resolve(rid)\n\n    def get_resolved_strings(self) -&gt; list[str]:\n        self._analyse()\n        if self._resolved_strings:\n            return self._resolved_strings\n\n        r = {}\n        for package_name in self.get_packages_names():\n            r[package_name] = {}\n            k = {}\n\n            for locale in self.values[package_name]:\n                v_locale = locale\n                if v_locale == '\\x00\\x00':\n                    v_locale = 'DEFAULT'\n\n                r[package_name][v_locale] = {}\n\n                try:\n                    for i in self.values[package_name][locale][\"public\"]:\n                        if i[0] == 'string':\n                            r[package_name][v_locale][i[2]] = None\n                            k[i[1]] = i[2]\n                except KeyError:\n                    pass\n\n                try:\n                    for i in self.values[package_name][locale][\"string\"]:\n                        if i[0] in k:\n                            r[package_name][v_locale][k[i[0]]] = i[1]\n                except KeyError:\n                    pass\n\n        self._resolved_strings = r\n        return r\n\n    def get_res_configs(\n        self,\n        rid: int,\n        config: Union[ARSCResTableConfig, None] = None,\n        fallback: bool = True,\n    ) -&gt; list[ARSCResTableConfig]:\n        \"\"\"\n        Return the resources found with the ID `rid` and select\n        the right one based on the configuration, or return all if no configuration was set.\n\n        But we try to be generous here and at least try to resolve something:\n        This method uses a fallback to return at least one resource (the first one in the list)\n        if more than one items are found and the default config is used and no default entry could be found.\n\n        This is usually a bad sign (i.e. the developer did not follow the android documentation:\n        &lt;https://developer.android.com/guide/topics/resources/localization.html#failing2)&gt;\n        In practise an app might just be designed to run on a single locale and thus only has those locales set.\n\n        You can disable this fallback behaviour, to just return exactly the given result.\n\n        :param rid: resource id as int\n        :param config: a config to resolve from, or None to get all results\n        :param fallback: Enable the fallback for resolving default configuration (default: True)\n        :return: a list of `ARSCResTableConfig`\n        \"\"\"\n        self._analyse()\n\n        if not rid:\n            raise ValueError(\"'rid' should be set\")\n        if not isinstance(rid, int):\n            raise ValueError(\"'rid' must be an int\")\n\n        if rid not in self.resource_values:\n            logger.warning(\n                \"The requested rid '0x{:08x}' could not be found in the list of resources.\".format(\n                    rid\n                )\n            )\n            return []\n\n        res_options = self.resource_values[rid]\n        if len(res_options) &gt; 1 and config:\n            if config in res_options:\n                return [(config, res_options[config])]\n            elif fallback and config == ARSCResTableConfig.default_config():\n                logger.warning(\n                    \"No default resource config could be found for the given rid '0x{:08x}', using fallback!\".format(\n                        rid\n                    )\n                )\n                return [list(self.resource_values[rid].items())[0]]\n            else:\n                return []\n        else:\n            return list(res_options.items())\n\n    def get_string(\n        self, package_name: str, name: str, locale: str = '\\x00\\x00'\n    ) -&gt; Union[str, None]:\n        self._analyse()\n\n        try:\n            for i in self.values[package_name][locale][\"string\"]:\n                if i[0] == name:\n                    return i\n        except KeyError:\n            return None\n\n    def get_res_id_by_key(self, package_name, resource_type, key):\n        try:\n            return self.resource_keys[package_name][resource_type][key]\n        except KeyError:\n            return None\n\n    def get_items(self, package_name):\n        self._analyse()\n        return self.packages[package_name]\n\n    def get_type_configs(self, package_name, type_name=None):\n        if package_name is None:\n            package_name = self.get_packages_names()[0]\n        result = collections.defaultdict(list)\n\n        for res_type, configs in list(\n            self.resource_configs[package_name].items()\n        ):\n            if res_type.get_package_name() == package_name and (\n                type_name is None or res_type.get_type() == type_name\n            ):\n                result[res_type.get_type()].extend(configs)\n\n        return result\n\n    @staticmethod\n    def parse_id(name: str) -&gt; tuple[str, str]:\n        \"\"\"\n        Resolves an id from a binary XML file in the form `@[package:]DEADBEEF`\n        and returns a tuple of package name and resource id.\n        If no package name was given, i.e. the ID has the form `@DEADBEEF`,\n        the package name is set to None.\n\n        :raises ValueError: if the id is malformed.\n\n        :param name: the string of the resource, as in the binary XML file\n        :return: a tuple of (resource_id, package_name).\n        \"\"\"\n\n        if not name.startswith('@'):\n            raise ValueError(\n                \"Not a valid resource ID, must start with @: '{}'\".format(name)\n            )\n\n        # remove @\n        name = name[1:]\n\n        package = None\n        if ':' in name:\n            package, res_id = name.split(':', 1)\n        else:\n            res_id = name\n\n        if len(res_id) != 8:\n            raise ValueError(\n                \"Numerical ID is not 8 characters long: '{}'\".format(res_id)\n            )\n\n        try:\n            return int(res_id, 16), package\n        except ValueError:\n            raise ValueError(\"ID is not a hex ID: '{}'\".format(res_id))\n\n    def get_resource_xml_name(\n        self, r_id: int, package: Union[str, None] = None\n    ) -&gt; str:\n        \"\"\"\n        Returns the XML name for a resource, including the package name if package is `None`.\n        A full name might look like `@com.example:string/foobar`\n        Otherwise the name is only looked up in the specified package and is returned without\n        the package name.\n        The same example from about without the package name will read as `@string/foobar`.\n\n        If the ID could not be found, `None` is returned.\n\n        A description of the XML name can be found here:\n        &lt;https://developer.android.com/guide/topics/resources/providing-resources#ResourcesFromXml&gt;\n\n        :param r_id: numerical ID if the resource\n        :param package: package name\n        :return: XML name identifier\n        \"\"\"\n        if package:\n            resource, name, i_id = self.get_id(package, r_id)\n            if not i_id:\n                return None\n            return \"@{}/{}\".format(resource, name)\n        else:\n            for p in self.get_packages_names():\n                r, n, i_id = self.get_id(p, r_id)\n                if i_id:\n                    # found the resource in this package\n                    package = p\n                    resource = r\n                    name = n\n                    break\n            if not package:\n                return None\n            else:\n                return \"@{}:{}/{}\".format(package, resource, name)\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCParser.ResourceResolver","title":"<code>ResourceResolver</code>","text":"<p>Resolves resources by ID and configuration. This resolver deals with complex resources as well as with references.</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>class ResourceResolver:\n    \"\"\"\n    Resolves resources by ID and configuration.\n    This resolver deals with complex resources as well as with references.\n    \"\"\"\n\n    def __init__(\n        self,\n        android_resources: ARSCParser,\n        config: Union[ARSCResTableConfig, None] = None,\n    ) -&gt; None:\n        \"\"\"\n        :param ARSCParser android_resources: A resource parser\n        :param ARSCResTableConfig config: The desired configuration or None to resolve all.\n        \"\"\"\n        self.resources = android_resources\n        self.wanted_config = config\n\n    def resolve(self, res_id: int) -&gt; list[tuple[ARSCResTableConfig, str]]:\n        \"\"\"\n        the given ID into the Resource and returns a list of matching resources.\n\n        :param int res_id: numerical ID of the resource\n        :returns: a list of tuples of (ARSCResTableConfig, str)\n        \"\"\"\n        result = []\n        self._resolve_into_result(result, res_id, self.wanted_config)\n        return result\n\n    def _resolve_into_result(self, result, res_id, config):\n        # First: Get all candidates\n        configs = self.resources.get_res_configs(res_id, config)\n\n        for config, ate in configs:\n            # deconstruct them and check if more candidates are generated\n            self.put_ate_value(result, ate, config)\n\n    def put_ate_value(\n        self,\n        result: list,\n        ate: ARSCResTableEntry,\n        config: ARSCResTableConfig,\n    ) -&gt; None:\n        \"\"\"\n        Put a [ARSCResTableEntry][androguard.core.axml.ARSCResTableEntry] into the list of results\n        :param result: results array\n        :param ate:\n        :param config:\n        \"\"\"\n        if ate.is_complex():\n            complex_array = []\n            result.append((config, complex_array))\n            for _, item in ate.item.items:\n                self.put_item_value(\n                    complex_array, item, config, ate, complex_=True\n                )\n        elif ate.is_compact():\n            self.put_item_value(\n                result,\n                ate.data,\n                config,\n                ate,\n                complex_=False,\n                compact_=True,\n            )\n        else:\n            self.put_item_value(\n                result, ate.key, config, ate, complex_=False\n            )\n\n    def put_item_value(\n        self,\n        result: list,\n        item: Union[ARSCResStringPoolRef, int],\n        config: ARSCResTableConfig,\n        parent: ARSCResTableEntry,\n        complex_: bool,\n        compact_: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Put the tuple ([ARSCResTableConfig][androguard.core.axml.ARSCResTableConfig], resolved string) into the result set\n\n        :param result: the result set\n        :param item:\n        :param config:\n        :param parent: the originating entry\n        :param complex_: True if the originating `ARSCResTableEntry` was complex\n        :param bool compact_: True if the originating `ARSCResTableEntry` was compact\n        \"\"\"\n        if isinstance(item, ARSCResStringPoolRef):\n            if item.is_reference():\n                res_id = item.get_data()\n                if res_id:\n                    # Infinite loop detection:\n                    # TODO should this stay here or should be detect the loop much earlier?\n                    if res_id == parent.mResId:\n                        logger.warning(\n                            \"Infinite loop detected at resource item {}. It references itself!\".format(\n                                parent\n                            )\n                        )\n                        return\n\n                    self._resolve_into_result(\n                        result, item.get_data(), self.wanted_config\n                    )\n            else:\n                if complex_:\n                    result.append(item.format_value())\n                else:\n                    result.append((config, item.format_value()))\n        else:\n            if compact_:\n                result.append(\n                    (config, parent.parent.stringpool_main.getString(item))\n                )\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCParser.ResourceResolver.__init__","title":"<code>__init__(android_resources, config=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>android_resources</code> <code>ARSCParser</code> <p>A resource parser</p> required <code>config</code> <code>ARSCResTableConfig</code> <p>The desired configuration or None to resolve all.</p> <code>None</code> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def __init__(\n    self,\n    android_resources: ARSCParser,\n    config: Union[ARSCResTableConfig, None] = None,\n) -&gt; None:\n    \"\"\"\n    :param ARSCParser android_resources: A resource parser\n    :param ARSCResTableConfig config: The desired configuration or None to resolve all.\n    \"\"\"\n    self.resources = android_resources\n    self.wanted_config = config\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCParser.ResourceResolver.put_ate_value","title":"<code>put_ate_value(result, ate, config)</code>","text":"<p>Put a ARSCResTableEntry into the list of results</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>list</code> <p>results array</p> required <code>ate</code> <code>ARSCResTableEntry</code> required <code>config</code> <code>ARSCResTableConfig</code> required Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def put_ate_value(\n    self,\n    result: list,\n    ate: ARSCResTableEntry,\n    config: ARSCResTableConfig,\n) -&gt; None:\n    \"\"\"\n    Put a [ARSCResTableEntry][androguard.core.axml.ARSCResTableEntry] into the list of results\n    :param result: results array\n    :param ate:\n    :param config:\n    \"\"\"\n    if ate.is_complex():\n        complex_array = []\n        result.append((config, complex_array))\n        for _, item in ate.item.items:\n            self.put_item_value(\n                complex_array, item, config, ate, complex_=True\n            )\n    elif ate.is_compact():\n        self.put_item_value(\n            result,\n            ate.data,\n            config,\n            ate,\n            complex_=False,\n            compact_=True,\n        )\n    else:\n        self.put_item_value(\n            result, ate.key, config, ate, complex_=False\n        )\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCParser.ResourceResolver.put_item_value","title":"<code>put_item_value(result, item, config, parent, complex_, compact_=False)</code>","text":"<p>Put the tuple (ARSCResTableConfig, resolved string) into the result set</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>list</code> <p>the result set</p> required <code>item</code> <code>Union[ARSCResStringPoolRef, int]</code> required <code>config</code> <code>ARSCResTableConfig</code> required <code>parent</code> <code>ARSCResTableEntry</code> <p>the originating entry</p> required <code>complex_</code> <code>bool</code> <p>True if the originating <code>ARSCResTableEntry</code> was complex</p> required <code>compact_</code> <code>bool</code> <p>True if the originating <code>ARSCResTableEntry</code> was compact</p> <code>False</code> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def put_item_value(\n    self,\n    result: list,\n    item: Union[ARSCResStringPoolRef, int],\n    config: ARSCResTableConfig,\n    parent: ARSCResTableEntry,\n    complex_: bool,\n    compact_: bool = False,\n) -&gt; None:\n    \"\"\"\n    Put the tuple ([ARSCResTableConfig][androguard.core.axml.ARSCResTableConfig], resolved string) into the result set\n\n    :param result: the result set\n    :param item:\n    :param config:\n    :param parent: the originating entry\n    :param complex_: True if the originating `ARSCResTableEntry` was complex\n    :param bool compact_: True if the originating `ARSCResTableEntry` was compact\n    \"\"\"\n    if isinstance(item, ARSCResStringPoolRef):\n        if item.is_reference():\n            res_id = item.get_data()\n            if res_id:\n                # Infinite loop detection:\n                # TODO should this stay here or should be detect the loop much earlier?\n                if res_id == parent.mResId:\n                    logger.warning(\n                        \"Infinite loop detected at resource item {}. It references itself!\".format(\n                            parent\n                        )\n                    )\n                    return\n\n                self._resolve_into_result(\n                    result, item.get_data(), self.wanted_config\n                )\n        else:\n            if complex_:\n                result.append(item.format_value())\n            else:\n                result.append((config, item.format_value()))\n    else:\n        if compact_:\n            result.append(\n                (config, parent.parent.stringpool_main.getString(item))\n            )\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCParser.ResourceResolver.resolve","title":"<code>resolve(res_id)</code>","text":"<p>the given ID into the Resource and returns a list of matching resources.</p> <p>Parameters:</p> Name Type Description Default <code>res_id</code> <code>int</code> <p>numerical ID of the resource</p> required <p>Returns:</p> Type Description <code>list[tuple[ARSCResTableConfig, str]]</code> <p>a list of tuples of (ARSCResTableConfig, str)</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def resolve(self, res_id: int) -&gt; list[tuple[ARSCResTableConfig, str]]:\n    \"\"\"\n    the given ID into the Resource and returns a list of matching resources.\n\n    :param int res_id: numerical ID of the resource\n    :returns: a list of tuples of (ARSCResTableConfig, str)\n    \"\"\"\n    result = []\n    self._resolve_into_result(result, res_id, self.wanted_config)\n    return result\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCParser.__init__","title":"<code>__init__(raw_buff)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>raw_buff</code> <code>bytes</code> <p>the raw bytes of the file</p> required Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def __init__(self, raw_buff: bytes) -&gt; None:\n    \"\"\"\n    :param bytes raw_buff: the raw bytes of the file\n    \"\"\"\n    self.buff = io.BufferedReader(io.BytesIO(raw_buff))\n    self.buff_size = self.buff.raw.getbuffer().nbytes\n\n    if self.buff_size &lt; 8 or self.buff_size &gt; 0xFFFFFFFF:\n        raise ResParserError(\n            \"Invalid file size {} for a resources.arsc file!\".format(\n                self.buff_size\n            )\n        )\n\n    self.analyzed = False\n    self._resolved_strings = None\n    self.packages = defaultdict(list)\n    self.values = {}\n    self.resource_values = defaultdict(defaultdict)\n    self.resource_configs = defaultdict(lambda: defaultdict(set))\n    self.resource_keys = defaultdict(lambda: defaultdict(defaultdict))\n    self.stringpool_main = None\n\n    # First, there is a ResTable_header.\n    self.header = ARSCHeader(self.buff, expected_type=RES_TABLE_TYPE)\n\n    # More sanity checks...\n    if self.header.header_size != 12:\n        logger.warning(\n            \"The ResTable_header has an unexpected header size! Expected 12 bytes, got {}.\".format(\n                self.header.header_size\n            )\n        )\n\n    if self.header.size &gt; self.buff_size:\n        raise ResParserError(\n            \"The file seems to be truncated. Refuse to parse the file! Filesize: {}, declared size: {}\".format(\n                self.buff_size, self.header.size\n            )\n        )\n\n    if self.header.size &lt; self.buff_size:\n        logger.warning(\n            \"The Resource file seems to have data appended to it. Filesize: {}, declared size: {}\".format(\n                self.buff_size, self.header.size\n            )\n        )\n\n    # The ResTable_header contains the packageCount, i.e. the number of ResTable_package\n    self.packageCount = unpack('&lt;I', self.buff.read(4))[0]\n\n    # Even more sanity checks...\n    if self.packageCount &lt; 1:\n        logger.warning(\n            \"The number of packages is smaller than one. There should be at least one package!\"\n        )\n\n    logger.debug(\n        \"Parsed ResTable_header with {} package(s) inside.\".format(\n            self.packageCount\n        )\n    )\n\n    # skip to the start of the first chunk's data, skipping trailing header bytes (there should be none)\n    self.buff.seek(self.header.start + self.header.header_size)\n\n    # Now parse the data:\n    # We should find one ResStringPool_header and one or more ResTable_package chunks inside\n    while self.buff.tell() &lt;= self.header.end - ARSCHeader.SIZE:\n        res_header = ARSCHeader(self.buff)\n\n        if res_header.end &gt; self.header.end:\n            # this inner chunk crosses the boundary of the table chunk\n            logger.warning(\n                \"Invalid chunk found! It is larger than the outer chunk: %s\",\n                res_header,\n            )\n            break\n\n        if res_header.type == RES_STRING_POOL_TYPE:\n            # There should be only one StringPool per resource table.\n            if self.stringpool_main:\n                logger.warning(\n                    \"Already found a ResStringPool_header, but there should be only one! Will not parse the Pool again.\"\n                )\n            else:\n                self.stringpool_main = StringBlock(self.buff, res_header)\n                logger.debug(\n                    \"Found the main string pool: %s\", self.stringpool_main\n                )\n\n        elif res_header.type == RES_TABLE_PACKAGE_TYPE:\n            if len(self.packages) &gt; self.packageCount:\n                raise ResParserError(\n                    \"Got more packages ({}) than expected ({})\".format(\n                        len(self.packages), self.packageCount\n                    )\n                )\n\n            current_package = ARSCResTablePackage(self.buff, res_header)\n            package_name = current_package.get_name()\n\n            # After the Header, we have the resource type symbol table\n            self.buff.seek(\n                current_package.header.start + current_package.typeStrings\n            )\n            type_sp_header = ARSCHeader(\n                self.buff, expected_type=RES_STRING_POOL_TYPE\n            )\n            mTableStrings = StringBlock(self.buff, type_sp_header)\n\n            # Next, we should have the resource key symbol table\n            self.buff.seek(\n                current_package.header.start + current_package.keyStrings\n            )\n            key_sp_header = ARSCHeader(\n                self.buff, expected_type=RES_STRING_POOL_TYPE\n            )\n            mKeyStrings = StringBlock(self.buff, key_sp_header)\n\n            # Add them to the dict of read packages\n            self.packages[package_name].append(current_package)\n            self.packages[package_name].append(mTableStrings)\n            self.packages[package_name].append(mKeyStrings)\n\n            pc = PackageContext(\n                current_package,\n                self.stringpool_main,\n                mTableStrings,\n                mKeyStrings,\n            )\n            logger.debug(\"Constructed a PackageContext: %s\", pc)\n\n            # skip to the first header in this table package chunk\n            # FIXME is this correct? We have already read the first two sections!\n            # self.buff.set_idx(res_header.start + res_header.header_size)\n            # this looks more like we want: (???)\n            # FIXME it looks like that the two string pools we have read might not be concatenated to each other,\n            # thus jumping to the sum of the sizes might not be correct...\n            next_idx = (\n                res_header.start\n                + res_header.header_size\n                + type_sp_header.size\n                + key_sp_header.size\n            )\n\n            if next_idx != self.buff.tell():\n                # If this happens, we have a testfile ;)\n                logger.error(\"This looks like an odd resources.arsc file!\")\n                logger.error(\n                    \"Please report this error including the file you have parsed!\"\n                )\n                logger.error(\n                    \"next_idx = {}, current buffer position = {}\".format(\n                        next_idx, self.buff.tell()\n                    )\n                )\n                logger.error(\n                    \"Please open a issue at https://github.com/androguard/androguard/issues\"\n                )\n                logger.error(\"Thank you!\")\n\n            self.buff.seek(next_idx)\n\n            # Read all other headers\n            while self.buff.tell() &lt;= res_header.end - ARSCHeader.SIZE:\n                pkg_chunk_header = ARSCHeader(self.buff)\n                logger.debug(\"Found a header: {}\".format(pkg_chunk_header))\n                if (\n                    pkg_chunk_header.start + pkg_chunk_header.size\n                    &gt; res_header.end\n                ):\n                    # we are way off the package chunk; bail out\n                    break\n\n                self.packages[package_name].append(pkg_chunk_header)\n\n                if pkg_chunk_header.type == RES_TABLE_TYPE_SPEC_TYPE:\n                    self.packages[package_name].append(\n                        ARSCResTypeSpec(self.buff, pc)\n                    )\n\n                elif pkg_chunk_header.type == RES_TABLE_TYPE_TYPE:\n                    # Parse a RES_TABLE_TYPE\n                    # http://androidxref.com/9.0.0_r3/xref/frameworks/base/tools/aapt2/format/binary/BinaryResourceParser.cpp#311\n                    start_of_chunk = self.buff.tell() - 8\n                    expected_end_of_chunk = (\n                        start_of_chunk + pkg_chunk_header.size\n                    )\n                    a_res_type = ARSCResType(self.buff, pc)\n                    self.packages[package_name].append(a_res_type)\n                    self.resource_configs[package_name][a_res_type].add(\n                        a_res_type.config\n                    )\n\n                    logger.debug(\"Config: {}\".format(a_res_type.config))\n\n                    entries = []\n                    FLAG_OFFSET16 = 0x02\n                    NO_ENTRY_16 = 0xFFFF\n                    NO_ENTRY_32 = 0xFFFFFFFF\n                    expected_entries_start = (\n                        start_of_chunk + a_res_type.entriesStart\n                    )\n\n                    # Helper function to convert 16-bit offset to 32-bit\n                    def offset_from16(off16):\n                        return (\n                            NO_ENTRY_16\n                            if off16 == NO_ENTRY_16\n                            else off16 * 4\n                        )\n\n                    for i in range(0, a_res_type.entryCount):\n                        current_package.mResId = (\n                            current_package.mResId &amp; 0xFFFF0000 | i\n                        )\n                        # Check if FLAG_OFFSET16 is set\n                        if a_res_type.flags &amp; FLAG_OFFSET16:\n                            # Read as 16-bit offset\n                            offset_16 = unpack('&lt;H', self.buff.read(2))[0]\n                            offset = offset_from16(offset_16)\n                            if offset == NO_ENTRY_16:\n                                continue\n                        else:\n                            # Read as 32-bit offset\n                            offset = unpack('&lt;I', self.buff.read(4))[0]\n                            if offset == NO_ENTRY_32:\n                                continue\n                        entries.append((offset, current_package.mResId))\n\n                    self.packages[package_name].append(entries)\n\n                    base_offset = self.buff.tell()\n                    if base_offset + ((4 - (base_offset % 4)) % 4) != expected_entries_start:\n                        # FIXME: seems like I am missing 2 bytes here in some cases, though it does not affect the result\n                        logger.warning(\n                            \"Something is off here! We are not where the entries should start.\"\n                        )\n                    base_offset = expected_entries_start\n                    for entry_offset, res_id in entries:\n                        if entry_offset != -1:\n                            ate = ARSCResTableEntry(\n                                self.buff,\n                                base_offset + entry_offset,\n                                expected_end_of_chunk,\n                                res_id,\n                                pc,\n                            )\n                            self.packages[package_name].append(ate)\n                            if ate.is_weak():\n                                # FIXME we are not sure how to implement the FLAG_WEAK!\n                                # We saw the following: There is just a single Res_value after the ARSCResTableEntry\n                                # and then comes the next ARSCHeader.\n                                # Therefore we think this means all entries are somehow replicated?\n                                # So we do some kind of hack here. We set the idx to the entry again...\n                                # Now we will read all entries!\n                                # Not sure if this is a good solution though\n                                self.buff.seek(ate.start)\n                elif pkg_chunk_header.type == RES_TABLE_LIBRARY_TYPE:\n                    logger.warning(\n                        \"RES_TABLE_LIBRARY_TYPE chunk is not supported\"\n                    )\n                else:\n                    # Unknown / not-handled chunk type\n                    logger.warning(\n                        \"Unknown chunk type encountered inside RES_TABLE_PACKAGE: %s\",\n                        pkg_chunk_header,\n                    )\n\n                # skip to the next chunk\n                self.buff.seek(pkg_chunk_header.end)\n        else:\n            # Unknown / not-handled chunk type\n            logger.warning(\n                \"Unknown chunk type encountered: %s\", res_header\n            )\n\n        # move to the next resource chunk\n        self.buff.seek(res_header.end)\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCParser.get_bool_resources","title":"<code>get_bool_resources(package_name, locale='\\x00\\x00')</code>","text":"<p>Get the XML (as string) of all resources of type 'bool'.</p> <p>Read more about bool resources: https://developer.android.com/guide/topics/resources/more-resources.html#Bool</p> <p>Parameters:</p> Name Type Description Default <code>package_name</code> <code>str</code> <p>the package name to get the resources for</p> required <code>locale</code> <code>str</code> <p>the locale to get the resources for (default: '\u0000\u0000')</p> <code>'\\x00\\x00'</code> <p>Returns:</p> Type Description <code>bytes</code> <p>the bool resources xml bytes</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def get_bool_resources(\n    self, package_name: str, locale: str = '\\x00\\x00'\n) -&gt; bytes:\n    \"\"\"\n    Get the XML (as string) of all resources of type 'bool'.\n\n    Read more about bool resources:\n    &lt;https://developer.android.com/guide/topics/resources/more-resources.html#Bool&gt;\n\n    :param package_name: the package name to get the resources for\n    :param locale: the locale to get the resources for (default: '\\x00\\x00')\n\n    :returns: the bool resources xml bytes\n    \"\"\"\n    self._analyse()\n\n    buff = '&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\\n'\n    buff += '&lt;resources&gt;\\n'\n\n    try:\n        for i in self.values[package_name][locale][\"bool\"]:\n            buff += '&lt;bool name=\"{}\"&gt;{}&lt;/bool&gt;\\n'.format(i[0], i[1])\n    except KeyError:\n        pass\n\n    buff += '&lt;/resources&gt;\\n'\n\n    return buff.encode('utf-8')\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCParser.get_color_resources","title":"<code>get_color_resources(package_name, locale='\\x00\\x00')</code>","text":"<p>Get the XML (as string) of all resources of type 'color'.</p> <p>Read more about color resources: https://developer.android.com/guide/topics/resources/more-resources.html#Color</p> <p>Parameters:</p> Name Type Description Default <code>package_name</code> <code>str</code> <p>the package name to get the resources for</p> required <code>locale</code> <code>str</code> <p>the locale to get the resources for (default: '\u0000\u0000')</p> <code>'\\x00\\x00'</code> <p>Returns:</p> Type Description <code>bytes</code> <p>the color resources xml bytes</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def get_color_resources(\n    self, package_name: str, locale: str = '\\x00\\x00'\n) -&gt; bytes:\n    \"\"\"\n    Get the XML (as string) of all resources of type 'color'.\n\n    Read more about color resources:\n    &lt;https://developer.android.com/guide/topics/resources/more-resources.html#Color&gt;\n\n    :param package_name: the package name to get the resources for\n    :param locale: the locale to get the resources for (default: '\\x00\\x00')\n\n    :returns: the color resources xml bytes\n    \"\"\"\n    self._analyse()\n\n    buff = '&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\\n'\n    buff += '&lt;resources&gt;\\n'\n\n    try:\n        for i in self.values[package_name][locale][\"color\"]:\n            buff += '&lt;color name=\"{}\"&gt;{}&lt;/color&gt;\\n'.format(i[0], i[1])\n    except KeyError:\n        pass\n\n    buff += '&lt;/resources&gt;\\n'\n\n    return buff.encode('utf-8')\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCParser.get_dimen_resources","title":"<code>get_dimen_resources(package_name, locale='\\x00\\x00')</code>","text":"<p>Get the XML (as string) of all resources of type 'dimen'.</p> <p>Read more about Dimension resources: https://developer.android.com/guide/topics/resources/more-resources.html#Dimension</p> <p>Parameters:</p> Name Type Description Default <code>package_name</code> <code>str</code> <p>the package name to get the resources for</p> required <code>locale</code> <code>str</code> <p>the locale to get the resources for (default: '\u0000\u0000')</p> <code>'\\x00\\x00'</code> <p>Returns:</p> Type Description <code>bytes</code> <p>the dimen resource xml bytes</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def get_dimen_resources(\n    self, package_name: str, locale: str = '\\x00\\x00'\n) -&gt; bytes:\n    \"\"\"\n    Get the XML (as string) of all resources of type 'dimen'.\n\n    Read more about Dimension resources:\n    &lt;https://developer.android.com/guide/topics/resources/more-resources.html#Dimension&gt;\n\n    :param package_name: the package name to get the resources for\n    :param locale: the locale to get the resources for (default: '\\x00\\x00')\n\n    :returns: the dimen resource xml bytes\n    \"\"\"\n    self._analyse()\n\n    buff = '&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\\n'\n    buff += '&lt;resources&gt;\\n'\n\n    try:\n        for i in self.values[package_name][locale][\"dimen\"]:\n            buff += '&lt;dimen name=\"{}\"&gt;{}&lt;/dimen&gt;\\n'.format(i[0], i[1])\n    except KeyError:\n        pass\n\n    buff += '&lt;/resources&gt;\\n'\n\n    return buff.encode('utf-8')\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCParser.get_id","title":"<code>get_id(package_name, rid, locale='\\x00\\x00')</code>","text":"<p>Returns the tuple <code>(resource_type, resource_name, resource_id)</code> for the given resource_id.</p> <p>Parameters:</p> Name Type Description Default <code>package_name</code> <code>str</code> <p>package name to query</p> required <code>rid</code> <code>int</code> <p>the resource_id</p> required <code>locale</code> <code>str</code> <p>specific locale</p> <code>'\\x00\\x00'</code> <p>Returns:</p> Type Description <code>tuple</code> <p>tuple of (resource_type, resource_name, resource_id)</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def get_id(\n    self, package_name: str, rid: int, locale: str = '\\x00\\x00'\n) -&gt; tuple:\n    \"\"\"\n    Returns the tuple `(resource_type, resource_name, resource_id)`\n    for the given resource_id.\n\n    :param package_name: package name to query\n    :param rid: the resource_id\n    :param locale: specific locale\n    :returns: tuple of (resource_type, resource_name, resource_id)\n    \"\"\"\n    self._analyse()\n\n    try:\n        for i in self.values[package_name][locale][\"public\"]:\n            if i[2] == rid:\n                return i\n    except KeyError:\n        pass\n    return None, None, None\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCParser.get_id_resources","title":"<code>get_id_resources(package_name, locale='\\x00\\x00')</code>","text":"<p>Get the XML (as string) of all resources of type 'id'.</p> <p>Read more about ID resources: https://developer.android.com/guide/topics/resources/more-resources.html#Id</p> <p>Parameters:</p> Name Type Description Default <code>package_name</code> <code>str</code> <p>the package name to get the resources for</p> required <code>locale</code> <code>str</code> <p>the locale to get the resources for (default: '\u0000\u0000')</p> <code>'\\x00\\x00'</code> <p>Returns:</p> Type Description <code>bytes</code> <p>the id resources xml bytes</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def get_id_resources(\n    self, package_name: str, locale: str = '\\x00\\x00'\n) -&gt; bytes:\n    \"\"\"\n    Get the XML (as string) of all resources of type 'id'.\n\n    Read more about ID resources:\n    &lt;https://developer.android.com/guide/topics/resources/more-resources.html#Id&gt;\n\n    :param package_name: the package name to get the resources for\n    :param locale: the locale to get the resources for (default: '\\x00\\x00')\n\n    :returns: the id resources xml bytes\n    \"\"\"\n    self._analyse()\n\n    buff = '&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\\n'\n    buff += '&lt;resources&gt;\\n'\n\n    try:\n        for i in self.values[package_name][locale][\"id\"]:\n            if len(i) == 1:\n                buff += '&lt;item type=\"id\" name=\"%s\"/&gt;\\n' % (i[0])\n            else:\n                buff += '&lt;item type=\"id\" name=\"{}\"&gt;{}&lt;/item&gt;\\n'.format(\n                    i[0], escape(i[1])\n                )\n    except KeyError:\n        pass\n\n    buff += '&lt;/resources&gt;\\n'\n\n    return buff.encode('utf-8')\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCParser.get_integer_resources","title":"<code>get_integer_resources(package_name, locale='\\x00\\x00')</code>","text":"<p>Get the XML (as string) of all resources of type 'integer'.</p> <p>Read more about integer resources: https://developer.android.com/guide/topics/resources/more-resources.html#Integer</p> <p>Parameters:</p> Name Type Description Default <code>package_name</code> <code>str</code> <p>the package name to get the resources for</p> required <code>locale</code> <code>str</code> <p>the locale to get the resources for (default: '\u0000\u0000')</p> <code>'\\x00\\x00'</code> <p>Returns:</p> Type Description <code>bytes</code> <p>the integer resources xml bytes</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def get_integer_resources(\n    self, package_name: str, locale: str = '\\x00\\x00'\n) -&gt; bytes:\n    \"\"\"\n    Get the XML (as string) of all resources of type 'integer'.\n\n    Read more about integer resources:\n    &lt;https://developer.android.com/guide/topics/resources/more-resources.html#Integer&gt;\n\n    :param package_name: the package name to get the resources for\n    :param locale: the locale to get the resources for (default: '\\x00\\x00')\n\n    :returns: the integer resources xml bytes\n    \"\"\"\n    self._analyse()\n\n    buff = '&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\\n'\n    buff += '&lt;resources&gt;\\n'\n\n    try:\n        for i in self.values[package_name][locale][\"integer\"]:\n            buff += '&lt;integer name=\"{}\"&gt;{}&lt;/integer&gt;\\n'.format(i[0], i[1])\n    except KeyError:\n        pass\n\n    buff += '&lt;/resources&gt;\\n'\n\n    return buff.encode('utf-8')\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCParser.get_locales","title":"<code>get_locales(package_name)</code>","text":"<p>Retrieve a list of all available locales in a given packagename.</p> <p>Parameters:</p> Name Type Description Default <code>package_name</code> <code>str</code> <p>the package name to get locales of</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>a list of locale strings</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def get_locales(self, package_name: str) -&gt; list[str]:\n    \"\"\"\n    Retrieve a list of all available locales in a given packagename.\n\n    :param package_name: the package name to get locales of\n    :returns: a list of locale strings\n    \"\"\"\n    self._analyse()\n    return list(self.values[package_name].keys())\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCParser.get_packages_names","title":"<code>get_packages_names()</code>","text":"<p>Retrieve a list of all package names, which are available in the given resources.arsc.</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def get_packages_names(self) -&gt; list[str]:\n    \"\"\"\n    Retrieve a list of all package names, which are available\n    in the given resources.arsc.\n    \"\"\"\n    return list(self.packages.keys())\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCParser.get_public_resources","title":"<code>get_public_resources(package_name, locale='\\x00\\x00')</code>","text":"<p>Get the XML (as string) of all resources of type 'public'.</p> <p>The public resources table contains the IDs for each item.</p> <p>Parameters:</p> Name Type Description Default <code>package_name</code> <code>str</code> <p>the package name to get the resources for</p> required <code>locale</code> <code>str</code> <p>the locale to get the resources for (default: '\u0000\u0000')</p> <code>'\\x00\\x00'</code> <p>Returns:</p> Type Description <code>bytes</code> <p>the public xml bytes</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def get_public_resources(\n    self, package_name: str, locale: str = '\\x00\\x00'\n) -&gt; bytes:\n    \"\"\"\n    Get the XML (as string) of all resources of type 'public'.\n\n    The public resources table contains the IDs for each item.\n\n    :param package_name: the package name to get the resources for\n    :param locale: the locale to get the resources for (default: '\\x00\\x00')\n    :returns: the public xml bytes\n    \"\"\"\n\n    self._analyse()\n\n    buff = '&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\\n'\n    buff += '&lt;resources&gt;\\n'\n\n    try:\n        for i in self.values[package_name][locale][\"public\"]:\n            buff += (\n                '&lt;public type=\"{}\" name=\"{}\" id=\"0x{:08x}\" /&gt;\\n'.format(\n                    i[0], i[1], i[2]\n                )\n            )\n    except KeyError:\n        pass\n\n    buff += '&lt;/resources&gt;\\n'\n\n    return buff.encode('utf-8')\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCParser.get_res_configs","title":"<code>get_res_configs(rid, config=None, fallback=True)</code>","text":"<p>Return the resources found with the ID <code>rid</code> and select the right one based on the configuration, or return all if no configuration was set.</p> <p>But we try to be generous here and at least try to resolve something: This method uses a fallback to return at least one resource (the first one in the list) if more than one items are found and the default config is used and no default entry could be found.</p> <p>This is usually a bad sign (i.e. the developer did not follow the android documentation: https://developer.android.com/guide/topics/resources/localization.html#failing2) In practise an app might just be designed to run on a single locale and thus only has those locales set.</p> <p>You can disable this fallback behaviour, to just return exactly the given result.</p> <p>Parameters:</p> Name Type Description Default <code>rid</code> <code>int</code> <p>resource id as int</p> required <code>config</code> <code>Union[ARSCResTableConfig, None]</code> <p>a config to resolve from, or None to get all results</p> <code>None</code> <code>fallback</code> <code>bool</code> <p>Enable the fallback for resolving default configuration (default: True)</p> <code>True</code> <p>Returns:</p> Type Description <code>list[ARSCResTableConfig]</code> <p>a list of <code>ARSCResTableConfig</code></p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def get_res_configs(\n    self,\n    rid: int,\n    config: Union[ARSCResTableConfig, None] = None,\n    fallback: bool = True,\n) -&gt; list[ARSCResTableConfig]:\n    \"\"\"\n    Return the resources found with the ID `rid` and select\n    the right one based on the configuration, or return all if no configuration was set.\n\n    But we try to be generous here and at least try to resolve something:\n    This method uses a fallback to return at least one resource (the first one in the list)\n    if more than one items are found and the default config is used and no default entry could be found.\n\n    This is usually a bad sign (i.e. the developer did not follow the android documentation:\n    &lt;https://developer.android.com/guide/topics/resources/localization.html#failing2)&gt;\n    In practise an app might just be designed to run on a single locale and thus only has those locales set.\n\n    You can disable this fallback behaviour, to just return exactly the given result.\n\n    :param rid: resource id as int\n    :param config: a config to resolve from, or None to get all results\n    :param fallback: Enable the fallback for resolving default configuration (default: True)\n    :return: a list of `ARSCResTableConfig`\n    \"\"\"\n    self._analyse()\n\n    if not rid:\n        raise ValueError(\"'rid' should be set\")\n    if not isinstance(rid, int):\n        raise ValueError(\"'rid' must be an int\")\n\n    if rid not in self.resource_values:\n        logger.warning(\n            \"The requested rid '0x{:08x}' could not be found in the list of resources.\".format(\n                rid\n            )\n        )\n        return []\n\n    res_options = self.resource_values[rid]\n    if len(res_options) &gt; 1 and config:\n        if config in res_options:\n            return [(config, res_options[config])]\n        elif fallback and config == ARSCResTableConfig.default_config():\n            logger.warning(\n                \"No default resource config could be found for the given rid '0x{:08x}', using fallback!\".format(\n                    rid\n                )\n            )\n            return [list(self.resource_values[rid].items())[0]]\n        else:\n            return []\n    else:\n        return list(res_options.items())\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCParser.get_resolved_res_configs","title":"<code>get_resolved_res_configs(rid, config=None)</code>","text":"<p>Return a list of resolved resource IDs with their corresponding configuration. It has a similar return type as get_res_configs but also handles complex entries and references. Also instead of returning ARSCResTableConfig in the tuple, the actual values are resolved.</p> <p>This is the preferred way of resolving resource IDs to their resources.</p> <p>Parameters:</p> Name Type Description Default <code>rid</code> <code>int</code> <p>the numerical ID of the resource</p> required <code>config</code> <code>Union[ARSCResTableConfig, None]</code> <p>the desired configuration or None to retrieve all</p> <code>None</code> <p>Returns:</p> Type Description <code>list[tuple[ARSCResTableConfig, str]]</code> <p>A list of tuples of (<code>ARSCResTableConfig</code>, str)</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def get_resolved_res_configs(\n    self, rid: int, config: Union[ARSCResTableConfig, None] = None\n) -&gt; list[tuple[ARSCResTableConfig, str]]:\n    \"\"\"\n    Return a list of resolved resource IDs with their corresponding configuration.\n    It has a similar return type as [get_res_configs][androguard.core.axml.ARSCParser.get_res_configs] but also handles complex entries\n    and references.\n    Also instead of returning [ARSCResTableConfig][androguard.core.axml.ARSCResTableConfig] in the tuple, the actual values are resolved.\n\n    This is the preferred way of resolving resource IDs to their resources.\n\n    :param rid: the numerical ID of the resource\n    :param config: the desired configuration or None to retrieve all\n    :return: A list of tuples of (`ARSCResTableConfig`, str)\n    \"\"\"\n    resolver = ARSCParser.ResourceResolver(self, config)\n    return resolver.resolve(rid)\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCParser.get_resource_xml_name","title":"<code>get_resource_xml_name(r_id, package=None)</code>","text":"<p>Returns the XML name for a resource, including the package name if package is <code>None</code>. A full name might look like <code>@com.example:string/foobar</code> Otherwise the name is only looked up in the specified package and is returned without the package name. The same example from about without the package name will read as <code>@string/foobar</code>.</p> <p>If the ID could not be found, <code>None</code> is returned.</p> <p>A description of the XML name can be found here: https://developer.android.com/guide/topics/resources/providing-resources#ResourcesFromXml</p> <p>Parameters:</p> Name Type Description Default <code>r_id</code> <code>int</code> <p>numerical ID if the resource</p> required <code>package</code> <code>Union[str, None]</code> <p>package name</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>XML name identifier</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def get_resource_xml_name(\n    self, r_id: int, package: Union[str, None] = None\n) -&gt; str:\n    \"\"\"\n    Returns the XML name for a resource, including the package name if package is `None`.\n    A full name might look like `@com.example:string/foobar`\n    Otherwise the name is only looked up in the specified package and is returned without\n    the package name.\n    The same example from about without the package name will read as `@string/foobar`.\n\n    If the ID could not be found, `None` is returned.\n\n    A description of the XML name can be found here:\n    &lt;https://developer.android.com/guide/topics/resources/providing-resources#ResourcesFromXml&gt;\n\n    :param r_id: numerical ID if the resource\n    :param package: package name\n    :return: XML name identifier\n    \"\"\"\n    if package:\n        resource, name, i_id = self.get_id(package, r_id)\n        if not i_id:\n            return None\n        return \"@{}/{}\".format(resource, name)\n    else:\n        for p in self.get_packages_names():\n            r, n, i_id = self.get_id(p, r_id)\n            if i_id:\n                # found the resource in this package\n                package = p\n                resource = r\n                name = n\n                break\n        if not package:\n            return None\n        else:\n            return \"@{}:{}/{}\".format(package, resource, name)\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCParser.get_string_resources","title":"<code>get_string_resources(package_name, locale='\\x00\\x00')</code>","text":"<p>Get the XML (as string) of all resources of type 'string'.</p> <p>Read more about string resources: https://developer.android.com/guide/topics/resources/string-resource.html</p> <p>Parameters:</p> Name Type Description Default <code>package_name</code> <code>str</code> <p>the package name to get the resources for</p> required <code>locale</code> <code>str</code> <p>the locale to get the resources for (default: '\u0000\u0000')</p> <code>'\\x00\\x00'</code> <p>Returns:</p> Type Description <code>bytes</code> <p>the string xml bytes</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def get_string_resources(\n    self, package_name: str, locale: str = '\\x00\\x00'\n) -&gt; bytes:\n    \"\"\"\n    Get the XML (as string) of all resources of type 'string'.\n\n    Read more about string resources:\n    &lt;https://developer.android.com/guide/topics/resources/string-resource.html&gt;\n\n    :param package_name: the package name to get the resources for\n    :param locale: the locale to get the resources for (default: '\\x00\\x00')\n    :returns: the string xml bytes\n    \"\"\"\n    self._analyse()\n\n    buff = '&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\\n'\n    buff += '&lt;resources&gt;\\n'\n\n    try:\n        for i in self.values[package_name][locale][\"string\"]:\n            if any(map(i[1].__contains__, '&lt;&amp;&gt;')):\n                value = '&lt;![CDATA[%s]]&gt;' % i[1]\n            else:\n                value = i[1]\n            buff += '&lt;string name=\"{}\"&gt;{}&lt;/string&gt;\\n'.format(i[0], value)\n    except KeyError:\n        pass\n\n    buff += '&lt;/resources&gt;\\n'\n\n    return buff.encode('utf-8')\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCParser.get_strings_resources","title":"<code>get_strings_resources()</code>","text":"<p>Get the XML (as string) of all resources of type 'string'. This is a combined variant, which has all locales and all package names stored.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>the string, locales, and package name xml bytes</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def get_strings_resources(self) -&gt; bytes:\n    \"\"\"\n    Get the XML (as string) of all resources of type 'string'.\n    This is a combined variant, which has all locales and all package names\n    stored.\n\n    :returns: the string, locales, and package name xml bytes\n    \"\"\"\n    self._analyse()\n\n    buff = '&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\\n'\n\n    buff += \"&lt;packages&gt;\\n\"\n    for package_name in self.get_packages_names():\n        buff += \"&lt;package name=\\\"%s\\\"&gt;\\n\" % package_name\n\n        for locale in self.get_locales(package_name):\n            buff += \"&lt;locale value=%s&gt;\\n\" % repr(locale)\n\n            buff += '&lt;resources&gt;\\n'\n            try:\n                for i in self.values[package_name][locale][\"string\"]:\n                    buff += '&lt;string name=\"{}\"&gt;{}&lt;/string&gt;\\n'.format(\n                        i[0], escape(i[1])\n                    )\n            except KeyError:\n                pass\n\n            buff += '&lt;/resources&gt;\\n'\n            buff += '&lt;/locale&gt;\\n'\n\n        buff += \"&lt;/package&gt;\\n\"\n\n    buff += \"&lt;/packages&gt;\\n\"\n\n    return buff.encode('utf-8')\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCParser.get_types","title":"<code>get_types(package_name, locale='\\x00\\x00')</code>","text":"<p>Retrieve a list of all types which are available in the given package and locale.</p> <p>Parameters:</p> Name Type Description Default <code>package_name</code> <code>str</code> <p>the package name to get types of</p> required <code>locale</code> <code>str</code> <p>the locale to get types of (default: '\u0000\u0000')</p> <code>'\\x00\\x00'</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>a list of type strings</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def get_types(\n    self, package_name: str, locale: str = '\\x00\\x00'\n) -&gt; list[str]:\n    \"\"\"\n    Retrieve a list of all types which are available in the given\n    package and locale.\n\n    :param package_name: the package name to get types of\n    :param locale: the locale to get types of (default: '\\x00\\x00')\n    :returns: a list of type strings\n    \"\"\"\n    self._analyse()\n    return list(self.values[package_name][locale].keys())\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCParser.parse_id","title":"<code>parse_id(name)</code>  <code>staticmethod</code>","text":"<p>Resolves an id from a binary XML file in the form <code>@[package:]DEADBEEF</code> and returns a tuple of package name and resource id. If no package name was given, i.e. the ID has the form <code>@DEADBEEF</code>, the package name is set to None.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the string of the resource, as in the binary XML file</p> required <p>Returns:</p> Type Description <code>tuple[str, str]</code> <p>a tuple of (resource_id, package_name).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the id is malformed.</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>@staticmethod\ndef parse_id(name: str) -&gt; tuple[str, str]:\n    \"\"\"\n    Resolves an id from a binary XML file in the form `@[package:]DEADBEEF`\n    and returns a tuple of package name and resource id.\n    If no package name was given, i.e. the ID has the form `@DEADBEEF`,\n    the package name is set to None.\n\n    :raises ValueError: if the id is malformed.\n\n    :param name: the string of the resource, as in the binary XML file\n    :return: a tuple of (resource_id, package_name).\n    \"\"\"\n\n    if not name.startswith('@'):\n        raise ValueError(\n            \"Not a valid resource ID, must start with @: '{}'\".format(name)\n        )\n\n    # remove @\n    name = name[1:]\n\n    package = None\n    if ':' in name:\n        package, res_id = name.split(':', 1)\n    else:\n        res_id = name\n\n    if len(res_id) != 8:\n        raise ValueError(\n            \"Numerical ID is not 8 characters long: '{}'\".format(res_id)\n        )\n\n    try:\n        return int(res_id, 16), package\n    except ValueError:\n        raise ValueError(\"ID is not a hex ID: '{}'\".format(res_id))\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCResStringPoolRef","title":"<code>ARSCResStringPoolRef</code>","text":"<p>This is actually a <code>Res_value</code> It holds information about the stored resource value</p> <p>See: ResourceTypes.h 262</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>class ARSCResStringPoolRef:\n    \"\"\"\n    This is actually a `Res_value`\n    It holds information about the stored resource value\n\n    See: [ResourceTypes.h 262](http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#262)\n    \"\"\"\n\n    def __init__(\n        self, buff: BinaryIO, parent: Union[PackageContext, None] = None\n    ) -&gt; None:\n        self.start = buff.tell()\n        self.parent = parent\n\n        (self.size,) = unpack(\"&lt;H\", buff.read(2))\n        (self.res0,) = unpack(\"&lt;B\", buff.read(1))\n        try:\n            if self.res0 != 0:\n                logger.warning(\"res0 must be always zero!\")\n            self.data_type = unpack('&lt;B', buff.read(1))[0]\n            # data is interpreted according to data_type\n            self.data = unpack('&lt;I', buff.read(4))[0]\n        except Exception as e:\n            logger.error(e)\n\n    def get_data_value(self) -&gt; str:\n        return self.parent.stringpool_main.getString(self.data)\n\n    def get_data(self) -&gt; int:\n        return self.data\n\n    def get_data_type(self) -&gt; bytes:\n        return self.data_type\n\n    def get_data_type_string(self) -&gt; str:\n        return TYPE_TABLE[self.data_type]\n\n    def format_value(self) -&gt; str:\n        \"\"\"\n        Return the formatted (interpreted) data according to `data_type`.\n        \"\"\"\n        return format_value(\n            self.data_type, self.data, self.parent.stringpool_main.getString\n        )\n\n    def is_reference(self) -&gt; bool:\n        \"\"\"\n        Returns True if the Res_value is actually a reference to another resource\n        \"\"\"\n        return self.data_type == TYPE_REFERENCE\n\n    def __repr__(self):\n        return \"&lt;ARSCResStringPoolRef idx='0x{:08x}' size='{}' type='{}' data='0x{:08x}'&gt;\".format(\n            self.start,\n            self.size,\n            TYPE_TABLE.get(self.data_type, \"0x%x\" % self.data_type),\n            self.data,\n        )\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCResStringPoolRef.format_value","title":"<code>format_value()</code>","text":"<p>Return the formatted (interpreted) data according to <code>data_type</code>.</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def format_value(self) -&gt; str:\n    \"\"\"\n    Return the formatted (interpreted) data according to `data_type`.\n    \"\"\"\n    return format_value(\n        self.data_type, self.data, self.parent.stringpool_main.getString\n    )\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCResStringPoolRef.is_reference","title":"<code>is_reference()</code>","text":"<p>Returns True if the Res_value is actually a reference to another resource</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def is_reference(self) -&gt; bool:\n    \"\"\"\n    Returns True if the Res_value is actually a reference to another resource\n    \"\"\"\n    return self.data_type == TYPE_REFERENCE\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCResTableConfig","title":"<code>ARSCResTableConfig</code>","text":"<p>ARSCResTableConfig contains the configuration for specific resource selection. This is used on the device to determine which resources should be loaded based on different properties of the device like locale or displaysize.</p> <p>See the definition of <code>ResTable_config</code> in http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#911</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>class ARSCResTableConfig:\n    \"\"\"\n    ARSCResTableConfig contains the configuration for specific resource selection.\n    This is used on the device to determine which resources should be loaded\n    based on different properties of the device like locale or displaysize.\n\n    See the definition of `ResTable_config` in\n    http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#911\n    \"\"\"\n\n    @classmethod\n    def default_config(cls):\n        if not hasattr(cls, 'DEFAULT'):\n            cls.DEFAULT = ARSCResTableConfig(None)\n        return cls.DEFAULT\n\n    def __init__(self, buff: Union[BinaryIO, None] = None, **kwargs) -&gt; None:\n        if buff is not None:\n            self.start = buff.tell()\n\n            # uint32_t\n            self.size = unpack('&lt;I', buff.read(4))[0]\n\n            # union: uint16_t mcc, uint16_t mnc\n            # 0 means any\n            self.imsi = unpack('&lt;I', buff.read(4))[0]\n\n            # uint32_t as chars \\0\\0 means any\n            # either two 7bit ASCII representing the ISO-639-1 language code\n            # or a single 16bit LE value representing ISO-639-2 3 letter code\n            self.locale = unpack('&lt;I', buff.read(4))[0]\n\n            # struct of:\n            # uint8_t orientation\n            # uint8_t touchscreen\n            # uint16_t density\n            self.screenType = unpack('&lt;I', buff.read(4))[0]\n\n            if self.size &gt;= 20:\n                # struct of\n                # uint8_t keyboard\n                # uint8_t navigation\n                # uint8_t inputFlags\n                # uint8_t inputPad0\n                self.input = unpack('&lt;I', buff.read(4))[0]\n            else:\n                logger.debug(\n                    \"This file does not have input flags! size={}\".format(\n                        self.size\n                    )\n                )\n                self.input = 0\n\n            if self.size &gt;= 24:\n                # struct of\n                # uint16_t screenWidth\n                # uint16_t screenHeight\n                self.screenSize = unpack('&lt;I', buff.read(4))[0]\n            else:\n                logger.debug(\n                    \"This file does not have screenSize! size={}\".format(\n                        self.size\n                    )\n                )\n                self.screenSize = 0\n\n            if self.size &gt;= 28:\n                # struct of\n                # uint16_t sdkVersion\n                # uint16_t minorVersion  which should be always 0, as the meaning is not defined\n                self.version = unpack('&lt;I', buff.read(4))[0]\n            else:\n                logger.debug(\n                    \"This file does not have version! size={}\".format(\n                        self.size\n                    )\n                )\n                self.version = 0\n\n            # The next three fields seems to be optional\n            if self.size &gt;= 32:\n                # struct of\n                # uint8_t screenLayout\n                # uint8_t uiMode\n                # uint16_t smallestScreenWidthDp\n                (self.screenConfig,) = unpack('&lt;I', buff.read(4))\n            else:\n                logger.debug(\n                    \"This file does not have a screenConfig! size={}\".format(\n                        self.size\n                    )\n                )\n                self.screenConfig = 0\n\n            if self.size &gt;= 36:\n                # struct of\n                # uint16_t screenWidthDp\n                # uint16_t screenHeightDp\n                (self.screenSizeDp,) = unpack('&lt;I', buff.read(4))\n            else:\n                logger.debug(\n                    \"This file does not have a screenSizeDp! size={}\".format(\n                        self.size\n                    )\n                )\n                self.screenSizeDp = 0\n\n            if self.size &gt;= 40:\n                self.localeScript = buff.read(4)\n\n            if self.size &gt;= 44:\n                self.localeVariant = buff.read(8)\n\n            if self.size &gt;= 52:\n                # struct of\n                # uint8_t screenLayout2\n                # uint8_t colorMode\n                # uint16_t screenConfigPad2\n                (self.screenConfig2,) = unpack(\"&lt;I\", buff.read(4))\n            else:\n                logger.debug(\n                    \"This file does not have a screenConfig2! size={}\".format(\n                        self.size\n                    )\n                )\n                self.screenConfig2 = 0\n\n            self.exceedingSize = self.size - (buff.tell() - self.start)\n            if self.exceedingSize &gt; 0:\n                logger.debug(\"Skipping padding bytes!\")\n                self.padding = buff.read(self.exceedingSize)\n\n        else:\n            self.start = 0\n            self.size = 0\n            self.imsi = ((kwargs.pop('mcc', 0) &amp; 0xFFFF) &lt;&lt; 0) + (\n                (kwargs.pop('mnc', 0) &amp; 0xFFFF) &lt;&lt; 16\n            )\n\n            temp_locale = kwargs.pop('locale', 0)\n            if isinstance(temp_locale, str):\n                self.set_language_and_region(temp_locale)\n            else:\n                self.locale = temp_locale\n\n            for char_ix, char in kwargs.pop('locale', \"\")[0:4]:\n                self.locale += ord(char) &lt;&lt; (char_ix * 8)\n\n            self.screenType = (\n                ((kwargs.pop('orientation', 0) &amp; 0xFF) &lt;&lt; 0)\n                + ((kwargs.pop('touchscreen', 0) &amp; 0xFF) &lt;&lt; 8)\n                + ((kwargs.pop('density', 0) &amp; 0xFFFF) &lt;&lt; 16)\n            )\n\n            self.input = (\n                ((kwargs.pop('keyboard', 0) &amp; 0xFF) &lt;&lt; 0)\n                + ((kwargs.pop('navigation', 0) &amp; 0xFF) &lt;&lt; 8)\n                + ((kwargs.pop('inputFlags', 0) &amp; 0xFF) &lt;&lt; 16)\n                + ((kwargs.pop('inputPad0', 0) &amp; 0xFF) &lt;&lt; 24)\n            )\n\n            self.screenSize = (\n                (kwargs.pop('screenWidth', 0) &amp; 0xFFFF) &lt;&lt; 0\n            ) + ((kwargs.pop('screenHeight', 0) &amp; 0xFFFF) &lt;&lt; 16)\n\n            self.version = ((kwargs.pop('sdkVersion', 0) &amp; 0xFFFF) &lt;&lt; 0) + (\n                (kwargs.pop('minorVersion', 0) &amp; 0xFFFF) &lt;&lt; 16\n            )\n\n            self.screenConfig = (\n                ((kwargs.pop('screenLayout', 0) &amp; 0xFF) &lt;&lt; 0)\n                + ((kwargs.pop('uiMode', 0) &amp; 0xFF) &lt;&lt; 8)\n                + ((kwargs.pop('smallestScreenWidthDp', 0) &amp; 0xFFFF) &lt;&lt; 16)\n            )\n\n            self.screenSizeDp = (\n                (kwargs.pop('screenWidthDp', 0) &amp; 0xFFFF) &lt;&lt; 0\n            ) + ((kwargs.pop('screenHeightDp', 0) &amp; 0xFFFF) &lt;&lt; 16)\n\n            # TODO add this some day...\n            self.screenConfig2 = 0\n\n            self.exceedingSize = 0\n\n    def _unpack_language_or_region(self, char_in, char_base):\n        char_out = \"\"\n        if char_in[0] &amp; 0x80:\n            first = char_in[1] &amp; 0x1F\n            second = ((char_in[1] &amp; 0xE0) &gt;&gt; 5) + ((char_in[0] &amp; 0x03) &lt;&lt; 3)\n            third = (char_in[0] &amp; 0x7C) &gt;&gt; 2\n            char_out += chr(first + char_base)\n            char_out += chr(second + char_base)\n            char_out += chr(third + char_base)\n        else:\n            if char_in[0]:\n                char_out += chr(char_in[0])\n            if char_in[1]:\n                char_out += chr(char_in[1])\n        return char_out\n\n    def _pack_language_or_region(self, char_in: str) -&gt; list[int]:\n        char_out = [0x00, 0x00]\n        if len(char_in) != 2:\n            return char_out\n        char_out[0] = ord(char_in[0])\n        char_out[1] = ord(char_in[1])\n        return char_out\n\n    def set_language_and_region(self, language_region):\n        try:\n            language, region = language_region.split(\"-r\")\n        except ValueError:\n            language, region = language_region, None\n        language_bytes = self._pack_language_or_region(language)\n        if region:\n            region_bytes = self._pack_language_or_region(region)\n        else:\n            region_bytes = [0x00, 0x00]\n        self.locale = (\n            language_bytes[0]\n            | (language_bytes[1] &lt;&lt; 8)\n            | (region_bytes[0] &lt;&lt; 16)\n            | (region_bytes[1] &lt;&lt; 24)\n        )\n\n    def get_language_and_region(self) -&gt; str:\n        \"\"\"\n        Returns the combined language+region string or \\x00\\x00 for the default locale\n        :returns: the combined language and region string\n        \"\"\"\n        if self.locale != 0:\n            _language = self._unpack_language_or_region(\n                [\n                    self.locale &amp; 0xFF,\n                    (self.locale &amp; 0xFF00) &gt;&gt; 8,\n                ],\n                ord('a'),\n            )\n            _region = self._unpack_language_or_region(\n                [\n                    (self.locale &amp; 0xFF0000) &gt;&gt; 16,\n                    (self.locale &amp; 0xFF000000) &gt;&gt; 24,\n                ],\n                ord('0'),\n            )\n            return (_language + \"-r\" + _region) if _region else _language\n        return \"\\x00\\x00\"\n\n    def get_config_name_friendly(self) -&gt; str:\n        \"\"\"\n        Here for legacy reasons.\n\n        use [get_qualifier][androguard.core.axml.ARSCResTableConfig.get_qualifier] instead.\n        :returns: the qualifier string\n        \"\"\"\n        return self.get_qualifier()\n\n    def get_qualifier(self) -&gt; str:\n        \"\"\"\n        Return resource name qualifier for the current configuration.\n        for example\n\n        * `ldpi-v4`\n        * `hdpi-v4`\n\n        All possible qualifiers are listed in table 2 of &lt;https://developer.android.com/guide/topics/resources/providing-resources&gt;\n\n        You can find how android process this at [ResourceTypes 3243](http://aospxref.com/android-13.0.0_r3/xref/frameworks/base/libs/androidfw/ResourceTypes.cpp#3243)\n\n        :return: the resource name qualifer string\n        \"\"\"\n        res = []\n\n        mcc = self.imsi &amp; 0xFFFF\n        mnc = (self.imsi &amp; 0xFFFF0000) &gt;&gt; 16\n        if mcc != 0:\n            res.append(\"mcc%d\" % mcc)\n        if mnc != 0:\n            res.append(\"mnc%d\" % mnc)\n\n        if self.locale != 0:\n            res.append(self.get_language_and_region())\n\n        screenLayout = self.screenConfig &amp; 0xFF\n        if (screenLayout &amp; MASK_LAYOUTDIR) != 0:\n            if screenLayout &amp; MASK_LAYOUTDIR == LAYOUTDIR_LTR:\n                res.append(\"ldltr\")\n            elif screenLayout &amp; MASK_LAYOUTDIR == LAYOUTDIR_RTL:\n                res.append(\"ldrtl\")\n            else:\n                res.append(\"layoutDir_%d\" % (screenLayout &amp; MASK_LAYOUTDIR))\n\n        smallestScreenWidthDp = (self.screenConfig &amp; 0xFFFF0000) &gt;&gt; 16\n        if smallestScreenWidthDp != 0:\n            res.append(\"sw%ddp\" % smallestScreenWidthDp)\n\n        screenWidthDp = self.screenSizeDp &amp; 0xFFFF\n        screenHeightDp = (self.screenSizeDp &amp; 0xFFFF0000) &gt;&gt; 16\n        if screenWidthDp != 0:\n            res.append(\"w%ddp\" % screenWidthDp)\n        if screenHeightDp != 0:\n            res.append(\"h%ddp\" % screenHeightDp)\n\n        if (screenLayout &amp; MASK_SCREENSIZE) != SCREENSIZE_ANY:\n            if screenLayout &amp; MASK_SCREENSIZE == SCREENSIZE_SMALL:\n                res.append(\"small\")\n            elif screenLayout &amp; MASK_SCREENSIZE == SCREENSIZE_NORMAL:\n                res.append(\"normal\")\n            elif screenLayout &amp; MASK_SCREENSIZE == SCREENSIZE_LARGE:\n                res.append(\"large\")\n            elif screenLayout &amp; MASK_SCREENSIZE == SCREENSIZE_XLARGE:\n                res.append(\"xlarge\")\n            else:\n                res.append(\n                    \"screenLayoutSize_%d\" % (screenLayout &amp; MASK_SCREENSIZE)\n                )\n        if (screenLayout &amp; MASK_SCREENLONG) != 0:\n            if screenLayout &amp; MASK_SCREENLONG == SCREENLONG_NO:\n                res.append(\"notlong\")\n            elif screenLayout &amp; MASK_SCREENLONG == SCREENLONG_YES:\n                res.append(\"long\")\n            else:\n                res.append(\n                    \"screenLayoutLong_%d\" % (screenLayout &amp; MASK_SCREENLONG)\n                )\n\n        screenLayout2 = self.screenConfig2 &amp; 0xFF\n        if (screenLayout2 &amp; MASK_SCREENROUND) != 0:\n            if screenLayout2 &amp; MASK_SCREENROUND == SCREENROUND_NO:\n                res.append(\"notround\")\n            elif screenLayout2 &amp; MASK_SCREENROUND == SCREENROUND_YES:\n                res.append(\"round\")\n            else:\n                res.append(\n                    \"screenRound_%d\" % (screenLayout2 &amp; MASK_SCREENROUND)\n                )\n\n        colorMode = (self.screenConfig2 &amp; 0xFF00) &gt;&gt; 8\n        if (colorMode &amp; MASK_WIDE_COLOR_GAMUT) != 0:\n            if colorMode &amp; MASK_WIDE_COLOR_GAMUT == WIDE_COLOR_GAMUT_NO:\n                res.append(\"nowidecg\")\n            elif colorMode &amp; MASK_WIDE_COLOR_GAMUT == WIDE_COLOR_GAMUT_YES:\n                res.append(\"widecg\")\n            else:\n                res.append(\n                    \"wideColorGamut_%d\" % (colorMode &amp; MASK_WIDE_COLOR_GAMUT)\n                )\n\n        if (colorMode &amp; MASK_HDR) != 0:\n            if colorMode &amp; MASK_HDR == HDR_NO:\n                res.append(\"lowdr\")\n            elif colorMode &amp; MASK_HDR == HDR_YES:\n                res.append(\"highdr\")\n            else:\n                res.append(\"hdr_%d\" % (colorMode &amp; MASK_HDR))\n\n        orientation = self.screenType &amp; 0xFF\n        if orientation != ORIENTATION_ANY:\n            if orientation == ORIENTATION_PORT:\n                res.append(\"port\")\n            elif orientation == ORIENTATION_LAND:\n                res.append(\"land\")\n            elif orientation == ORIENTATION_SQUARE:\n                res.append(\"square\")\n            else:\n                res.append(\"orientation_%d\" % orientation)\n\n        uiMode = (self.screenConfig &amp; 0xFF00) &gt;&gt; 8\n        if (uiMode &amp; MASK_UI_MODE_TYPE) != UI_MODE_TYPE_ANY:\n            ui_mode = uiMode &amp; MASK_UI_MODE_TYPE\n            if ui_mode == UI_MODE_TYPE_DESK:\n                res.append(\"desk\")\n            elif ui_mode == UI_MODE_TYPE_CAR:\n                res.append(\"car\")\n            elif ui_mode == UI_MODE_TYPE_TELEVISION:\n                res.append(\"television\")\n            elif ui_mode == UI_MODE_TYPE_APPLIANCE:\n                res.append(\"appliance\")\n            elif ui_mode == UI_MODE_TYPE_WATCH:\n                res.append(\"watch\")\n            elif ui_mode == UI_MODE_TYPE_VR_HEADSET:\n                res.append(\"vrheadset\")\n            else:\n                res.append(\"uiModeType_%d\" % ui_mode)\n\n        if (uiMode &amp; MASK_UI_MODE_NIGHT) != 0:\n            if uiMode &amp; MASK_UI_MODE_NIGHT == UI_MODE_NIGHT_NO:\n                res.append(\"notnight\")\n            elif uiMode &amp; MASK_UI_MODE_NIGHT == UI_MODE_NIGHT_YES:\n                res.append(\"night\")\n            else:\n                res.append(\"uiModeNight_%d\" % (uiMode &amp; MASK_UI_MODE_NIGHT))\n\n        density = (self.screenType &amp; 0xFFFF0000) &gt;&gt; 16\n        if density != DENSITY_DEFAULT:\n            if density == DENSITY_LOW:\n                res.append(\"ldpi\")\n            elif density == DENSITY_MEDIUM:\n                res.append(\"mdpi\")\n            elif density == DENSITY_TV:\n                res.append(\"tvdpi\")\n            elif density == DENSITY_HIGH:\n                res.append(\"hdpi\")\n            elif density == DENSITY_XHIGH:\n                res.append(\"xhdpi\")\n            elif density == DENSITY_XXHIGH:\n                res.append(\"xxhdpi\")\n            elif density == DENSITY_XXXHIGH:\n                res.append(\"xxxhdpi\")\n            elif density == DENSITY_NONE:\n                res.append(\"nodpi\")\n            elif density == DENSITY_ANY:\n                res.append(\"anydpi\")\n            else:\n                res.append(\"%ddpi\" % (density))\n\n        touchscreen = (self.screenType &amp; 0xFF00) &gt;&gt; 8\n        if touchscreen != TOUCHSCREEN_ANY:\n            if touchscreen == TOUCHSCREEN_NOTOUCH:\n                res.append(\"notouch\")\n            elif touchscreen == TOUCHSCREEN_FINGER:\n                res.append(\"finger\")\n            elif touchscreen == TOUCHSCREEN_STYLUS:\n                res.append(\"stylus\")\n            else:\n                res.append(\"touchscreen_%d\" % touchscreen)\n\n        keyboard = self.input &amp; 0xFF\n        navigation = (self.input &amp; 0xFF00) &gt;&gt; 8\n        inputFlags = (self.input &amp; 0xFF0000) &gt;&gt; 16\n\n        if inputFlags &amp; MASK_KEYSHIDDEN != 0:\n            input_flags = inputFlags &amp; MASK_KEYSHIDDEN\n            if input_flags == KEYSHIDDEN_NO:\n                res.append(\"keysexposed\")\n            elif input_flags == KEYSHIDDEN_YES:\n                res.append(\"keyshidden\")\n            elif input_flags == KEYSHIDDEN_SOFT:\n                res.append(\"keyssoft\")\n\n        if keyboard != KEYBOARD_ANY:\n            if keyboard == KEYBOARD_NOKEYS:\n                res.append(\"nokeys\")\n            elif keyboard == KEYBOARD_QWERTY:\n                res.append(\"qwerty\")\n            elif keyboard == KEYBOARD_12KEY:\n                res.append(\"12key\")\n            else:\n                res.append(\"keyboard_%d\" % keyboard)\n\n        if inputFlags &amp; MASK_NAVHIDDEN != 0:\n            input_flags = inputFlags &amp; MASK_NAVHIDDEN\n            if input_flags == NAVHIDDEN_NO:\n                res.append(\"navexposed\")\n            elif input_flags == NAVHIDDEN_YES:\n                res.append(\"navhidden\")\n            else:\n                res.append(\"inputFlagsNavHidden_%d\" % input_flags)\n\n        if navigation != NAVIGATION_ANY:\n            if navigation == NAVIGATION_NONAV:\n                res.append(\"nonav\")\n            elif navigation == NAVIGATION_DPAD:\n                res.append(\"dpad\")\n            elif navigation == NAVIGATION_TRACKBALL:\n                res.append(\"trackball\")\n            elif navigation == NAVIGATION_WHEEL:\n                res.append(\"wheel\")\n            else:\n                res.append(\"navigation_%d\" % navigation)\n\n        screenSize = self.screenSize\n        if screenSize != 0:\n            screenWidth = self.screenSize &amp; 0xFFFF\n            screenHeight = (self.screenSize &amp; 0xFFFF0000) &gt;&gt; 16\n            res.append(\"%dx%d\" % (screenWidth, screenHeight))\n\n        version = self.version\n        if version != 0:\n            sdkVersion = self.version &amp; 0xFFFF\n            minorVersion = (self.version &amp; 0xFFFF0000) &gt;&gt; 16\n            res.append(\"v%d\" % sdkVersion)\n            if minorVersion != 0:\n                res.append(\".%d\" % minorVersion)\n\n        return \"-\".join(res)\n\n    def get_language(self) -&gt; str:\n        x = self.locale &amp; 0x0000FFFF\n        return chr(x &amp; 0x00FF) + chr((x &amp; 0xFF00) &gt;&gt; 8)\n\n    def get_country(self) -&gt; str:\n        x = (self.locale &amp; 0xFFFF0000) &gt;&gt; 16\n        return chr(x &amp; 0x00FF) + chr((x &amp; 0xFF00) &gt;&gt; 8)\n\n    def get_density(self) -&gt; str:\n        x = (self.screenType &gt;&gt; 16) &amp; 0xFFFF\n        return x\n\n    def is_default(self) -&gt; bool:\n        \"\"\"\n        Test if this is a default resource, which matches all\n\n        This is indicated that all fields are zero.\n        :returns: True if default, False otherwise\n        \"\"\"\n        return all(map(lambda x: x == 0, self._get_tuple()))\n\n    def _get_tuple(self):\n        return (\n            self.imsi,\n            self.locale,\n            self.screenType,\n            self.input,\n            self.screenSize,\n            self.version,\n            self.screenConfig,\n            self.screenSizeDp,\n            self.screenConfig2,\n        )\n\n    def __hash__(self):\n        return hash(self._get_tuple())\n\n    def __eq__(self, other):\n        return self._get_tuple() == other._get_tuple()\n\n    def __repr__(self):\n        return \"&lt;ARSCResTableConfig '{}'={}&gt;\".format(\n            self.get_qualifier(), repr(self._get_tuple())\n        )\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCResTableConfig.get_config_name_friendly","title":"<code>get_config_name_friendly()</code>","text":"<p>Here for legacy reasons.</p> <p>use get_qualifier instead.</p> <p>Returns:</p> Type Description <code>str</code> <p>the qualifier string</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def get_config_name_friendly(self) -&gt; str:\n    \"\"\"\n    Here for legacy reasons.\n\n    use [get_qualifier][androguard.core.axml.ARSCResTableConfig.get_qualifier] instead.\n    :returns: the qualifier string\n    \"\"\"\n    return self.get_qualifier()\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCResTableConfig.get_language_and_region","title":"<code>get_language_and_region()</code>","text":"<p>Returns the combined language+region string or \u0000\u0000 for the default locale</p> <p>Returns:</p> Type Description <code>str</code> <p>the combined language and region string</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def get_language_and_region(self) -&gt; str:\n    \"\"\"\n    Returns the combined language+region string or \\x00\\x00 for the default locale\n    :returns: the combined language and region string\n    \"\"\"\n    if self.locale != 0:\n        _language = self._unpack_language_or_region(\n            [\n                self.locale &amp; 0xFF,\n                (self.locale &amp; 0xFF00) &gt;&gt; 8,\n            ],\n            ord('a'),\n        )\n        _region = self._unpack_language_or_region(\n            [\n                (self.locale &amp; 0xFF0000) &gt;&gt; 16,\n                (self.locale &amp; 0xFF000000) &gt;&gt; 24,\n            ],\n            ord('0'),\n        )\n        return (_language + \"-r\" + _region) if _region else _language\n    return \"\\x00\\x00\"\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCResTableConfig.get_qualifier","title":"<code>get_qualifier()</code>","text":"<p>Return resource name qualifier for the current configuration. for example</p> <ul> <li><code>ldpi-v4</code></li> <li><code>hdpi-v4</code></li> </ul> <p>All possible qualifiers are listed in table 2 of https://developer.android.com/guide/topics/resources/providing-resources</p> <p>You can find how android process this at ResourceTypes 3243</p> <p>Returns:</p> Type Description <code>str</code> <p>the resource name qualifer string</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def get_qualifier(self) -&gt; str:\n    \"\"\"\n    Return resource name qualifier for the current configuration.\n    for example\n\n    * `ldpi-v4`\n    * `hdpi-v4`\n\n    All possible qualifiers are listed in table 2 of &lt;https://developer.android.com/guide/topics/resources/providing-resources&gt;\n\n    You can find how android process this at [ResourceTypes 3243](http://aospxref.com/android-13.0.0_r3/xref/frameworks/base/libs/androidfw/ResourceTypes.cpp#3243)\n\n    :return: the resource name qualifer string\n    \"\"\"\n    res = []\n\n    mcc = self.imsi &amp; 0xFFFF\n    mnc = (self.imsi &amp; 0xFFFF0000) &gt;&gt; 16\n    if mcc != 0:\n        res.append(\"mcc%d\" % mcc)\n    if mnc != 0:\n        res.append(\"mnc%d\" % mnc)\n\n    if self.locale != 0:\n        res.append(self.get_language_and_region())\n\n    screenLayout = self.screenConfig &amp; 0xFF\n    if (screenLayout &amp; MASK_LAYOUTDIR) != 0:\n        if screenLayout &amp; MASK_LAYOUTDIR == LAYOUTDIR_LTR:\n            res.append(\"ldltr\")\n        elif screenLayout &amp; MASK_LAYOUTDIR == LAYOUTDIR_RTL:\n            res.append(\"ldrtl\")\n        else:\n            res.append(\"layoutDir_%d\" % (screenLayout &amp; MASK_LAYOUTDIR))\n\n    smallestScreenWidthDp = (self.screenConfig &amp; 0xFFFF0000) &gt;&gt; 16\n    if smallestScreenWidthDp != 0:\n        res.append(\"sw%ddp\" % smallestScreenWidthDp)\n\n    screenWidthDp = self.screenSizeDp &amp; 0xFFFF\n    screenHeightDp = (self.screenSizeDp &amp; 0xFFFF0000) &gt;&gt; 16\n    if screenWidthDp != 0:\n        res.append(\"w%ddp\" % screenWidthDp)\n    if screenHeightDp != 0:\n        res.append(\"h%ddp\" % screenHeightDp)\n\n    if (screenLayout &amp; MASK_SCREENSIZE) != SCREENSIZE_ANY:\n        if screenLayout &amp; MASK_SCREENSIZE == SCREENSIZE_SMALL:\n            res.append(\"small\")\n        elif screenLayout &amp; MASK_SCREENSIZE == SCREENSIZE_NORMAL:\n            res.append(\"normal\")\n        elif screenLayout &amp; MASK_SCREENSIZE == SCREENSIZE_LARGE:\n            res.append(\"large\")\n        elif screenLayout &amp; MASK_SCREENSIZE == SCREENSIZE_XLARGE:\n            res.append(\"xlarge\")\n        else:\n            res.append(\n                \"screenLayoutSize_%d\" % (screenLayout &amp; MASK_SCREENSIZE)\n            )\n    if (screenLayout &amp; MASK_SCREENLONG) != 0:\n        if screenLayout &amp; MASK_SCREENLONG == SCREENLONG_NO:\n            res.append(\"notlong\")\n        elif screenLayout &amp; MASK_SCREENLONG == SCREENLONG_YES:\n            res.append(\"long\")\n        else:\n            res.append(\n                \"screenLayoutLong_%d\" % (screenLayout &amp; MASK_SCREENLONG)\n            )\n\n    screenLayout2 = self.screenConfig2 &amp; 0xFF\n    if (screenLayout2 &amp; MASK_SCREENROUND) != 0:\n        if screenLayout2 &amp; MASK_SCREENROUND == SCREENROUND_NO:\n            res.append(\"notround\")\n        elif screenLayout2 &amp; MASK_SCREENROUND == SCREENROUND_YES:\n            res.append(\"round\")\n        else:\n            res.append(\n                \"screenRound_%d\" % (screenLayout2 &amp; MASK_SCREENROUND)\n            )\n\n    colorMode = (self.screenConfig2 &amp; 0xFF00) &gt;&gt; 8\n    if (colorMode &amp; MASK_WIDE_COLOR_GAMUT) != 0:\n        if colorMode &amp; MASK_WIDE_COLOR_GAMUT == WIDE_COLOR_GAMUT_NO:\n            res.append(\"nowidecg\")\n        elif colorMode &amp; MASK_WIDE_COLOR_GAMUT == WIDE_COLOR_GAMUT_YES:\n            res.append(\"widecg\")\n        else:\n            res.append(\n                \"wideColorGamut_%d\" % (colorMode &amp; MASK_WIDE_COLOR_GAMUT)\n            )\n\n    if (colorMode &amp; MASK_HDR) != 0:\n        if colorMode &amp; MASK_HDR == HDR_NO:\n            res.append(\"lowdr\")\n        elif colorMode &amp; MASK_HDR == HDR_YES:\n            res.append(\"highdr\")\n        else:\n            res.append(\"hdr_%d\" % (colorMode &amp; MASK_HDR))\n\n    orientation = self.screenType &amp; 0xFF\n    if orientation != ORIENTATION_ANY:\n        if orientation == ORIENTATION_PORT:\n            res.append(\"port\")\n        elif orientation == ORIENTATION_LAND:\n            res.append(\"land\")\n        elif orientation == ORIENTATION_SQUARE:\n            res.append(\"square\")\n        else:\n            res.append(\"orientation_%d\" % orientation)\n\n    uiMode = (self.screenConfig &amp; 0xFF00) &gt;&gt; 8\n    if (uiMode &amp; MASK_UI_MODE_TYPE) != UI_MODE_TYPE_ANY:\n        ui_mode = uiMode &amp; MASK_UI_MODE_TYPE\n        if ui_mode == UI_MODE_TYPE_DESK:\n            res.append(\"desk\")\n        elif ui_mode == UI_MODE_TYPE_CAR:\n            res.append(\"car\")\n        elif ui_mode == UI_MODE_TYPE_TELEVISION:\n            res.append(\"television\")\n        elif ui_mode == UI_MODE_TYPE_APPLIANCE:\n            res.append(\"appliance\")\n        elif ui_mode == UI_MODE_TYPE_WATCH:\n            res.append(\"watch\")\n        elif ui_mode == UI_MODE_TYPE_VR_HEADSET:\n            res.append(\"vrheadset\")\n        else:\n            res.append(\"uiModeType_%d\" % ui_mode)\n\n    if (uiMode &amp; MASK_UI_MODE_NIGHT) != 0:\n        if uiMode &amp; MASK_UI_MODE_NIGHT == UI_MODE_NIGHT_NO:\n            res.append(\"notnight\")\n        elif uiMode &amp; MASK_UI_MODE_NIGHT == UI_MODE_NIGHT_YES:\n            res.append(\"night\")\n        else:\n            res.append(\"uiModeNight_%d\" % (uiMode &amp; MASK_UI_MODE_NIGHT))\n\n    density = (self.screenType &amp; 0xFFFF0000) &gt;&gt; 16\n    if density != DENSITY_DEFAULT:\n        if density == DENSITY_LOW:\n            res.append(\"ldpi\")\n        elif density == DENSITY_MEDIUM:\n            res.append(\"mdpi\")\n        elif density == DENSITY_TV:\n            res.append(\"tvdpi\")\n        elif density == DENSITY_HIGH:\n            res.append(\"hdpi\")\n        elif density == DENSITY_XHIGH:\n            res.append(\"xhdpi\")\n        elif density == DENSITY_XXHIGH:\n            res.append(\"xxhdpi\")\n        elif density == DENSITY_XXXHIGH:\n            res.append(\"xxxhdpi\")\n        elif density == DENSITY_NONE:\n            res.append(\"nodpi\")\n        elif density == DENSITY_ANY:\n            res.append(\"anydpi\")\n        else:\n            res.append(\"%ddpi\" % (density))\n\n    touchscreen = (self.screenType &amp; 0xFF00) &gt;&gt; 8\n    if touchscreen != TOUCHSCREEN_ANY:\n        if touchscreen == TOUCHSCREEN_NOTOUCH:\n            res.append(\"notouch\")\n        elif touchscreen == TOUCHSCREEN_FINGER:\n            res.append(\"finger\")\n        elif touchscreen == TOUCHSCREEN_STYLUS:\n            res.append(\"stylus\")\n        else:\n            res.append(\"touchscreen_%d\" % touchscreen)\n\n    keyboard = self.input &amp; 0xFF\n    navigation = (self.input &amp; 0xFF00) &gt;&gt; 8\n    inputFlags = (self.input &amp; 0xFF0000) &gt;&gt; 16\n\n    if inputFlags &amp; MASK_KEYSHIDDEN != 0:\n        input_flags = inputFlags &amp; MASK_KEYSHIDDEN\n        if input_flags == KEYSHIDDEN_NO:\n            res.append(\"keysexposed\")\n        elif input_flags == KEYSHIDDEN_YES:\n            res.append(\"keyshidden\")\n        elif input_flags == KEYSHIDDEN_SOFT:\n            res.append(\"keyssoft\")\n\n    if keyboard != KEYBOARD_ANY:\n        if keyboard == KEYBOARD_NOKEYS:\n            res.append(\"nokeys\")\n        elif keyboard == KEYBOARD_QWERTY:\n            res.append(\"qwerty\")\n        elif keyboard == KEYBOARD_12KEY:\n            res.append(\"12key\")\n        else:\n            res.append(\"keyboard_%d\" % keyboard)\n\n    if inputFlags &amp; MASK_NAVHIDDEN != 0:\n        input_flags = inputFlags &amp; MASK_NAVHIDDEN\n        if input_flags == NAVHIDDEN_NO:\n            res.append(\"navexposed\")\n        elif input_flags == NAVHIDDEN_YES:\n            res.append(\"navhidden\")\n        else:\n            res.append(\"inputFlagsNavHidden_%d\" % input_flags)\n\n    if navigation != NAVIGATION_ANY:\n        if navigation == NAVIGATION_NONAV:\n            res.append(\"nonav\")\n        elif navigation == NAVIGATION_DPAD:\n            res.append(\"dpad\")\n        elif navigation == NAVIGATION_TRACKBALL:\n            res.append(\"trackball\")\n        elif navigation == NAVIGATION_WHEEL:\n            res.append(\"wheel\")\n        else:\n            res.append(\"navigation_%d\" % navigation)\n\n    screenSize = self.screenSize\n    if screenSize != 0:\n        screenWidth = self.screenSize &amp; 0xFFFF\n        screenHeight = (self.screenSize &amp; 0xFFFF0000) &gt;&gt; 16\n        res.append(\"%dx%d\" % (screenWidth, screenHeight))\n\n    version = self.version\n    if version != 0:\n        sdkVersion = self.version &amp; 0xFFFF\n        minorVersion = (self.version &amp; 0xFFFF0000) &gt;&gt; 16\n        res.append(\"v%d\" % sdkVersion)\n        if minorVersion != 0:\n            res.append(\".%d\" % minorVersion)\n\n    return \"-\".join(res)\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCResTableConfig.is_default","title":"<code>is_default()</code>","text":"<p>Test if this is a default resource, which matches all</p> <p>This is indicated that all fields are zero.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if default, False otherwise</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def is_default(self) -&gt; bool:\n    \"\"\"\n    Test if this is a default resource, which matches all\n\n    This is indicated that all fields are zero.\n    :returns: True if default, False otherwise\n    \"\"\"\n    return all(map(lambda x: x == 0, self._get_tuple()))\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCResTableEntry","title":"<code>ARSCResTableEntry</code>","text":"<p>A <code>ResTable_entry</code>.</p> <p>See https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h;l=1522;drc=442fcb158a5b2e23340b74ce2e29e5e1f5bf9d66;bpv=0;bpt=0</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>class ARSCResTableEntry:\n    \"\"\"\n    A `ResTable_entry`.\n\n    See &lt;https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h;l=1522;drc=442fcb158a5b2e23340b74ce2e29e5e1f5bf9d66;bpv=0;bpt=0&gt;\n    \"\"\"\n\n    # If set, this is a complex entry, holding a set of name/value\n    # mappings.  It is followed by an array of ResTable_map structures.\n    FLAG_COMPLEX = 1\n\n    # If set, this resource has been declared public, so libraries\n    # are allowed to reference it.\n    FLAG_PUBLIC = 2\n\n    # If set, this is a weak resource and may be overriden by strong\n    # resources of the same name/type. This is only useful during\n    # linking with other resource tables.\n    FLAG_WEAK = 4\n\n    # If set, this is a compact entry with data type and value directly\n    # encoded in this entry\n    FLAG_COMPACT = 8\n\n    def __init__(\n        self,\n        buff: BinaryIO,\n        entry_offset: int,\n        expected_end_of_chunk: int,\n        mResId: int,\n        parent: Union[PackageContext, None] = None,\n    ) -&gt; None:\n        self.start = buff.seek(entry_offset)\n        self.mResId = mResId\n        self.parent = parent\n\n        self.size = unpack('&lt;H', buff.read(2))[0]\n        self.flags = unpack('&lt;H', buff.read(2))[0]\n        # This is a ResStringPool_ref\n        self.index = unpack('&lt;I', buff.read(4))[0]\n\n        if self.is_complex():\n            self.item = ARSCComplex(buff, expected_end_of_chunk, parent)\n        elif self.is_compact():\n            self.key = self.size\n            self.data = self.index\n            self.datatype = (self.flags &gt;&gt; 8) &amp; 0xFF\n        else:\n            # If FLAG_COMPLEX is not set, a Res_value structure will follow\n            self.key = ARSCResStringPoolRef(buff, self.parent)\n\n        if self.is_weak():\n            logger.debug(\"Parsed {}\".format(self))\n\n    def get_index(self) -&gt; int:\n        return self.index\n\n    def get_value(self) -&gt; str:\n        return self.parent.mKeyStrings.getString(self.index)\n\n    def get_key_data(self) -&gt; str:\n        if self.is_compact():\n            return self.parent.stringpool_main.getString(self.key)\n        else:\n            return self.key.get_data_value()\n\n    def is_public(self) -&gt; bool:\n        return (self.flags &amp; self.FLAG_PUBLIC) != 0\n\n    def is_complex(self) -&gt; bool:\n        return (self.flags &amp; self.FLAG_COMPLEX) != 0\n\n    def is_compact(self) -&gt; bool:\n        return (self.flags &amp; self.FLAG_COMPACT) != 0\n\n    def is_weak(self) -&gt; bool:\n        return (self.flags &amp; self.FLAG_WEAK) != 0\n\n    def __repr__(self):\n        return \"&lt;ARSCResTableEntry idx='0x{:08x}' mResId='0x{:08x}' flags='0x{:02x}' holding={}&gt;\".format(\n            self.start,\n            self.mResId,\n            self.flags,\n            self.item if self.is_complex() else self.key,\n        )\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCResTablePackage","title":"<code>ARSCResTablePackage</code>","text":"<p>A <code>ResTable_package</code></p> <p>See http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#861</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>class ARSCResTablePackage:\n    \"\"\"\n    A `ResTable_package`\n\n    See http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#861\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, header: ARSCHeader) -&gt; None:\n        self.header = header\n        self.start = buff.tell()\n        self.id = unpack('&lt;I', buff.read(4))[0]\n        self.name = buff.read(256)\n        self.typeStrings = unpack('&lt;I', buff.read(4))[0]\n        self.lastPublicType = unpack('&lt;I', buff.read(4))[0]\n        self.keyStrings = unpack('&lt;I', buff.read(4))[0]\n        self.lastPublicKey = unpack('&lt;I', buff.read(4))[0]\n        self.mResId = self.id &lt;&lt; 24\n\n    def get_name(self) -&gt; None:\n        name = self.name.decode(\"utf-16\", 'replace')\n        name = name[: name.find(\"\\x00\")]\n        return name\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCResType","title":"<code>ARSCResType</code>","text":"<p>This is a <code>ResTable_type</code> without it's <code>ResChunk_header</code>. It contains a <code>ResTable_config</code></p> <p>See http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#1364</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>class ARSCResType:\n    \"\"\"\n    This is a `ResTable_type` without it's `ResChunk_header`.\n    It contains a `ResTable_config`\n\n    See http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#1364\n    \"\"\"\n\n    def __init__(\n        self, buff: BinaryIO, parent: Union[PackageContext, None] = None\n    ) -&gt; None:\n        self.start = buff.tell()\n        self.parent = parent\n\n        self.id = unpack('&lt;B', buff.read(1))[0]\n        # TODO there is now FLAG_SPARSE: http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#1401\n        (self.flags,) = unpack('&lt;B', buff.read(1))\n        self.reserved = unpack('&lt;H', buff.read(2))[0]\n        if self.reserved != 0:\n            raise ResParserError(\"reserved must be zero!\")\n        self.entryCount = unpack('&lt;I', buff.read(4))[0]\n        self.entriesStart = unpack('&lt;I', buff.read(4))[0]\n\n        self.mResId = (0xFF000000 &amp; self.parent.get_mResId()) | self.id &lt;&lt; 16\n        self.parent.set_mResId(self.mResId)\n\n        self.config = ARSCResTableConfig(buff)\n\n        logger.debug(\"Parsed {}\".format(self))\n\n    def get_type(self) -&gt; str:\n        return self.parent.mTableStrings.getString(self.id - 1)\n\n    def get_package_name(self) -&gt; str:\n        return self.parent.get_package_name()\n\n    def __repr__(self):\n        return (\n            \"&lt;ARSCResType(start=0x%x, id=0x%x, flags=0x%x, entryCount=%d, entriesStart=0x%x, mResId=0x%x, %s)&gt;\"\n            % (\n                self.start,\n                self.id,\n                self.flags,\n                self.entryCount,\n                self.entriesStart,\n                self.mResId,\n                \"table:\" + self.parent.mTableStrings.getString(self.id - 1),\n            )\n        )\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ARSCResTypeSpec","title":"<code>ARSCResTypeSpec</code>","text":"<p>See http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#1327</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>class ARSCResTypeSpec:\n    \"\"\"\n    See http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#1327\n    \"\"\"\n\n    def __init__(\n        self, buff: BinaryIO, parent: Union[PackageContext, None] = None\n    ) -&gt; None:\n        self.start = buff.tell()\n        self.parent = parent\n        self.id = unpack('&lt;B', buff.read(1))[0]\n        self.res0 = unpack('&lt;B', buff.read(1))[0]\n        self.res1 = unpack('&lt;H', buff.read(2))[0]\n        # TODO: https://github.com/androguard/androguard/issues/1014 | Properly account for the cases where res0/1 are not zero\n        try:\n            if self.res0 != 0:\n                logger.warning(\"res0 must be zero!\")\n            if self.res1 != 0:\n                logger.warning(\"res1 must be zero!\")\n            self.entryCount = unpack('&lt;I', buff.read(4))[0]\n\n            self.typespec_entries = []\n            for i in range(0, self.entryCount):\n                self.typespec_entries.append(unpack('&lt;I', buff.read(4))[0])\n        except Exception as e:\n            logger.error(e)\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.AXMLParser","title":"<code>AXMLParser</code>","text":"<p><code>AXMLParser</code> reads through all chunks in the AXML file and implements a state machine to return information about the current chunk, which can then be read by AXMLPrinter.</p> <p>An AXML file is a file which contains multiple chunks of data, defined by the <code>ResChunk_header</code>. There is no real file magic but as the size of the first header is fixed and the <code>type</code> of the <code>ResChunk_header</code> is set to <code>RES_XML_TYPE</code>, a file will usually start with <code>0x03000800</code>. But there are several examples where the <code>type</code> is set to something else, probably in order to fool parsers.</p> <p>Typically the <code>AXMLParser</code> is used in a loop which terminates if <code>m_event</code> is set to <code>END_DOCUMENT</code>. You can use the <code>next()</code> function to get the next chunk. Note that not all chunk types are yielded from the iterator! Some chunks are processed in the <code>AXMLParser</code> only. The parser will set is_valid to <code>False</code> if it parses something not valid. Messages what is wrong are logged.</p> <p>See http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#563</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>class AXMLParser:\n    \"\"\"\n    `AXMLParser` reads through all chunks in the AXML file\n    and implements a state machine to return information about\n    the current chunk, which can then be read by [AXMLPrinter][androguard.core.axml.AXMLPrinter].\n\n    An AXML file is a file which contains multiple chunks of data, defined\n    by the `ResChunk_header`.\n    There is no real file magic but as the size of the first header is fixed\n    and the `type` of the `ResChunk_header` is set to `RES_XML_TYPE`, a file\n    will usually start with `0x03000800`.\n    But there are several examples where the `type` is set to something\n    else, probably in order to fool parsers.\n\n    Typically the `AXMLParser` is used in a loop which terminates if `m_event` is set to `END_DOCUMENT`.\n    You can use the `next()` function to get the next chunk.\n    Note that not all chunk types are yielded from the iterator! Some chunks are processed in\n    the `AXMLParser` only.\n    The parser will set [is_valid][androguard.core.axml.AXMLParser.is_valid] to `False` if it parses something not valid.\n    Messages what is wrong are logged.\n\n    See http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#563\n    \"\"\"\n\n    def __init__(self, raw_buff: bytes) -&gt; None:\n        logger.debug(\"AXMLParser\")\n\n        self._reset()\n\n        self._valid = True\n        self.axml_tampered = False\n        self.buff = io.BufferedReader(io.BytesIO(raw_buff))\n        self.buff_size = self.buff.raw.getbuffer().nbytes\n        self.packerwarning = False\n\n        # Minimum is a single ARSCHeader, which would be a strange edge case...\n        if self.buff_size &lt; 8:\n            logger.error(\n                \"Filesize is too small to be a valid AXML file! Filesize: {}\".format(\n                    self.buff_size\n                )\n            )\n            self._valid = False\n            return\n\n        # This would be even stranger, if an AXML file is larger than 4GB...\n        # But this is not possible as the maximum chunk size is a unsigned 4 byte int.\n        if self.buff_size &gt; 0xFFFFFFFF:\n            logger.error(\n                \"Filesize is too large to be a valid AXML file! Filesize: {}\".format(\n                    self.buff_size\n                )\n            )\n            self._valid = False\n            return\n\n        try:\n            axml_header = ARSCHeader(self.buff)\n            logger.debug(\"FIRST HEADER {}\".format(axml_header))\n        except ResParserError as e:\n            logger.error(\"Error parsing first resource header: %s\", e)\n            self._valid = False\n            return\n\n        self.filesize = axml_header.size\n\n        if axml_header.header_size == 28024:\n            # Can be a common error: the file is not an AXML but a plain XML\n            # The file will then usually start with '&lt;?xm' / '3C 3F 78 6D'\n            logger.warning(\n                \"Header size is 28024! Are you trying to parse a plain XML file?\"\n            )\n\n        if axml_header.header_size != 8:\n            logger.error(\n                \"This does not look like an AXML file. header size does not equal 8! header size = {}\".format(\n                    axml_header.header_size\n                )\n            )\n            self._valid = False\n            return\n\n        if self.filesize &gt; self.buff_size:\n            logger.error(\n                \"This does not look like an AXML file. Declared filesize does not match real size: {} vs {}\".format(\n                    self.filesize, self.buff_size\n                )\n            )\n            self._valid = False\n            return\n\n        if self.filesize &lt; self.buff_size:\n            # The file can still be parsed up to the point where the chunk should end.\n            self.axml_tampered = True\n            logger.warning(\n                \"Declared filesize ({}) is smaller than total file size ({}). \"\n                \"Was something appended to the file? Trying to parse it anyways.\".format(\n                    self.filesize, self.buff_size\n                )\n            )\n\n        # Not that severe of an error, we have plenty files where this is not\n        # set correctly\n        if axml_header.type != RES_XML_TYPE:\n            self.axml_tampered = True\n            logger.warning(\n                \"AXML file has an unusual resource type! \"\n                \"Malware likes to to such stuff to anti androguard! \"\n                \"But we try to parse it anyways. Resource Type: 0x{:04x}\".format(\n                    axml_header.type\n                )\n            )\n\n        # Now we parse the STRING POOL\n        try:\n            header = ARSCHeader(self.buff, expected_type=RES_STRING_POOL_TYPE)\n            logger.debug(\"STRING_POOL {}\".format(header))\n        except ResParserError as e:\n            logger.error(\n                \"Error parsing resource header of string pool: {}\".format(e)\n            )\n            self._valid = False\n            return\n\n        if header.header_size != 0x1C:\n            logger.error(\n                \"This does not look like an AXML file. String chunk header size does not equal 28! header size = {}\".format(\n                    header.header_size\n                )\n            )\n            self._valid = False\n            return\n\n        self.sb = StringBlock(self.buff, header)\n\n        self.buff.seek(axml_header.header_size + header.size)\n\n        # Stores resource ID mappings, if any\n        self.m_resourceIDs = []\n\n        # Store a list of prefix/uri mappings encountered\n        self.namespaces = []\n\n    def is_valid(self) -&gt; bool:\n        \"\"\"\n        Get the state of the [AXMLPrinter][androguard.core.axml.AXMLPrinter].\n        if an error happend somewhere in the process of parsing the file,\n        this flag is set to `False`.\n\n        :returns: `True` if the `AXMLPrinter` finished parsing, or `False` if an error occurred\n        \"\"\"\n        logger.debug(self._valid)\n        return self._valid\n\n    def _reset(self):\n        self.m_event = -1\n        self.m_lineNumber = -1\n        self.m_name = -1\n        self.m_namespaceUri = -1\n        self.m_attributes = []\n        self.m_idAttribute = -1\n        self.m_classAttribute = -1\n        self.m_styleAttribute = -1\n\n    def __next__(self):\n        self._do_next()\n        return self.m_event\n\n    def _do_next(self):\n        logger.debug(\"M_EVENT {}\".format(self.m_event))\n\n        if self.m_event == END_DOCUMENT:\n            return\n\n        self._reset()\n        while self._valid:\n            # Stop at the declared filesize or at the end of the file\n            if self.buff.tell() == self.filesize:\n                self.m_event = END_DOCUMENT\n                break\n\n            # Again, we read an ARSCHeader\n            try:\n                possible_types = {256, 257, 258, 259, 260, 384}\n                h = ARSCHeader(self.buff, possible_types=possible_types)\n                logger.debug(\"NEXT HEADER {}\".format(h))\n            except ResParserError as e:\n                logger.error(\"Error parsing resource header: {}\".format(e))\n                self._valid = False\n                return\n\n            # Special chunk: Resource Map. This chunk might be contained inside\n            # the file, after the string pool.\n            if h.type == RES_XML_RESOURCE_MAP_TYPE:\n                logger.debug(\"AXML contains a RESOURCE MAP\")\n                # Check size: &lt; 8 bytes mean that the chunk is not complete\n                # Should be aligned to 4 bytes.\n                if h.size &lt; 8 or (h.size % 4) != 0:\n                    logger.error(\n                        \"Invalid chunk size in chunk XML_RESOURCE_MAP\"\n                    )\n                    self._valid = False\n                    return\n\n                for i in range((h.size - h.header_size) // 4):\n                    self.m_resourceIDs.append(\n                        unpack('&lt;L', self.buff.read(4))[0]\n                    )\n\n                continue\n\n            # Parse now the XML chunks.\n            # unknown chunk types might cause problems, but we can skip them!\n            if (\n                h.type &lt; RES_XML_FIRST_CHUNK_TYPE\n                or h.type &gt; RES_XML_LAST_CHUNK_TYPE\n            ):\n                # h.size is the size of the whole chunk including the header.\n                # We read already 8 bytes of the header, thus we need to\n                # subtract them.\n                logger.error(\n                    \"Not a XML resource chunk type: 0x{:04x}. Skipping {} bytes\".format(\n                        h.type, h.size\n                    )\n                )\n                self.buff.seek(h.end)\n                continue\n\n            # Check that we read a correct header\n            if h.header_size != 0x10:\n                logger.error(\n                    \"XML Resource Type Chunk header size does not match 16! \"\n                    \"At chunk type 0x{:04x}, declared header size=0x{:04x}, chunk size=0x{:04x}\".format(\n                        h.type, h.header_size, h.size\n                    )\n                )\n                self.buff.seek(h.end)\n                continue\n\n            # Line Number of the source file, only used as meta information\n            (self.m_lineNumber,) = unpack('&lt;L', self.buff.read(4))\n\n            # Comment_Index (usually 0xFFFFFFFF)\n            (self.m_comment_index,) = unpack('&lt;L', self.buff.read(4))\n\n            if self.m_comment_index != 0xFFFFFFFF and h.type in [\n                RES_XML_START_NAMESPACE_TYPE,\n                RES_XML_END_NAMESPACE_TYPE,\n            ]:\n                logger.warning(\n                    \"Unhandled Comment at namespace chunk: '{}'\".format(\n                        self.sb[self.m_comment_index]\n                    )\n                )\n\n            if h.type == RES_XML_START_NAMESPACE_TYPE:\n                (prefix,) = unpack('&lt;L', self.buff.read(4))\n                (uri,) = unpack('&lt;L', self.buff.read(4))\n\n                s_prefix = self.sb[prefix]\n                s_uri = self.sb[uri]\n\n                logger.debug(\n                    \"Start of Namespace mapping: prefix {}: '{}' --&gt; uri {}: '{}'\".format(\n                        prefix, s_prefix, uri, s_uri\n                    )\n                )\n\n                if s_uri == '':\n                    logger.warning(\n                        \"Namespace prefix '{}' resolves to empty URI. \"\n                        \"This might be a packer.\".format(s_prefix)\n                    )\n\n                if (prefix, uri) in self.namespaces:\n                    logger.debug(\n                        \"Namespace mapping ({}, {}) already seen! \"\n                        \"This is usually not a problem but could indicate packers or broken AXML compilers.\".format(\n                            prefix, uri\n                        )\n                    )\n                self.namespaces.append((prefix, uri))\n\n                # We can continue with the next chunk, as we store the namespace\n                # mappings for each tag\n                continue\n\n            if h.type == RES_XML_END_NAMESPACE_TYPE:\n                # END_PREFIX contains again prefix and uri field\n                (prefix,) = unpack('&lt;L', self.buff.read(4))\n                (uri,) = unpack('&lt;L', self.buff.read(4))\n\n                # We remove the last namespace mapping matching\n                if (prefix, uri) in self.namespaces:\n                    self.namespaces.remove((prefix, uri))\n                else:\n                    logger.warning(\n                        \"Reached a NAMESPACE_END without having the namespace stored before? \"\n                        \"Prefix ID: {}, URI ID: {}\".format(prefix, uri)\n                    )\n\n                # We can continue with the next chunk, as we store the namespace\n                # mappings for each tag\n                continue\n\n            # START_TAG is the start of a new tag.\n            if h.type == RES_XML_START_ELEMENT_TYPE:\n                # The TAG consists of some fields:\n                # * (chunk_size, line_number, comment_index - we read before)\n                # * namespace_uri\n                # * name\n                # * flags\n                # * attribute_count\n                # * class_attribute\n                # After that, there are two lists of attributes, 20 bytes each\n\n                # Namespace URI (String ID)\n                (self.m_namespaceUri,) = unpack('&lt;L', self.buff.read(4))\n                # Name of the Tag (String ID)\n                (self.m_name,) = unpack('&lt;L', self.buff.read(4))\n                self.at_start, self.at_size = unpack('&lt;HH', self.buff.read(4))\n                # Attribute Count\n                (attributeCount,) = unpack('&lt;L', self.buff.read(4))\n                # Class Attribute\n                (self.m_classAttribute,) = unpack('&lt;L', self.buff.read(4))\n\n                self.m_idAttribute = (attributeCount &gt;&gt; 16) - 1\n                self.m_attribute_count = attributeCount &amp; 0xFFFF\n                self.m_styleAttribute = (self.m_classAttribute &gt;&gt; 16) - 1\n                self.m_classAttribute = (self.m_classAttribute &amp; 0xFFFF) - 1\n\n                # Now, we parse the attributes.\n                # Each attribute has 5 fields of 4 byte\n                for i in range(0, self.m_attribute_count):\n                    # Each field is linearly parsed into the array\n                    # Each Attribute contains:\n                    # * Namespace URI (String ID)\n                    # * Name (String ID)\n                    # * Value\n                    # * Type\n                    # * Data\n                    for j in range(0, ATTRIBUTE_LENGTH):\n                        self.m_attributes.append(\n                            unpack('&lt;L', self.buff.read(4))[0]\n                        )\n                    if self.at_size != 20:\n                        self.buff.read(self.at_size - 20)\n\n                # Then there are class_attributes\n                for i in range(\n                    ATTRIBUTE_IX_VALUE_TYPE,\n                    len(self.m_attributes),\n                    ATTRIBUTE_LENGTH,\n                ):\n                    self.m_attributes[i] = self.m_attributes[i] &gt;&gt; 24\n\n                self.m_event = START_TAG\n                break\n\n            if h.type == RES_XML_END_ELEMENT_TYPE:\n                (self.m_namespaceUri,) = unpack('&lt;L', self.buff.read(4))\n                (self.m_name,) = unpack('&lt;L', self.buff.read(4))\n\n                self.m_event = END_TAG\n                break\n\n            if h.type == RES_XML_CDATA_TYPE:\n                # The CDATA field is like an attribute.\n                # It contains an index into the String pool\n                # as well as a typed value.\n                # usually, this typed value is set to UNDEFINED\n\n                # ResStringPool_ref data --&gt; uint32_t index\n                (self.m_name,) = unpack('&lt;L', self.buff.read(4))\n\n                # Res_value typedData:\n                # uint16_t size\n                # uint8_t res0 -&gt; always zero\n                # uint8_t dataType\n                # uint32_t data\n                # For now, we ingore these values\n                size, res0, dataType, data = unpack(\"&lt;HBBL\", self.buff.read(8))\n\n                logger.debug(\n                    \"found a CDATA Chunk: \"\n                    \"index={: 6d}, size={: 4d}, res0={: 4d}, dataType={: 4d}, data={: 4d}\".format(\n                        self.m_name, size, res0, dataType, data\n                    )\n                )\n\n                self.m_event = TEXT\n                break\n\n            # Still here? Looks like we read an unknown XML header, try to skip it...\n            logger.warning(\n                \"Unknown XML Chunk: 0x{:04x}, skipping {} bytes.\".format(\n                    h.type, h.size\n                )\n            )\n            self.buff.seek(h.end)\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Return the String associated with the tag name\n\n        :returns: the string\n        \"\"\"\n        if self.m_name == -1 or (\n            self.m_event != START_TAG and self.m_event != END_TAG\n        ):\n            return ''\n\n        return self.sb[self.m_name]\n\n    @property\n    def comment(self) -&gt; Union[str, None]:\n        \"\"\"\n        Return the comment at the current position or None if no comment is given\n\n        This works only for Tags, as the comments of Namespaces are silently dropped.\n        Currently, there is no way of retrieving comments of namespaces.\n\n        :returns: the comment string, or None if no comment exists\n        \"\"\"\n        if self.m_comment_index == 0xFFFFFFFF:\n            return None\n\n        return self.sb[self.m_comment_index]\n\n    @property\n    def namespace(self) -&gt; str:\n        \"\"\"\n        Return the Namespace URI (if any) as a String for the current tag\n\n        :returns: the namespace uri, or empty if namespace does not exist\n        \"\"\"\n        if self.m_name == -1 or (\n            self.m_event != START_TAG and self.m_event != END_TAG\n        ):\n            return ''\n\n        # No Namespace\n        if self.m_namespaceUri == 0xFFFFFFFF:\n            return ''\n\n        return self.sb[self.m_namespaceUri]\n\n    @property\n    def nsmap(self) -&gt; dict[str, str]:\n        \"\"\"\n        Returns the current namespace mapping as a dictionary\n\n        there are several problems with the map and we try to guess a few\n        things here:\n\n        1) a URI can be mapped by many prefixes, so it is to decide which one to take\n        2) a prefix might map to an empty string (some packers)\n        3) uri+prefix mappings might be included several times\n        4) prefix might be empty\n\n        :returns: the namespace mapping dictionary\n        \"\"\"\n\n        NSMAP = dict()\n        # solve 3) by using a set\n        for k, v in set(self.namespaces):\n            s_prefix = self.sb[k]\n            s_uri = self.sb[v]\n            # Solve 2) &amp; 4) by not including\n            if s_uri != \"\" and s_prefix != \"\":\n                # solve 1) by using the last one in the list\n                NSMAP[s_prefix] = s_uri.strip()\n\n        return NSMAP\n\n    @property\n    def text(self) -&gt; str:\n        \"\"\"\n        Return the String assosicated with the current text\n\n        :returns: the string associated with the current text\n        \"\"\"\n        if self.m_name == -1 or self.m_event != TEXT:\n            return ''\n\n        return self.sb[self.m_name]\n\n    def getName(self) -&gt; str:\n        \"\"\"\n        Legacy only!\n        use `name` attribute instead\n        \"\"\"\n        return self.name\n\n    def getText(self) -&gt; str:\n        \"\"\"\n        Legacy only!\n        use `text` attribute instead\n        \"\"\"\n        return self.text\n\n    def getPrefix(self) -&gt; str:\n        \"\"\"\n        Legacy only!\n        use `namespace` attribute instead\n        \"\"\"\n        return self.namespace\n\n    def _get_attribute_offset(self, index: int):\n        \"\"\"\n        Return the start inside the m_attributes array for a given attribute\n        \"\"\"\n        if self.m_event != START_TAG:\n            logger.warning(\"Current event is not START_TAG.\")\n\n        offset = index * ATTRIBUTE_LENGTH\n        if offset &gt;= len(self.m_attributes):\n            logger.warning(\"Invalid attribute index\")\n\n        return offset\n\n    def getAttributeCount(self) -&gt; int:\n        \"\"\"\n        Return the number of Attributes for a Tag\n        or -1 if not in a tag\n\n        :returns: the number of attributes\n        \"\"\"\n        if self.m_event != START_TAG:\n            return -1\n\n        return self.m_attribute_count\n\n    def getAttributeUri(self, index:int) -&gt; int:\n        \"\"\"\n        Returns the numeric ID for the namespace URI of an attribute\n\n        :returns: the namespace URI numeric id\n        \"\"\"\n        logger.debug(index)\n\n        offset = self._get_attribute_offset(index)\n        uri = self.m_attributes[offset + ATTRIBUTE_IX_NAMESPACE_URI]\n\n        return uri\n\n    def getAttributeNamespace(self, index:int) -&gt; str:\n        \"\"\"\n        Return the Namespace URI (if any) for the attribute\n\n        :returns: the attribute uri, or empty string if no namespace\n        \"\"\"\n        logger.debug(index)\n\n        uri = self.getAttributeUri(index)\n\n        # No Namespace\n        if uri == 0xFFFFFFFF:\n            return ''\n\n        return self.sb[uri]\n\n    def getAttributeName(self, index:int) -&gt; str:\n        \"\"\"\n        Returns the String which represents the attribute name\n\n        :returns: the attribute name\n        \"\"\"\n        logger.debug(index)\n        offset = self._get_attribute_offset(index)\n        name = self.m_attributes[offset + ATTRIBUTE_IX_NAME]\n\n        res = self.sb[name]\n        # If the result is a (null) string, we need to look it up.\n        if name &lt; len(self.m_resourceIDs):\n            attr = self.m_resourceIDs[name]\n            if attr in public.SYSTEM_RESOURCES['attributes']['inverse']:\n                res = public.SYSTEM_RESOURCES['attributes']['inverse'][\n                    attr\n                ].replace(\"_\", \":\")\n                if res != self.sb[name]:\n                    self.packerwarning = True\n\n        if not res or res == \":\":\n            # Attach the HEX Number, so for multiple missing attributes we do not run\n            # into problems.\n            res = 'android:UNKNOWN_SYSTEM_ATTRIBUTE_{:08x}'.format(attr)\n        return res\n\n    def getAttributeValueType(self, index: int):\n        \"\"\"\n        Return the type of the attribute at the given index\n\n        :param index: index of the attribute\n        \"\"\"\n        logger.debug(index)\n\n        offset = self._get_attribute_offset(index)\n        return self.m_attributes[offset + ATTRIBUTE_IX_VALUE_TYPE]\n\n    def getAttributeValueData(self, index: int):\n        \"\"\"\n        Return the data of the attribute at the given index\n\n        :param index: index of the attribute\n        \"\"\"\n        logger.debug(index)\n\n        offset = self._get_attribute_offset(index)\n        return self.m_attributes[offset + ATTRIBUTE_IX_VALUE_DATA]\n\n    def getAttributeValue(self, index: int) -&gt; str:\n        \"\"\"\n        This function is only used to look up strings\n        All other work is done by\n        [format_value][androguard.core.axml.format_value]\n        # FIXME should unite those functions\n        :param index: index of the attribute\n        :returns: the string\n        \"\"\"\n        logger.debug(index)\n\n        offset = self._get_attribute_offset(index)\n        valueType = self.m_attributes[offset + ATTRIBUTE_IX_VALUE_TYPE]\n        if valueType == TYPE_STRING:\n            valueString = self.m_attributes[offset + ATTRIBUTE_IX_VALUE_STRING]\n            return self.sb[valueString]\n        return ''\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.AXMLParser.comment","title":"<code>comment</code>  <code>property</code>","text":"<p>Return the comment at the current position or None if no comment is given</p> <p>This works only for Tags, as the comments of Namespaces are silently dropped. Currently, there is no way of retrieving comments of namespaces.</p> <p>Returns:</p> Type Description <code>Union[str, None]</code> <p>the comment string, or None if no comment exists</p>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.AXMLParser.name","title":"<code>name</code>  <code>property</code>","text":"<p>Return the String associated with the tag name</p> <p>Returns:</p> Type Description <code>str</code> <p>the string</p>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.AXMLParser.namespace","title":"<code>namespace</code>  <code>property</code>","text":"<p>Return the Namespace URI (if any) as a String for the current tag</p> <p>Returns:</p> Type Description <code>str</code> <p>the namespace uri, or empty if namespace does not exist</p>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.AXMLParser.nsmap","title":"<code>nsmap</code>  <code>property</code>","text":"<p>Returns the current namespace mapping as a dictionary</p> <p>there are several problems with the map and we try to guess a few things here:</p> <p>1) a URI can be mapped by many prefixes, so it is to decide which one to take 2) a prefix might map to an empty string (some packers) 3) uri+prefix mappings might be included several times 4) prefix might be empty</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>the namespace mapping dictionary</p>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.AXMLParser.text","title":"<code>text</code>  <code>property</code>","text":"<p>Return the String assosicated with the current text</p> <p>Returns:</p> Type Description <code>str</code> <p>the string associated with the current text</p>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.AXMLParser.getAttributeCount","title":"<code>getAttributeCount()</code>","text":"<p>Return the number of Attributes for a Tag or -1 if not in a tag</p> <p>Returns:</p> Type Description <code>int</code> <p>the number of attributes</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def getAttributeCount(self) -&gt; int:\n    \"\"\"\n    Return the number of Attributes for a Tag\n    or -1 if not in a tag\n\n    :returns: the number of attributes\n    \"\"\"\n    if self.m_event != START_TAG:\n        return -1\n\n    return self.m_attribute_count\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.AXMLParser.getAttributeName","title":"<code>getAttributeName(index)</code>","text":"<p>Returns the String which represents the attribute name</p> <p>Returns:</p> Type Description <code>str</code> <p>the attribute name</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def getAttributeName(self, index:int) -&gt; str:\n    \"\"\"\n    Returns the String which represents the attribute name\n\n    :returns: the attribute name\n    \"\"\"\n    logger.debug(index)\n    offset = self._get_attribute_offset(index)\n    name = self.m_attributes[offset + ATTRIBUTE_IX_NAME]\n\n    res = self.sb[name]\n    # If the result is a (null) string, we need to look it up.\n    if name &lt; len(self.m_resourceIDs):\n        attr = self.m_resourceIDs[name]\n        if attr in public.SYSTEM_RESOURCES['attributes']['inverse']:\n            res = public.SYSTEM_RESOURCES['attributes']['inverse'][\n                attr\n            ].replace(\"_\", \":\")\n            if res != self.sb[name]:\n                self.packerwarning = True\n\n    if not res or res == \":\":\n        # Attach the HEX Number, so for multiple missing attributes we do not run\n        # into problems.\n        res = 'android:UNKNOWN_SYSTEM_ATTRIBUTE_{:08x}'.format(attr)\n    return res\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.AXMLParser.getAttributeNamespace","title":"<code>getAttributeNamespace(index)</code>","text":"<p>Return the Namespace URI (if any) for the attribute</p> <p>Returns:</p> Type Description <code>str</code> <p>the attribute uri, or empty string if no namespace</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def getAttributeNamespace(self, index:int) -&gt; str:\n    \"\"\"\n    Return the Namespace URI (if any) for the attribute\n\n    :returns: the attribute uri, or empty string if no namespace\n    \"\"\"\n    logger.debug(index)\n\n    uri = self.getAttributeUri(index)\n\n    # No Namespace\n    if uri == 0xFFFFFFFF:\n        return ''\n\n    return self.sb[uri]\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.AXMLParser.getAttributeUri","title":"<code>getAttributeUri(index)</code>","text":"<p>Returns the numeric ID for the namespace URI of an attribute</p> <p>Returns:</p> Type Description <code>int</code> <p>the namespace URI numeric id</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def getAttributeUri(self, index:int) -&gt; int:\n    \"\"\"\n    Returns the numeric ID for the namespace URI of an attribute\n\n    :returns: the namespace URI numeric id\n    \"\"\"\n    logger.debug(index)\n\n    offset = self._get_attribute_offset(index)\n    uri = self.m_attributes[offset + ATTRIBUTE_IX_NAMESPACE_URI]\n\n    return uri\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.AXMLParser.getAttributeValue","title":"<code>getAttributeValue(index)</code>","text":"<p>This function is only used to look up strings All other work is done by format_value</p>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.AXMLParser.getAttributeValue--fixme-should-unite-those-functions","title":"FIXME should unite those functions","text":"<p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>index of the attribute</p> required <p>Returns:</p> Type Description <code>str</code> <p>the string</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def getAttributeValue(self, index: int) -&gt; str:\n    \"\"\"\n    This function is only used to look up strings\n    All other work is done by\n    [format_value][androguard.core.axml.format_value]\n    # FIXME should unite those functions\n    :param index: index of the attribute\n    :returns: the string\n    \"\"\"\n    logger.debug(index)\n\n    offset = self._get_attribute_offset(index)\n    valueType = self.m_attributes[offset + ATTRIBUTE_IX_VALUE_TYPE]\n    if valueType == TYPE_STRING:\n        valueString = self.m_attributes[offset + ATTRIBUTE_IX_VALUE_STRING]\n        return self.sb[valueString]\n    return ''\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.AXMLParser.getAttributeValueData","title":"<code>getAttributeValueData(index)</code>","text":"<p>Return the data of the attribute at the given index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>index of the attribute</p> required Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def getAttributeValueData(self, index: int):\n    \"\"\"\n    Return the data of the attribute at the given index\n\n    :param index: index of the attribute\n    \"\"\"\n    logger.debug(index)\n\n    offset = self._get_attribute_offset(index)\n    return self.m_attributes[offset + ATTRIBUTE_IX_VALUE_DATA]\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.AXMLParser.getAttributeValueType","title":"<code>getAttributeValueType(index)</code>","text":"<p>Return the type of the attribute at the given index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>index of the attribute</p> required Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def getAttributeValueType(self, index: int):\n    \"\"\"\n    Return the type of the attribute at the given index\n\n    :param index: index of the attribute\n    \"\"\"\n    logger.debug(index)\n\n    offset = self._get_attribute_offset(index)\n    return self.m_attributes[offset + ATTRIBUTE_IX_VALUE_TYPE]\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.AXMLParser.getName","title":"<code>getName()</code>","text":"<p>Legacy only! use <code>name</code> attribute instead</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def getName(self) -&gt; str:\n    \"\"\"\n    Legacy only!\n    use `name` attribute instead\n    \"\"\"\n    return self.name\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.AXMLParser.getPrefix","title":"<code>getPrefix()</code>","text":"<p>Legacy only! use <code>namespace</code> attribute instead</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def getPrefix(self) -&gt; str:\n    \"\"\"\n    Legacy only!\n    use `namespace` attribute instead\n    \"\"\"\n    return self.namespace\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.AXMLParser.getText","title":"<code>getText()</code>","text":"<p>Legacy only! use <code>text</code> attribute instead</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def getText(self) -&gt; str:\n    \"\"\"\n    Legacy only!\n    use `text` attribute instead\n    \"\"\"\n    return self.text\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.AXMLParser.is_valid","title":"<code>is_valid()</code>","text":"<p>Get the state of the AXMLPrinter. if an error happend somewhere in the process of parsing the file, this flag is set to <code>False</code>.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the <code>AXMLPrinter</code> finished parsing, or <code>False</code> if an error occurred</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def is_valid(self) -&gt; bool:\n    \"\"\"\n    Get the state of the [AXMLPrinter][androguard.core.axml.AXMLPrinter].\n    if an error happend somewhere in the process of parsing the file,\n    this flag is set to `False`.\n\n    :returns: `True` if the `AXMLPrinter` finished parsing, or `False` if an error occurred\n    \"\"\"\n    logger.debug(self._valid)\n    return self._valid\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.AXMLPrinter","title":"<code>AXMLPrinter</code>","text":"<p>Converter for AXML Files into a lxml ElementTree, which can easily be converted into XML.</p> <p>A Reference Implementation can be found at http://androidxref.com/9.0.0_r3/xref/frameworks/base/tools/aapt/XMLNode.cpp</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>class AXMLPrinter:\n    \"\"\"\n    Converter for AXML Files into a lxml ElementTree, which can easily be\n    converted into XML.\n\n    A Reference Implementation can be found at http://androidxref.com/9.0.0_r3/xref/frameworks/base/tools/aapt/XMLNode.cpp\n    \"\"\"\n\n    __charrange = None\n    __replacement = None\n\n    def __init__(self, raw_buff: bytes) -&gt; bytes:\n        logger.debug(\"AXMLPrinter\")\n\n        self.axml = AXMLParser(raw_buff)\n\n        self.root = None\n        self.packerwarning = False\n        cur = []\n\n        while self.axml.is_valid():\n            _type = next(self.axml)\n            logger.debug(\"DEBUG ARSC TYPE {}\".format(_type))\n\n            if _type == START_TAG:\n                if not self.axml.name:  # Check if the name is empty\n                    logger.debug(\"Empty tag name, skipping to next element\")\n                    continue  # Skip this iteration\n                uri = self._print_namespace(self.axml.namespace)\n                uri, name = self._fix_name(uri, self.axml.name)\n                tag = \"{}{}\".format(uri, name)\n\n                comment = self.axml.comment\n                if comment:\n                    if self.root is None:\n                        logger.warning(\n                            \"Can not attach comment with content '{}' without root!\".format(\n                                comment\n                            )\n                        )\n                    else:\n                        cur[-1].append(etree.Comment(comment))\n\n                logger.debug(\n                    \"START_TAG: {} (line={})\".format(\n                        tag, self.axml.m_lineNumber\n                    )\n                )\n\n                try:\n                    elem = etree.Element(tag, nsmap=self.axml.nsmap)\n                except ValueError as e:\n                    logger.error(e)\n                    # nsmap= {'&lt;!--': 'http://schemas.android.com/apk/res/android'} | pull/1056\n                    if 'Invalid namespace prefix' in str(e):\n                        corrected_nsmap = self.clean_and_replace_nsmap(\n                            self.axml.nsmap, str(e).split(\"'\")[1]\n                        )\n                        elem = etree.Element(tag, nsmap=corrected_nsmap)\n                    else:\n                        raise\n\n                for i in range(self.axml.getAttributeCount()):\n                    uri = self._print_namespace(\n                        self.axml.getAttributeNamespace(i)\n                    )\n                    uri, name = self._fix_name(\n                        uri, self.axml.getAttributeName(i)\n                    )\n                    value = self._fix_value(self._get_attribute_value(i))\n\n                    logger.debug(\n                        \"found an attribute: {}{}='{}'\".format(\n                            uri, name, value.encode(\"utf-8\")\n                        )\n                    )\n                    if \"{}{}\".format(uri, name) in elem.attrib:\n                        logger.warning(\n                            \"Duplicate attribute '{}{}'! Will overwrite!\".format(\n                                uri, name\n                            )\n                        )\n                    elem.set(\"{}{}\".format(uri, name), value)\n\n                if self.root is None:\n                    self.root = elem\n                else:\n                    if not cur:\n                        # looks like we lost the root?\n                        logger.error(\n                            \"No more elements available to attach to! Is the XML malformed?\"\n                        )\n                        break\n                    cur[-1].append(elem)\n                cur.append(elem)\n\n            if _type == END_TAG:\n                if not cur:\n                    logger.warning(\n                        \"Too many END_TAG! No more elements available to attach to!\"\n                    )\n                else:\n                    if not self.axml.name:  # Check if the name is empty\n                        logger.debug(\n                            \"Empty tag name at END_TAG, skipping to next element\"\n                        )\n                        continue\n\n                name = self.axml.name\n                uri = self._print_namespace(self.axml.namespace)\n                tag = \"{}{}\".format(uri, name)\n                if cur[-1].tag != tag:\n                    logger.warning(\n                        \"Closing tag '{}' does not match current stack! At line number: {}. Is the XML malformed?\".format(\n                            self.axml.name, self.axml.m_lineNumber\n                        )\n                    )\n                cur.pop()\n            if _type == TEXT:\n                logger.debug(\"TEXT for {}\".format(cur[-1]))\n                cur[-1].text = self.axml.text\n            if _type == END_DOCUMENT:\n                # Check if all namespace mappings are closed\n                if len(self.axml.namespaces) &gt; 0:\n                    logger.warning(\n                        \"Not all namespace mappings were closed! Malformed AXML?\"\n                    )\n                break\n\n    def clean_and_replace_nsmap(self, nsmap, invalid_prefix):\n        correct_prefix = 'android'\n        corrected_nsmap = {}\n        for prefix, uri in nsmap.items():\n            if prefix.startswith(invalid_prefix):\n                corrected_nsmap[correct_prefix] = uri\n            else:\n                corrected_nsmap[prefix] = uri\n        return corrected_nsmap\n\n    def get_buff(self) -&gt; bytes:\n        \"\"\"\n        Returns the raw XML file without prettification applied.\n\n        :returns: bytes, encoded as UTF-8\n        \"\"\"\n        return self.get_xml(pretty=False)\n\n    def get_xml(self, pretty: bool = True) -&gt; bytes:\n        \"\"\"\n        Get the XML as an UTF-8 string\n\n        :returns: bytes encoded as UTF-8\n        \"\"\"\n        return etree.tostring(self.root, encoding=\"utf-8\", pretty_print=pretty)\n\n    def get_xml_obj(self) -&gt; etree.Element:\n        \"\"\"\n        Get the XML as an ElementTree object\n\n        :returns: `lxml.etree.Element` object\n        \"\"\"\n        return self.root\n\n    def is_valid(self) -&gt; bool:\n        \"\"\"\n        Return the state of the [AXMLParser][androguard.core.axml.AXMLParser].\n        If this flag is set to `False`, the parsing has failed, thus\n        the resulting XML will not work or will even be empty.\n\n        :returns: `True` if the `AXMLParser` finished parsing, or `False` if an error occurred\n        \"\"\"\n        return self.axml.is_valid()\n\n    def is_packed(self) -&gt; bool:\n        \"\"\"\n        Returns True if the AXML is likely to be packed\n\n        Packers do some weird stuff and we try to detect it.\n        Sometimes the files are not packed but simply broken or compiled with\n        some broken version of a tool.\n        Some file corruption might also be appear to be a packed file.\n\n        :returns: True if packer detected, False otherwise\n        \"\"\"\n        return self.packerwarning or self.axml.packerwarning\n\n    def _get_attribute_value(self, index: int):\n        \"\"\"\n        Wrapper function for format_value to resolve the actual value of an attribute in a tag\n        :param index: index of the current attribute\n        :return: formatted value\n        \"\"\"\n        _type = self.axml.getAttributeValueType(index)\n        _data = self.axml.getAttributeValueData(index)\n\n        return format_value(\n            _type, _data, lambda _: self.axml.getAttributeValue(index)\n        )\n\n    def _fix_name(self, prefix, name) -&gt; tuple[str, str]:\n        \"\"\"\n        Apply some fixes to element named and attribute names.\n        Try to get conform to:\n        &gt; Like element names, attribute names are case-sensitive and must start with a letter or underscore.\n        &gt; The rest of the name can contain letters, digits, hyphens, underscores, and periods.\n        See: &lt;https://msdn.microsoft.com/en-us/library/ms256152(v=vs.110).aspx&gt;\n\n        This function tries to fix some broken namespace mappings.\n        In some cases, the namespace prefix is inside the name and not in the prefix field.\n        Then, the tag name will usually look like 'android:foobar'.\n        If and only if the namespace prefix is inside the namespace mapping and the actual prefix field is empty,\n        we will strip the prefix from the attribute name and return the fixed prefix URI instead.\n        Otherwise replacement rules will be applied.\n\n        The replacement rules work in that way, that all unwanted characters are replaced by underscores.\n        In other words, all characters except the ones listed above are replaced.\n\n        :param name: Name of the attribute or tag\n        :param prefix: The existing prefix uri as found in the AXML chunk\n        :return: a fixed version of prefix and name\n        \"\"\"\n        if not name[0].isalpha() and name[0] != \"_\":\n            logger.warning(\n                \"Invalid start for name '{}'. \"\n                \"XML name must start with a letter.\".format(name)\n            )\n            self.packerwarning = True\n            name = \"_{}\".format(name)\n        if (\n            name.startswith(\"android:\")\n            and prefix == ''\n            and 'android' in self.axml.nsmap\n        ):\n            # Seems be a common thing...\n            logger.info(\n                \"Name '{}' starts with 'android:' prefix but 'android' is a known prefix. Replacing prefix.\".format(\n                    name\n                )\n            )\n            prefix = self._print_namespace(self.axml.nsmap['android'])\n            name = name[len(\"android:\") :]\n            # It looks like this is some kind of packer... Not sure though.\n            self.packerwarning = True\n        elif \":\" in name and prefix == '':\n            self.packerwarning = True\n            embedded_prefix, new_name = name.split(\":\", 1)\n            if embedded_prefix in self.axml.nsmap:\n                logger.info(\n                    \"Prefix '{}' is in namespace mapping, assume that it is a prefix.\"\n                )\n                prefix = self._print_namespace(\n                    self.axml.nsmap[embedded_prefix]\n                )\n                name = new_name\n            else:\n                # Print out an extra warning\n                logger.warning(\n                    \"Confused: name contains a unknown namespace prefix: '{}'. \"\n                    \"This is either a broken AXML file or some attempt to break stuff.\".format(\n                        name\n                    )\n                )\n        if not re.match(r\"^[a-zA-Z0-9._-]*$\", name):\n            logger.warning(\n                \"Name '{}' contains invalid characters!\".format(name)\n            )\n            self.packerwarning = True\n            name = re.sub(r\"[^a-zA-Z0-9._-]\", \"_\", name)\n\n        return prefix, name\n\n    def _fix_value(self, value):\n        \"\"\"\n        Return a cleaned version of a value\n        according to the specification:\n        &gt; Char\t   ::=   \t#x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]\n\n        See &lt;https://www.w3.org/TR/xml/#charsets&gt;\n\n        :param value: a value to clean\n        :return: the cleaned value\n        \"\"\"\n        if not self.__charrange or not self.__replacement:\n            self.__charrange = re.compile(\n                '^[\\u0020-\\uD7FF\\u0009\\u000A\\u000D\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$'\n            )\n            self.__replacement = re.compile(\n                '[^\\u0020-\\uD7FF\\u0009\\u000A\\u000D\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]'\n            )\n\n        # Reading string until \\x00. This is the same as aapt does.\n        if \"\\x00\" in value:\n            self.packerwarning = True\n            logger.warning(\n                \"Null byte found in attribute value at position {}: \"\n                \"Value(hex): '{}'\".format(\n                    value.find(\"\\x00\"), binascii.hexlify(value.encode(\"utf-8\"))\n                )\n            )\n            value = value[: value.find(\"\\x00\")]\n\n        if not self.__charrange.match(value):\n            logger.warning(\n                \"Invalid character in value found. Replacing with '_'.\"\n            )\n            self.packerwarning = True\n            value = self.__replacement.sub('_', value)\n        return value\n\n    def _print_namespace(self, uri):\n        if uri != \"\":\n            uri = \"{{{}}}\".format(uri)\n        return uri\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.AXMLPrinter.get_buff","title":"<code>get_buff()</code>","text":"<p>Returns the raw XML file without prettification applied.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>bytes, encoded as UTF-8</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def get_buff(self) -&gt; bytes:\n    \"\"\"\n    Returns the raw XML file without prettification applied.\n\n    :returns: bytes, encoded as UTF-8\n    \"\"\"\n    return self.get_xml(pretty=False)\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.AXMLPrinter.get_xml","title":"<code>get_xml(pretty=True)</code>","text":"<p>Get the XML as an UTF-8 string</p> <p>Returns:</p> Type Description <code>bytes</code> <p>bytes encoded as UTF-8</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def get_xml(self, pretty: bool = True) -&gt; bytes:\n    \"\"\"\n    Get the XML as an UTF-8 string\n\n    :returns: bytes encoded as UTF-8\n    \"\"\"\n    return etree.tostring(self.root, encoding=\"utf-8\", pretty_print=pretty)\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.AXMLPrinter.get_xml_obj","title":"<code>get_xml_obj()</code>","text":"<p>Get the XML as an ElementTree object</p> <p>Returns:</p> Type Description <code>Element</code> <p><code>lxml.etree.Element</code> object</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def get_xml_obj(self) -&gt; etree.Element:\n    \"\"\"\n    Get the XML as an ElementTree object\n\n    :returns: `lxml.etree.Element` object\n    \"\"\"\n    return self.root\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.AXMLPrinter.is_packed","title":"<code>is_packed()</code>","text":"<p>Returns True if the AXML is likely to be packed</p> <p>Packers do some weird stuff and we try to detect it. Sometimes the files are not packed but simply broken or compiled with some broken version of a tool. Some file corruption might also be appear to be a packed file.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if packer detected, False otherwise</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def is_packed(self) -&gt; bool:\n    \"\"\"\n    Returns True if the AXML is likely to be packed\n\n    Packers do some weird stuff and we try to detect it.\n    Sometimes the files are not packed but simply broken or compiled with\n    some broken version of a tool.\n    Some file corruption might also be appear to be a packed file.\n\n    :returns: True if packer detected, False otherwise\n    \"\"\"\n    return self.packerwarning or self.axml.packerwarning\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.AXMLPrinter.is_valid","title":"<code>is_valid()</code>","text":"<p>Return the state of the AXMLParser. If this flag is set to <code>False</code>, the parsing has failed, thus the resulting XML will not work or will even be empty.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the <code>AXMLParser</code> finished parsing, or <code>False</code> if an error occurred</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def is_valid(self) -&gt; bool:\n    \"\"\"\n    Return the state of the [AXMLParser][androguard.core.axml.AXMLParser].\n    If this flag is set to `False`, the parsing has failed, thus\n    the resulting XML will not work or will even be empty.\n\n    :returns: `True` if the `AXMLParser` finished parsing, or `False` if an error occurred\n    \"\"\"\n    return self.axml.is_valid()\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.PackageContext","title":"<code>PackageContext</code>","text":"Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>class PackageContext:\n    def __init__(\n        self,\n        current_package: ARSCResTablePackage,\n        stringpool_main: StringBlock,\n        mTableStrings: StringBlock,\n        mKeyStrings: StringBlock,\n    ) -&gt; None:\n        \"\"\"\n        :param current_package:\n        :param stringpool_main:\n        :param mTableStrings:\n        :param mKeyStrings:\n        \"\"\"\n        self.stringpool_main = stringpool_main\n        self.mTableStrings = mTableStrings\n        self.mKeyStrings = mKeyStrings\n        self.current_package = current_package\n\n    def get_mResId(self) -&gt; int:\n        return self.current_package.mResId\n\n    def set_mResId(self, mResId: int) -&gt; None:\n        self.current_package.mResId = mResId\n\n    def get_package_name(self) -&gt; str:\n        return self.current_package.get_name()\n\n    def __repr__(self):\n        return \"&lt;PackageContext {}, {}, {}, {}&gt;\".format(\n            self.current_package,\n            self.stringpool_main,\n            self.mTableStrings,\n            self.mKeyStrings,\n        )\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.PackageContext.__init__","title":"<code>__init__(current_package, stringpool_main, mTableStrings, mKeyStrings)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>current_package</code> <code>ARSCResTablePackage</code> required <code>stringpool_main</code> <code>StringBlock</code> required <code>mTableStrings</code> <code>StringBlock</code> required <code>mKeyStrings</code> <code>StringBlock</code> required Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def __init__(\n    self,\n    current_package: ARSCResTablePackage,\n    stringpool_main: StringBlock,\n    mTableStrings: StringBlock,\n    mKeyStrings: StringBlock,\n) -&gt; None:\n    \"\"\"\n    :param current_package:\n    :param stringpool_main:\n    :param mTableStrings:\n    :param mKeyStrings:\n    \"\"\"\n    self.stringpool_main = stringpool_main\n    self.mTableStrings = mTableStrings\n    self.mKeyStrings = mKeyStrings\n    self.current_package = current_package\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.ResParserError","title":"<code>ResParserError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception for the parsers</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>class ResParserError(Exception):\n    \"\"\"Exception for the parsers\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.StringBlock","title":"<code>StringBlock</code>","text":"<p>StringBlock is a CHUNK inside an AXML File: <code>ResStringPool_header</code> It contains all strings, which are used by referencing to ID's</p> <p>See http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#436</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>class StringBlock:\n    \"\"\"\n    StringBlock is a CHUNK inside an AXML File: `ResStringPool_header`\n    It contains all strings, which are used by referencing to ID's\n\n    See http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/include/androidfw/ResourceTypes.h#436\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, header: ARSCHeader) -&gt; None:\n        \"\"\"\n        :param buff: buffer which holds the string block\n        :param header: a instance of [ARSCHeader][androguard.core.axml.ARSCHeader]\n        \"\"\"\n        self._cache = {}\n        self.header = header\n        # We already read the header (which was chunk_type and chunk_size\n        # Now, we read the string_count:\n        self.stringCount = unpack('&lt;I', buff.read(4))[0]\n        # style_count\n        self.styleCount = unpack('&lt;I', buff.read(4))[0]\n\n        # flags\n        self.flags = unpack('&lt;I', buff.read(4))[0]\n        self.m_isUTF8 = (self.flags &amp; UTF8_FLAG) != 0\n\n        # string_pool_offset\n        # The string offset is counted from the beginning of the string section\n        self.stringsOffset = unpack('&lt;I', buff.read(4))[0]\n        # check if the stringCount is correct\n        if (\n            self.stringsOffset - (self.styleCount * 4 + 28)\n        ) / 4 != self.stringCount:\n            self.stringCount = int(\n                (self.stringsOffset - (self.styleCount * 4 + 28)) / 4\n            )\n\n        # style_pool_offset\n        # The styles offset is counted as well from the beginning of the string section\n        self.stylesOffset = unpack('&lt;I', buff.read(4))[0]\n\n        # Check if they supplied a stylesOffset even if the count is 0:\n        if self.styleCount == 0 and self.stylesOffset &gt; 0:\n            logger.info(\n                \"Styles Offset given, but styleCount is zero. \"\n                \"This is not a problem but could indicate packers.\"\n            )\n\n        self.m_stringOffsets = []\n        self.m_styleOffsets = []\n        self.m_charbuff = \"\"\n        self.m_styles = []\n\n        # Next, there is a list of string following.\n        # This is only a list of offsets (4 byte each)\n        for i in range(self.stringCount):\n            self.m_stringOffsets.append(unpack('&lt;I', buff.read(4))[0])\n\n        # And a list of styles\n        # again, a list of offsets\n        for i in range(self.styleCount):\n            self.m_styleOffsets.append(unpack('&lt;I', buff.read(4))[0])\n\n        # FIXME it is probably better to parse n strings and not calculate the size\n        size = self.header.size - self.stringsOffset\n\n        # if there are styles as well, we do not want to read them too.\n        # Only read them, if no\n        if self.stylesOffset != 0 and self.styleCount != 0:\n            size = self.stylesOffset - self.stringsOffset\n\n        if (size % 4) != 0:\n            logger.warning(\"Size of strings is not aligned by four bytes.\")\n\n        self.m_charbuff = buff.read(size)\n\n        if self.stylesOffset != 0 and self.styleCount != 0:\n            size = self.header.size - self.stylesOffset\n\n            if (size % 4) != 0:\n                logger.warning(\"Size of styles is not aligned by four bytes.\")\n\n            for i in range(0, size // 4):\n                self.m_styles.append(unpack('&lt;I', buff.read(4))[0])\n\n    def __repr__(self):\n        return \"&lt;StringPool #strings={}, #styles={}, UTF8={}&gt;\".format(\n            self.stringCount, self.styleCount, self.m_isUTF8\n        )\n\n    def __getitem__(self, idx):\n        \"\"\"\n        Returns the string at the index in the string table\n\n        :returns: the string\n        \"\"\"\n        return self.getString(idx)\n\n    def __len__(self):\n        \"\"\"\n        Get the number of strings stored in this table\n\n        :return: the number of strings\n        \"\"\"\n        return self.stringCount\n\n    def __iter__(self):\n        \"\"\"\n        Iterable over all strings\n\n        :returns: a generator over all strings\n        \"\"\"\n        for i in range(self.stringCount):\n            yield self.getString(i)\n\n    def getString(self, idx: int) -&gt; str:\n        \"\"\"\n        Return the string at the index in the string table\n\n        :param idx: index in the string table\n        :return: the string\n        \"\"\"\n        if idx in self._cache:\n            return self._cache[idx]\n\n        if idx &lt; 0 or not self.m_stringOffsets or idx &gt;= self.stringCount:\n            return \"\"\n\n        offset = self.m_stringOffsets[idx]\n\n        if self.m_isUTF8:\n            self._cache[idx] = self._decode8(offset)\n        else:\n            self._cache[idx] = self._decode16(offset)\n\n        return self._cache[idx]\n\n    def getStyle(self, idx: int) -&gt; int:\n        \"\"\"\n        Return the style associated with the index\n\n        :param idx: index of the style\n        :return: the style integer\n        \"\"\"\n        return self.m_styles[idx]\n\n    def _decode8(self, offset: int) -&gt; str:\n        \"\"\"\n        Decode an UTF-8 String at the given offset\n\n        :param offset: offset of the string inside the data\n        :raises ResParserError: if string is not null terminated\n        :return: the decoded string\n        \"\"\"\n        # UTF-8 Strings contain two lengths, as they might differ:\n        # 1) the UTF-16 length\n        str_len, skip = self._decode_length(offset, 1)\n        offset += skip\n\n        # 2) the utf-8 string length\n        encoded_bytes, skip = self._decode_length(offset, 1)\n        offset += skip\n\n        # Two checks should happen here:\n        # a) offset + encoded_bytes surpassing the string_pool length and\n        # b) non-null terminated strings which should be rejected\n        # platform/frameworks/base/libs/androidfw/ResourceTypes.cpp#789\n        if len(self.m_charbuff) &lt; (offset + encoded_bytes):\n            logger.warning(\n                f\"String size: {offset + encoded_bytes} is exceeding string pool size. Returning empty string.\"\n            )\n            return \"\"\n        data = self.m_charbuff[offset : offset + encoded_bytes]\n\n        if self.m_charbuff[offset + encoded_bytes] != 0:\n            raise ResParserError(\n                \"UTF-8 String is not null terminated! At offset={}\".format(\n                    offset\n                )\n            )\n\n        return self._decode_bytes(data, 'utf-8', str_len)\n\n    def _decode16(self, offset: int) -&gt; str:\n        \"\"\"\n        Decode an UTF-16 String at the given offset\n\n        :param offset: offset of the string inside the data\n        :raises ResParserError: if string is not null terminated\n\n        :return: the decoded string\n        \"\"\"\n        str_len, skip = self._decode_length(offset, 2)\n        offset += skip\n\n        # The len is the string len in utf-16 units\n        encoded_bytes = str_len * 2\n\n        # Two checks should happen here:\n        # a) offset + encoded_bytes surpassing the string_pool length and\n        # b) non-null terminated strings which should be rejected\n        # platform/frameworks/base/libs/androidfw/ResourceTypes.cpp#789\n        if len(self.m_charbuff) &lt; (offset + encoded_bytes):\n            logger.warning(\n                f\"String size: {offset + encoded_bytes} is exceeding string pool size. Returning empty string.\"\n            )\n            return \"\"\n\n        data = self.m_charbuff[offset : offset + encoded_bytes]\n\n        if (\n            self.m_charbuff[\n                offset + encoded_bytes : offset + encoded_bytes + 2\n            ]\n            != b\"\\x00\\x00\"\n        ):\n            raise ResParserError(\n                \"UTF-16 String is not null terminated! At offset={}\".format(\n                    offset\n                )\n            )\n\n        return self._decode_bytes(data, 'utf-16', str_len)\n\n    @staticmethod\n    def _decode_bytes(data: bytes, encoding: str, str_len: int) -&gt; str:\n        \"\"\"\n        Generic decoding with length check.\n        The string is decoded from bytes with the given encoding, then the length\n        of the string is checked.\n        The string is decoded using the \"replace\" method.\n\n        :param data: bytes\n        :param encoding: encoding name (\"utf-8\" or \"utf-16\")\n        :param str_len: length of the decoded string\n        :return: the decoded bytes\n        \"\"\"\n        string = data.decode(encoding, 'replace')\n        if len(string) != str_len:\n            logger.warning(\"invalid decoded string length\")\n        return string\n\n    def _decode_length(self, offset: int, sizeof_char: int) -&gt; tuple[int, int]:\n        \"\"\"\n        Generic Length Decoding at offset of string\n\n        The method works for both 8 and 16 bit Strings.\n        Length checks are enforced:\n        * 8 bit strings: maximum of 0x7FFF bytes (See\n        http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/ResourceTypes.cpp#692)\n        * 16 bit strings: maximum of 0x7FFFFFF bytes (See\n        http://androidxref.com/9.0.0_r3/xref/frameworks/base/libs/androidfw/ResourceTypes.cpp#670)\n\n        :param offset: offset into the string data section of the beginning of\n        the string\n        :param sizeof_char: number of bytes per char (1 = 8bit, 2 = 16bit)\n        :returns: tuple of (length, read bytes)\n        \"\"\"\n        sizeof_2chars = sizeof_char &lt;&lt; 1\n        fmt = \"&lt;2{}\".format('B' if sizeof_char == 1 else 'H')\n        highbit = 0x80 &lt;&lt; (8 * (sizeof_char - 1))\n\n        length1, length2 = unpack(\n            fmt, self.m_charbuff[offset : (offset + sizeof_2chars)]\n        )\n\n        if (length1 &amp; highbit) != 0:\n            length = ((length1 &amp; ~highbit) &lt;&lt; (8 * sizeof_char)) | length2\n            size = sizeof_2chars\n        else:\n            length = length1\n            size = sizeof_char\n\n        # These are true asserts, as the size should never be less than the values\n        if sizeof_char == 1:\n            assert (\n                length &lt;= 0x7FFF\n            ), \"length of UTF-8 string is too large! At offset={}\".format(\n                offset\n            )\n        else:\n            assert (\n                length &lt;= 0x7FFFFFFF\n            ), \"length of UTF-16 string is too large!  At offset={}\".format(\n                offset\n            )\n\n        return length, size\n\n    def show(self) -&gt; None:\n        \"\"\"\n        Print some information on stdout about the string table\n        \"\"\"\n        print(\n            \"StringBlock(stringsCount=0x%x, \"\n            \"stringsOffset=0x%x, \"\n            \"stylesCount=0x%x, \"\n            \"stylesOffset=0x%x, \"\n            \"flags=0x%x\"\n            \")\"\n            % (\n                self.stringCount,\n                self.stringsOffset,\n                self.styleCount,\n                self.stylesOffset,\n                self.flags,\n            )\n        )\n\n        if self.stringCount &gt; 0:\n            print()\n            print(\"String Table: \")\n            for i, s in enumerate(self):\n                print(\"{:08d} {}\".format(i, repr(s)))\n\n        if self.styleCount &gt; 0:\n            print()\n            print(\"Styles Table: \")\n            for i in range(self.styleCount):\n                print(\"{:08d} {}\".format(i, repr(self.getStyle(i))))\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.StringBlock.__getitem__","title":"<code>__getitem__(idx)</code>","text":"<p>Returns the string at the index in the string table</p> <p>Returns:</p> Type Description <p>the string</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def __getitem__(self, idx):\n    \"\"\"\n    Returns the string at the index in the string table\n\n    :returns: the string\n    \"\"\"\n    return self.getString(idx)\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.StringBlock.__init__","title":"<code>__init__(buff, header)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>buffer which holds the string block</p> required <code>header</code> <code>ARSCHeader</code> <p>a instance of ARSCHeader</p> required Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def __init__(self, buff: BinaryIO, header: ARSCHeader) -&gt; None:\n    \"\"\"\n    :param buff: buffer which holds the string block\n    :param header: a instance of [ARSCHeader][androguard.core.axml.ARSCHeader]\n    \"\"\"\n    self._cache = {}\n    self.header = header\n    # We already read the header (which was chunk_type and chunk_size\n    # Now, we read the string_count:\n    self.stringCount = unpack('&lt;I', buff.read(4))[0]\n    # style_count\n    self.styleCount = unpack('&lt;I', buff.read(4))[0]\n\n    # flags\n    self.flags = unpack('&lt;I', buff.read(4))[0]\n    self.m_isUTF8 = (self.flags &amp; UTF8_FLAG) != 0\n\n    # string_pool_offset\n    # The string offset is counted from the beginning of the string section\n    self.stringsOffset = unpack('&lt;I', buff.read(4))[0]\n    # check if the stringCount is correct\n    if (\n        self.stringsOffset - (self.styleCount * 4 + 28)\n    ) / 4 != self.stringCount:\n        self.stringCount = int(\n            (self.stringsOffset - (self.styleCount * 4 + 28)) / 4\n        )\n\n    # style_pool_offset\n    # The styles offset is counted as well from the beginning of the string section\n    self.stylesOffset = unpack('&lt;I', buff.read(4))[0]\n\n    # Check if they supplied a stylesOffset even if the count is 0:\n    if self.styleCount == 0 and self.stylesOffset &gt; 0:\n        logger.info(\n            \"Styles Offset given, but styleCount is zero. \"\n            \"This is not a problem but could indicate packers.\"\n        )\n\n    self.m_stringOffsets = []\n    self.m_styleOffsets = []\n    self.m_charbuff = \"\"\n    self.m_styles = []\n\n    # Next, there is a list of string following.\n    # This is only a list of offsets (4 byte each)\n    for i in range(self.stringCount):\n        self.m_stringOffsets.append(unpack('&lt;I', buff.read(4))[0])\n\n    # And a list of styles\n    # again, a list of offsets\n    for i in range(self.styleCount):\n        self.m_styleOffsets.append(unpack('&lt;I', buff.read(4))[0])\n\n    # FIXME it is probably better to parse n strings and not calculate the size\n    size = self.header.size - self.stringsOffset\n\n    # if there are styles as well, we do not want to read them too.\n    # Only read them, if no\n    if self.stylesOffset != 0 and self.styleCount != 0:\n        size = self.stylesOffset - self.stringsOffset\n\n    if (size % 4) != 0:\n        logger.warning(\"Size of strings is not aligned by four bytes.\")\n\n    self.m_charbuff = buff.read(size)\n\n    if self.stylesOffset != 0 and self.styleCount != 0:\n        size = self.header.size - self.stylesOffset\n\n        if (size % 4) != 0:\n            logger.warning(\"Size of styles is not aligned by four bytes.\")\n\n        for i in range(0, size // 4):\n            self.m_styles.append(unpack('&lt;I', buff.read(4))[0])\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.StringBlock.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterable over all strings</p> <p>Returns:</p> Type Description <p>a generator over all strings</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def __iter__(self):\n    \"\"\"\n    Iterable over all strings\n\n    :returns: a generator over all strings\n    \"\"\"\n    for i in range(self.stringCount):\n        yield self.getString(i)\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.StringBlock.__len__","title":"<code>__len__()</code>","text":"<p>Get the number of strings stored in this table</p> <p>Returns:</p> Type Description <p>the number of strings</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def __len__(self):\n    \"\"\"\n    Get the number of strings stored in this table\n\n    :return: the number of strings\n    \"\"\"\n    return self.stringCount\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.StringBlock.getString","title":"<code>getString(idx)</code>","text":"<p>Return the string at the index in the string table</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>index in the string table</p> required <p>Returns:</p> Type Description <code>str</code> <p>the string</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def getString(self, idx: int) -&gt; str:\n    \"\"\"\n    Return the string at the index in the string table\n\n    :param idx: index in the string table\n    :return: the string\n    \"\"\"\n    if idx in self._cache:\n        return self._cache[idx]\n\n    if idx &lt; 0 or not self.m_stringOffsets or idx &gt;= self.stringCount:\n        return \"\"\n\n    offset = self.m_stringOffsets[idx]\n\n    if self.m_isUTF8:\n        self._cache[idx] = self._decode8(offset)\n    else:\n        self._cache[idx] = self._decode16(offset)\n\n    return self._cache[idx]\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.StringBlock.getStyle","title":"<code>getStyle(idx)</code>","text":"<p>Return the style associated with the index</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>index of the style</p> required <p>Returns:</p> Type Description <code>int</code> <p>the style integer</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def getStyle(self, idx: int) -&gt; int:\n    \"\"\"\n    Return the style associated with the index\n\n    :param idx: index of the style\n    :return: the style integer\n    \"\"\"\n    return self.m_styles[idx]\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.StringBlock.show","title":"<code>show()</code>","text":"<p>Print some information on stdout about the string table</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"\n    Print some information on stdout about the string table\n    \"\"\"\n    print(\n        \"StringBlock(stringsCount=0x%x, \"\n        \"stringsOffset=0x%x, \"\n        \"stylesCount=0x%x, \"\n        \"stylesOffset=0x%x, \"\n        \"flags=0x%x\"\n        \")\"\n        % (\n            self.stringCount,\n            self.stringsOffset,\n            self.styleCount,\n            self.stylesOffset,\n            self.flags,\n        )\n    )\n\n    if self.stringCount &gt; 0:\n        print()\n        print(\"String Table: \")\n        for i, s in enumerate(self):\n            print(\"{:08d} {}\".format(i, repr(s)))\n\n    if self.styleCount &gt; 0:\n        print()\n        print(\"Styles Table: \")\n        for i in range(self.styleCount):\n            print(\"{:08d} {}\".format(i, repr(self.getStyle(i))))\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.complexToFloat","title":"<code>complexToFloat(xcomplex)</code>","text":"<p>Convert a complex unit into float</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def complexToFloat(xcomplex) -&gt; float:\n    \"\"\"\n    Convert a complex unit into float\n    \"\"\"\n    return float(xcomplex &amp; 0xFFFFFF00) * RADIX_MULTS[(xcomplex &gt;&gt; 4) &amp; 3]\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.format_value","title":"<code>format_value(_type, _data, lookup_string=lambda ix: '&lt;string&gt;')</code>","text":"<p>Format a value based on type and data. By default, no strings are looked up and <code>\"&lt;string&gt;\"</code> is returned. You need to define <code>lookup_string</code> in order to actually lookup strings from the string table.</p> <p>Parameters:</p> Name Type Description Default <code>_type</code> <code>int</code> <p>The numeric type of the value</p> required <code>_data</code> <code>int</code> <p>The numeric data of the value</p> required <code>lookup_string</code> <p>A function how to resolve strings from integer IDs</p> <code>lambda ix: '&lt;string&gt;'</code> <p>Returns:</p> Type Description <code>str</code> <p>the formatted string</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def format_value(\n    _type: int, _data: int, lookup_string=lambda ix: \"&lt;string&gt;\"\n) -&gt; str:\n    \"\"\"\n    Format a value based on type and data.\n    By default, no strings are looked up and `\"&lt;string&gt;\"` is returned.\n    You need to define `lookup_string` in order to actually lookup strings from\n    the string table.\n\n    :param _type: The numeric type of the value\n    :param _data: The numeric data of the value\n    :param lookup_string: A function how to resolve strings from integer IDs\n    :returns: the formatted string\n    \"\"\"\n\n    # Function to prepend android prefix for attributes/references from the\n    # android library\n    fmt_package = lambda x: \"android:\" if x &gt;&gt; 24 == 1 else \"\"\n\n    # Function to represent integers\n    fmt_int = lambda x: (0x7FFFFFFF &amp; x) - 0x80000000 if x &gt; 0x7FFFFFFF else x\n\n    if _type == TYPE_STRING:\n        return lookup_string(_data)\n\n    elif _type == TYPE_ATTRIBUTE:\n        return \"?{}{:08X}\".format(fmt_package(_data), _data)\n\n    elif _type == TYPE_REFERENCE:\n        return \"@{}{:08X}\".format(fmt_package(_data), _data)\n\n    elif _type == TYPE_FLOAT:\n        return \"%f\" % unpack(\"=f\", pack(\"=L\", _data))[0]\n\n    elif _type == TYPE_INT_HEX:\n        return \"0x%08X\" % _data\n\n    elif _type == TYPE_INT_BOOLEAN:\n        if _data == 0:\n            return \"false\"\n        return \"true\"\n\n    elif _type == TYPE_DIMENSION:\n        return \"{:f}{}\".format(\n            complexToFloat(_data), DIMENSION_UNITS[_data &amp; COMPLEX_UNIT_MASK]\n        )\n\n    elif _type == TYPE_FRACTION:\n        return \"{:f}{}\".format(\n            complexToFloat(_data) * 100,\n            FRACTION_UNITS[_data &amp; COMPLEX_UNIT_MASK],\n        )\n\n    elif TYPE_FIRST_COLOR_INT &lt;= _type &lt;= TYPE_LAST_COLOR_INT:\n        return \"#%08X\" % _data\n\n    elif TYPE_FIRST_INT &lt;= _type &lt;= TYPE_LAST_INT:\n        return \"%d\" % fmt_int(_data)\n\n    return \"&lt;0x{:X}, type 0x{:02X}&gt;\".format(_data, _type)\n</code></pre>"},{"location":"reference/androguard/core/axml/index.html#androguard.core.axml.get_arsc_info","title":"<code>get_arsc_info(arscobj)</code>","text":"<p>Return a string containing all resources packages ordered by packagename, locale and type.</p> <p>Parameters:</p> Name Type Description Default <code>arscobj</code> <code>ARSCParser</code> <p>ARSCParser</p> required <p>Returns:</p> Type Description <code>str</code> <p>a string</p> Source code in <code>androguard/core/axml/__init__.py</code> <pre><code>def get_arsc_info(arscobj: ARSCParser) -&gt; str:\n    \"\"\"\n    Return a string containing all resources packages ordered by packagename, locale and type.\n\n    :param arscobj: [ARSCParser][androguard.core.axml.ARSCParser]\n    :return: a string\n    \"\"\"\n    buff = \"\"\n    for package in arscobj.get_packages_names():\n        buff += package + \":\\n\"\n        for locale in arscobj.get_locales(package):\n            buff += \"\\t\" + repr(locale) + \":\\n\"\n            for ttype in arscobj.get_types(package, locale):\n                buff += \"\\t\\t\" + ttype + \":\\n\"\n                try:\n                    tmp_buff = (\n                        getattr(arscobj, \"get_\" + ttype + \"_resources\")(\n                            package, locale\n                        )\n                        .decode(\"utf-8\", 'replace')\n                        .split(\"\\n\")\n                    )\n                    for i in tmp_buff:\n                        buff += \"\\t\\t\\t\" + i + \"\\n\"\n                except AttributeError:\n                    pass\n    return buff\n</code></pre>"},{"location":"reference/androguard/core/axml/types.html","title":"types","text":""},{"location":"reference/androguard/core/dex/index.html","title":"dex","text":""},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.AnnotationElement","title":"<code>AnnotationElement</code>","text":"<p>This class can parse an <code>annotation_element</code> of a dex file</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a buff object of the <code>annotation_element</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class AnnotationElement:\n    \"\"\"\n    This class can parse an `annotation_element` of a dex file\n\n    :param buff: a string which represents a buff object of the `annotation_element`\n    :param cm: a `ClassManager` object\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm: ClassManager) -&gt; None:\n        self.CM = cm\n        self.offset = buff.tell()\n\n        self.name_idx = readuleb128(cm, buff)\n        self.value = EncodedValue(buff, cm)\n\n    def get_name_idx(self) -&gt; int:\n        \"\"\"\n        Return the index to the element name, represented as an index into the `string_ids` section\n\n        :returns: the index to the name\n        \"\"\"\n        return self.name_idx\n\n    def get_value(self) -&gt; EncodedValue:\n        \"\"\"\n        Return the element value ([EncodedValue][androguard.core.dex.EncodedValue])\n\n        :returns: a :`EncodedValue` object\n        \"\"\"\n        return self.value\n\n    def show(self):\n        bytecode._PrintSubBanner(\"Annotation Element\")\n        bytecode._PrintDefault(\"name_idx=%d\\n\" % self.name_idx)\n        self.value.show()\n\n    def get_obj(self):\n        return writeuleb128(self.CM, self.name_idx)\n\n    def get_raw(self):\n        return self.get_obj() + self.value.get_raw()\n\n    def get_length(self):\n        return len(self.get_obj()) + self.value.get_length()\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.AnnotationElement.get_name_idx","title":"<code>get_name_idx()</code>","text":"<p>Return the index to the element name, represented as an index into the <code>string_ids</code> section</p> <p>Returns:</p> Type Description <code>int</code> <p>the index to the name</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_name_idx(self) -&gt; int:\n    \"\"\"\n    Return the index to the element name, represented as an index into the `string_ids` section\n\n    :returns: the index to the name\n    \"\"\"\n    return self.name_idx\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.AnnotationElement.get_value","title":"<code>get_value()</code>","text":"<p>Return the element value (EncodedValue)</p> <p>Returns:</p> Type Description <code>EncodedValue</code> <p>a :<code>EncodedValue</code> object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_value(self) -&gt; EncodedValue:\n    \"\"\"\n    Return the element value ([EncodedValue][androguard.core.dex.EncodedValue])\n\n    :returns: a :`EncodedValue` object\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.AnnotationItem","title":"<code>AnnotationItem</code>","text":"<p>This class can parse an <code>annotation_item</code> of a dex file</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class AnnotationItem:\n    \"\"\"\n    This class can parse an `annotation_item` of a dex file\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm:ClassManager) -&gt; None:\n        \"\"\"\n        :param buff: a string which represents a Buff object of the `annotation_item`\n        :param cm: a `ClassManager` object \n        \"\"\"\n        self.CM = cm\n\n        self.offset = buff.tell()\n\n        self.visibility = get_byte(cm, buff)\n        self.annotation = EncodedAnnotation(buff, cm)\n\n    def get_visibility(self) -&gt; int:\n        \"\"\"\n        Return the intended visibility of this annotation\n\n        :returns: the visibility of the annotation\n        \"\"\"\n        return self.visibility\n\n    def get_annotation(self) -&gt; EncodedAnnotation:\n        \"\"\"\n        Return the encoded annotation contents\n\n        :returns: a `EncodedAnnotation` object\n        \"\"\"\n        return self.annotation\n\n    def set_off(self, off: int) -&gt; None:\n        self.offset = off\n\n    def get_off(self) -&gt; int:\n        return self.offset\n\n    def show(self) -&gt; None:\n        bytecode._PrintSubBanner(\"Annotation Item\")\n        bytecode._PrintDefault(\"visibility=%d\\n\" % self.visibility)\n        self.annotation.show()\n\n    def get_obj(self) -&gt; list[EncodedAnnotation]:\n        return [self.annotation]\n\n    def get_raw(self) -&gt; bytes:\n        return (\n            self.CM.packer[\"B\"].pack(self.visibility)\n            + self.annotation.get_raw()\n        )\n\n    def get_length(self) -&gt; int:\n        return len(self.get_raw())\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.AnnotationItem.__init__","title":"<code>__init__(buff, cm)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a Buff object of the <code>annotation_item</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def __init__(self, buff: BinaryIO, cm:ClassManager) -&gt; None:\n    \"\"\"\n    :param buff: a string which represents a Buff object of the `annotation_item`\n    :param cm: a `ClassManager` object \n    \"\"\"\n    self.CM = cm\n\n    self.offset = buff.tell()\n\n    self.visibility = get_byte(cm, buff)\n    self.annotation = EncodedAnnotation(buff, cm)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.AnnotationItem.get_annotation","title":"<code>get_annotation()</code>","text":"<p>Return the encoded annotation contents</p> <p>Returns:</p> Type Description <code>EncodedAnnotation</code> <p>a <code>EncodedAnnotation</code> object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_annotation(self) -&gt; EncodedAnnotation:\n    \"\"\"\n    Return the encoded annotation contents\n\n    :returns: a `EncodedAnnotation` object\n    \"\"\"\n    return self.annotation\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.AnnotationItem.get_visibility","title":"<code>get_visibility()</code>","text":"<p>Return the intended visibility of this annotation</p> <p>Returns:</p> Type Description <code>int</code> <p>the visibility of the annotation</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_visibility(self) -&gt; int:\n    \"\"\"\n    Return the intended visibility of this annotation\n\n    :returns: the visibility of the annotation\n    \"\"\"\n    return self.visibility\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.AnnotationOffItem","title":"<code>AnnotationOffItem</code>","text":"<p>This class can parse an <code>annotation_off_item</code> of a dex file</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a Buff object of the <code>annotation_off_item</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class AnnotationOffItem:\n    \"\"\"\n    This class can parse an `annotation_off_item` of a dex file\n\n    :param buff: a string which represents a Buff object of the `annotation_off_item`\n    :param cm: a `ClassManager` object\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm: ClassManager) -&gt; None:\n        self.CM = cm\n        (self.annotation_off,) = cm.packer[\"I\"].unpack(buff.read(4))\n\n    def get_annotation_off(self) -&gt; int:\n        return self.annotation_off\n\n    def show(self):\n        bytecode._PrintSubBanner(\"Annotation Off Item\")\n        bytecode._PrintDefault(\"annotation_off=0x%x\\n\" % self.annotation_off)\n\n    def get_obj(self) -&gt; bytes:\n        if self.annotation_off != 0:\n            self.annotation_off = self.CM.get_obj_by_offset(\n                self.annotation_off\n            ).get_off()\n\n        return self.CM.packer[\"I\"].pack(self.annotation_off)\n\n    def get_raw(self) -&gt; bytes:\n        return self.get_obj()\n\n    def get_length(self) -&gt; int:\n        return len(self.get_obj())\n\n    def get_annotation_item(self) -&gt; AnnotationItem:\n        return self.CM.get_annotation_item(self.get_annotation_off())\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.AnnotationSetItem","title":"<code>AnnotationSetItem</code>","text":"<p>This class can parse an <code>annotation_set_item</code> of a dex file</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a buff object of the <code>annotation_set_item</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class AnnotationSetItem:\n    \"\"\"\n    This class can parse an `annotation_set_item` of a dex file\n\n    :param buff: a string which represents a buff object of the `annotation_set_item`\n    :param cm: a `ClassManager` object\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm: ClassManager) -&gt; None:\n        self.CM = cm\n        self.offset = buff.tell()\n\n        (self.size,) = cm.packer[\"I\"].unpack(buff.read(4))\n        self.annotation_off_item = [\n            AnnotationOffItem(buff, cm) for _ in range(self.size)\n        ]\n\n    def get_annotation_off_item(self) -&gt; list[AnnotationOffItem]:\n        \"\"\"\n        Return the offset from the start of the file to an annotation\n\n        :returns: a list of `AnnotationOffItem`\n        \"\"\"\n        return self.annotation_off_item\n\n    def set_off(self, off: int) -&gt; None:\n        self.offset = off\n\n    def get_off(self) -&gt; int:\n        return self.offset\n\n    def show(self) -&gt; None:\n        bytecode._PrintSubBanner(\"Annotation Set Item\")\n        for i in self.annotation_off_item:\n            i.show()\n\n    def get_obj(self) -&gt; bytes:\n        return self.CM.packer[\"I\"].pack(self.size)\n\n    def get_raw(self) -&gt; bytes:\n        return self.get_obj() + b''.join(\n            i.get_raw() for i in self.annotation_off_item\n        )\n\n    def get_length(self) -&gt; int:\n        length = len(self.get_obj())\n\n        for i in self.annotation_off_item:\n            length += i.get_length()\n\n        return length\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.AnnotationSetItem.get_annotation_off_item","title":"<code>get_annotation_off_item()</code>","text":"<p>Return the offset from the start of the file to an annotation</p> <p>Returns:</p> Type Description <code>list[AnnotationOffItem]</code> <p>a list of <code>AnnotationOffItem</code></p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_annotation_off_item(self) -&gt; list[AnnotationOffItem]:\n    \"\"\"\n    Return the offset from the start of the file to an annotation\n\n    :returns: a list of `AnnotationOffItem`\n    \"\"\"\n    return self.annotation_off_item\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.AnnotationSetRefItem","title":"<code>AnnotationSetRefItem</code>","text":"<p>This class can parse an <code>annotation_set_ref_item</code> of a dex file</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class AnnotationSetRefItem:\n    \"\"\"\n    This class can parse an `annotation_set_ref_item` of a dex file\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm:ClassManager) -&gt; None:\n        \"\"\"\n        :param buff: a string which represents a Buff object of the `annotation_set_ref_item`\n        :param cm: a `ClassManager` object\n        \"\"\"\n        self.CM = cm\n        (self.annotations_off,) = cm.packer[\"I\"].unpack(buff.read(4))\n\n    def get_annotations_off(self) -&gt; int:\n        \"\"\"\n        Return the offset from the start of the file to the referenced annotation set or\n        0 if there are no annotations for this element.\n\n        :returns: the offset\n        \"\"\"\n        return self.annotations_off\n\n    def show(self) -&gt; str:\n        bytecode._PrintSubBanner(\"Annotation Set Ref Item\")\n        bytecode._PrintDefault(\"annotation_off=0x%x\\n\" % self.annotations_off)\n\n    def get_obj(self) -&gt; bytes:\n        if self.annotations_off != 0:\n            self.annotations_off = self.CM.get_obj_by_offset(\n                self.annotations_off\n            ).get_off()\n\n        return self.CM.packer[\"I\"].pack(self.annotations_off)\n\n    def get_raw(self) -&gt; bytes:\n        return self.get_obj()\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.AnnotationSetRefItem.__init__","title":"<code>__init__(buff, cm)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a Buff object of the <code>annotation_set_ref_item</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def __init__(self, buff: BinaryIO, cm:ClassManager) -&gt; None:\n    \"\"\"\n    :param buff: a string which represents a Buff object of the `annotation_set_ref_item`\n    :param cm: a `ClassManager` object\n    \"\"\"\n    self.CM = cm\n    (self.annotations_off,) = cm.packer[\"I\"].unpack(buff.read(4))\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.AnnotationSetRefItem.get_annotations_off","title":"<code>get_annotations_off()</code>","text":"<p>Return the offset from the start of the file to the referenced annotation set or 0 if there are no annotations for this element.</p> <p>Returns:</p> Type Description <code>int</code> <p>the offset</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_annotations_off(self) -&gt; int:\n    \"\"\"\n    Return the offset from the start of the file to the referenced annotation set or\n    0 if there are no annotations for this element.\n\n    :returns: the offset\n    \"\"\"\n    return self.annotations_off\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.AnnotationSetRefList","title":"<code>AnnotationSetRefList</code>","text":"<p>This class can parse an <code>annotation_set_ref_list_item</code> of a dex file</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class AnnotationSetRefList:\n    \"\"\"\n    This class can parse an `annotation_set_ref_list_item` of a dex file\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm:ClassManager) -&gt; None:\n        \"\"\"\n        :param buff: a string which represents a Buff object of the `annotation_set_ref_list_item`\n        :param cm: a ClassManager object\n        \"\"\"\n        self.offset = buff.tell()\n\n        self.CM = cm\n        (self.size,) = cm.packer[\"I\"].unpack(buff.read(4))\n\n        self.list = [AnnotationSetRefItem(buff, cm) for _ in range(self.size)]\n\n    def get_list(self) -&gt; list[AnnotationSetRefItem]:\n        \"\"\"\n        Return list of [AnnotationSetRefItem][androguard.core.dex.AnnotationSetRefItem]\n\n        :returns: list of `AnnotationSetRefItem`\n        \"\"\"\n        return self.list\n\n    def get_off(self) -&gt; int:\n        return self.offset\n\n    def set_off(self, off: int) -&gt; None:\n        self.offset = off\n\n    def show(self) -&gt; None:\n        bytecode._PrintSubBanner(\"Annotation Set Ref List Item\")\n        for i in self.list:\n            i.show()\n\n    def get_obj(self) -&gt; list[AnnotationSetRefItem]:\n        return [i for i in self.list]\n\n    def get_raw(self) -&gt; bytes:\n        return self.CM.packer[\"I\"].pack(self.size) + b''.join(\n            i.get_raw() for i in self.list\n        )\n\n    def get_length(self) -&gt; int:\n        return len(self.get_raw())\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.AnnotationSetRefList.__init__","title":"<code>__init__(buff, cm)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a Buff object of the <code>annotation_set_ref_list_item</code></p> required <code>cm</code> <code>ClassManager</code> <p>a ClassManager object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def __init__(self, buff: BinaryIO, cm:ClassManager) -&gt; None:\n    \"\"\"\n    :param buff: a string which represents a Buff object of the `annotation_set_ref_list_item`\n    :param cm: a ClassManager object\n    \"\"\"\n    self.offset = buff.tell()\n\n    self.CM = cm\n    (self.size,) = cm.packer[\"I\"].unpack(buff.read(4))\n\n    self.list = [AnnotationSetRefItem(buff, cm) for _ in range(self.size)]\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.AnnotationSetRefList.get_list","title":"<code>get_list()</code>","text":"<p>Return list of AnnotationSetRefItem</p> <p>Returns:</p> Type Description <code>list[AnnotationSetRefItem]</code> <p>list of <code>AnnotationSetRefItem</code></p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_list(self) -&gt; list[AnnotationSetRefItem]:\n    \"\"\"\n    Return list of [AnnotationSetRefItem][androguard.core.dex.AnnotationSetRefItem]\n\n    :returns: list of `AnnotationSetRefItem`\n    \"\"\"\n    return self.list\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.AnnotationsDirectoryItem","title":"<code>AnnotationsDirectoryItem</code>","text":"<p>This class can parse an <code>annotations_directory_item</code> of a dex file</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class AnnotationsDirectoryItem:\n    \"\"\"\n    This class can parse an `annotations_directory_item` of a dex file\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm:ClassManager) -&gt; None:\n        \"\"\"\n        :param buff: a string which represents a Buff object of the `annotations_directory_item`\n        :param cm: a `ClassManager` object\n        \"\"\"\n        self.CM = cm\n\n        self.offset = buff.tell()\n\n        (\n            self.class_annotations_off,\n            self.annotated_fields_size,\n            self.annotated_methods_size,\n            self.annotated_parameters_size,\n        ) = cm.packer[\"4I\"].unpack(buff.read(16))\n\n        self.field_annotations = [\n            FieldAnnotation(buff, cm)\n            for i in range(0, self.annotated_fields_size)\n        ]\n\n        self.method_annotations = [\n            MethodAnnotation(buff, cm)\n            for i in range(0, self.annotated_methods_size)\n        ]\n\n        self.parameter_annotations = [\n            ParameterAnnotation(buff, cm)\n            for i in range(0, self.annotated_parameters_size)\n        ]\n\n    def get_class_annotations_off(self) -&gt; int:\n        \"\"\"\n        Return the offset from the start of the file to the annotations made directly on the class,\n        or 0 if the class has no direct annotations\n\n        :returns: the offset\n        \"\"\"\n        return self.class_annotations_off\n\n    def get_annotation_set_item(self) -&gt; list[AnnotationSetItem]:\n        return self.CM.get_annotation_set_item(self.class_annotations_off)\n\n    def get_annotated_fields_size(self) -&gt; int:\n        \"\"\"\n        Return the count of fields annotated by this item\n\n        :returns: the offset\n        \"\"\"\n        return self.annotated_fields_size\n\n    def get_annotated_methods_size(self) -&gt; int:\n        \"\"\"\n        Return the count of methods annotated by this item\n\n        :returns: the count of methods\n        \"\"\"\n        return self.annotated_methods_size\n\n    def get_annotated_parameters_size(self) -&gt; int:\n        \"\"\"\n        Return the count of method parameter lists annotated by this item\n\n        :returns: the count of method parameter lists\n        \"\"\"\n        return self.annotated_parameters_size\n\n    def get_field_annotations(self) -&gt; list[FieldAnnotation]:\n        \"\"\"\n        Return the list of associated [FieldAnnotation][androguard.core.dex.FieldAnnotation]\n\n        :returns: a list of `FieldAnnotation`\n        \"\"\"\n        return self.field_annotations\n\n    def get_method_annotations(self) -&gt; list[MethodAnnotation]:\n        \"\"\"\n        Return the list of associated [MethodAnnotation][androguard.core.dex.MethodAnnotation]\n\n        :returns: a list of `MethodAnnotation`\n        \"\"\"\n        return self.method_annotations\n\n    def get_parameter_annotations(self) -&gt; list[ParameterAnnotation]:\n        \"\"\"\n        Return the list of associated method [ParameterAnnotation][androguard.core.dex.ParameterAnnotation]\n\n        :returns: a list of `ParameterAnnotation`\n        \"\"\"\n        return self.parameter_annotations\n\n    def set_off(self, off: int) -&gt; None:\n        self.offset = off\n\n    def get_off(self) -&gt; int:\n        return self.offset\n\n    def show(self) -&gt; None:\n        bytecode._PrintSubBanner(\"Annotations Directory Item\")\n        bytecode._PrintDefault(\n            \"class_annotations_off=0x%x annotated_fields_size=%d annotated_methods_size=%d annotated_parameters_size=%d\\n\"\n            % (\n                self.class_annotations_off,\n                self.annotated_fields_size,\n                self.annotated_methods_size,\n                self.annotated_parameters_size,\n            )\n        )\n\n        for i in self.field_annotations:\n            i.show()\n\n        for i in self.method_annotations:\n            i.show()\n\n        for i in self.parameter_annotations:\n            i.show()\n\n    def get_obj(self) -&gt; bytes:\n        if self.class_annotations_off != 0:\n            self.class_annotations_off = self.CM.get_obj_by_offset(\n                self.class_annotations_off\n            ).get_off()\n\n        return self.CM.packer[\"4I\"].pack(\n            self.class_annotations_off,\n            self.annotated_fields_size,\n            self.annotated_methods_size,\n            self.annotated_parameters_size,\n        )\n\n    def get_raw(self) -&gt; bytes:\n        return (\n            self.get_obj()\n            + b''.join(i.get_raw() for i in self.field_annotations)\n            + b''.join(i.get_raw() for i in self.method_annotations)\n            + b''.join(i.get_raw() for i in self.parameter_annotations)\n        )\n\n    def get_length(self) -&gt; int:\n        length = len(self.get_obj())\n        for i in self.field_annotations:\n            length += i.get_length()\n\n        for i in self.method_annotations:\n            length += i.get_length()\n\n        for i in self.parameter_annotations:\n            length += i.get_length()\n\n        return length\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.AnnotationsDirectoryItem.__init__","title":"<code>__init__(buff, cm)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a Buff object of the <code>annotations_directory_item</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def __init__(self, buff: BinaryIO, cm:ClassManager) -&gt; None:\n    \"\"\"\n    :param buff: a string which represents a Buff object of the `annotations_directory_item`\n    :param cm: a `ClassManager` object\n    \"\"\"\n    self.CM = cm\n\n    self.offset = buff.tell()\n\n    (\n        self.class_annotations_off,\n        self.annotated_fields_size,\n        self.annotated_methods_size,\n        self.annotated_parameters_size,\n    ) = cm.packer[\"4I\"].unpack(buff.read(16))\n\n    self.field_annotations = [\n        FieldAnnotation(buff, cm)\n        for i in range(0, self.annotated_fields_size)\n    ]\n\n    self.method_annotations = [\n        MethodAnnotation(buff, cm)\n        for i in range(0, self.annotated_methods_size)\n    ]\n\n    self.parameter_annotations = [\n        ParameterAnnotation(buff, cm)\n        for i in range(0, self.annotated_parameters_size)\n    ]\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.AnnotationsDirectoryItem.get_annotated_fields_size","title":"<code>get_annotated_fields_size()</code>","text":"<p>Return the count of fields annotated by this item</p> <p>Returns:</p> Type Description <code>int</code> <p>the offset</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_annotated_fields_size(self) -&gt; int:\n    \"\"\"\n    Return the count of fields annotated by this item\n\n    :returns: the offset\n    \"\"\"\n    return self.annotated_fields_size\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.AnnotationsDirectoryItem.get_annotated_methods_size","title":"<code>get_annotated_methods_size()</code>","text":"<p>Return the count of methods annotated by this item</p> <p>Returns:</p> Type Description <code>int</code> <p>the count of methods</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_annotated_methods_size(self) -&gt; int:\n    \"\"\"\n    Return the count of methods annotated by this item\n\n    :returns: the count of methods\n    \"\"\"\n    return self.annotated_methods_size\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.AnnotationsDirectoryItem.get_annotated_parameters_size","title":"<code>get_annotated_parameters_size()</code>","text":"<p>Return the count of method parameter lists annotated by this item</p> <p>Returns:</p> Type Description <code>int</code> <p>the count of method parameter lists</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_annotated_parameters_size(self) -&gt; int:\n    \"\"\"\n    Return the count of method parameter lists annotated by this item\n\n    :returns: the count of method parameter lists\n    \"\"\"\n    return self.annotated_parameters_size\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.AnnotationsDirectoryItem.get_class_annotations_off","title":"<code>get_class_annotations_off()</code>","text":"<p>Return the offset from the start of the file to the annotations made directly on the class, or 0 if the class has no direct annotations</p> <p>Returns:</p> Type Description <code>int</code> <p>the offset</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_class_annotations_off(self) -&gt; int:\n    \"\"\"\n    Return the offset from the start of the file to the annotations made directly on the class,\n    or 0 if the class has no direct annotations\n\n    :returns: the offset\n    \"\"\"\n    return self.class_annotations_off\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.AnnotationsDirectoryItem.get_field_annotations","title":"<code>get_field_annotations()</code>","text":"<p>Return the list of associated FieldAnnotation</p> <p>Returns:</p> Type Description <code>list[FieldAnnotation]</code> <p>a list of <code>FieldAnnotation</code></p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_field_annotations(self) -&gt; list[FieldAnnotation]:\n    \"\"\"\n    Return the list of associated [FieldAnnotation][androguard.core.dex.FieldAnnotation]\n\n    :returns: a list of `FieldAnnotation`\n    \"\"\"\n    return self.field_annotations\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.AnnotationsDirectoryItem.get_method_annotations","title":"<code>get_method_annotations()</code>","text":"<p>Return the list of associated MethodAnnotation</p> <p>Returns:</p> Type Description <code>list[MethodAnnotation]</code> <p>a list of <code>MethodAnnotation</code></p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_method_annotations(self) -&gt; list[MethodAnnotation]:\n    \"\"\"\n    Return the list of associated [MethodAnnotation][androguard.core.dex.MethodAnnotation]\n\n    :returns: a list of `MethodAnnotation`\n    \"\"\"\n    return self.method_annotations\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.AnnotationsDirectoryItem.get_parameter_annotations","title":"<code>get_parameter_annotations()</code>","text":"<p>Return the list of associated method ParameterAnnotation</p> <p>Returns:</p> Type Description <code>list[ParameterAnnotation]</code> <p>a list of <code>ParameterAnnotation</code></p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_parameter_annotations(self) -&gt; list[ParameterAnnotation]:\n    \"\"\"\n    Return the list of associated method [ParameterAnnotation][androguard.core.dex.ParameterAnnotation]\n\n    :returns: a list of `ParameterAnnotation`\n    \"\"\"\n    return self.parameter_annotations\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDataItem","title":"<code>ClassDataItem</code>","text":"<p>This class can parse a <code>class_data_item</code> of a dex file</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class ClassDataItem:\n    \"\"\"\n    This class can parse a `class_data_item` of a dex file\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm:ClassManager) -&gt; None:\n        \"\"\"\n        :param buff: a string which represents a Buff object of the `class_data_item`\n        :param cm: a `ClassManager` object\n        \"\"\"\n        self.CM = cm\n\n        self.offset = buff.tell()\n\n        self.static_fields_size = readuleb128(cm, buff)\n        self.instance_fields_size = readuleb128(cm, buff)\n        self.direct_methods_size = readuleb128(cm, buff)\n        self.virtual_methods_size = readuleb128(cm, buff)\n\n        self.static_fields = []\n        self.instance_fields = []\n        self.direct_methods = []\n        self.virtual_methods = []\n\n        self._load_elements(\n            self.static_fields_size, self.static_fields, EncodedField, buff, cm\n        )\n        self._load_elements(\n            self.instance_fields_size,\n            self.instance_fields,\n            EncodedField,\n            buff,\n            cm,\n        )\n        self._load_elements(\n            self.direct_methods_size,\n            self.direct_methods,\n            EncodedMethod,\n            buff,\n            cm,\n        )\n        self._load_elements(\n            self.virtual_methods_size,\n            self.virtual_methods,\n            EncodedMethod,\n            buff,\n            cm,\n        )\n\n    def get_static_fields_size(self) -&gt; int:\n        \"\"\"\n        Return the number of static fields defined in this item\n\n        :returns: number of static fields\n        \"\"\"\n        return self.static_fields_size\n\n    def get_instance_fields_size(self) -&gt; int:\n        \"\"\"\n        Return the number of instance fields defined in this item\n\n        :returns: number of instance fields\n        \"\"\"\n        return self.instance_fields_size\n\n    def get_direct_methods_size(self) -&gt; int:\n        \"\"\"\n        Return the number of direct methods defined in this item\n\n        :returns: number of direct methods\n        \"\"\"\n        return self.direct_methods_size\n\n    def get_virtual_methods_size(self) -&gt; int:\n        \"\"\"\n        Return the number of virtual methods defined in this item\n\n        :returns: number of virtual methods\n        \"\"\"\n        return self.virtual_methods_size\n\n    def get_static_fields(self) -&gt; list[EncodedField]:\n        \"\"\"\n        Return the defined static fields, represented as a sequence of encoded elements\n\n        :returns: a list of `EncodedField` objects\n        \"\"\"\n        return self.static_fields\n\n    def get_instance_fields(self) -&gt; list[EncodedField]:\n        \"\"\"\n        Return the defined instance fields, represented as a sequence of encoded elements\n\n        :returns: list of `EncodedField` objects\n        \"\"\"\n        return self.instance_fields\n\n    def get_direct_methods(self) -&gt; list[EncodedMethod]:\n        \"\"\"\n        Return the defined direct (any of static, private, or constructor) methods, represented as a sequence of encoded elements\n\n        :returns: a list of `EncodedMethod` objects\n        \"\"\"\n        return self.direct_methods\n\n    def get_virtual_methods(self) -&gt; list[EncodedMethod]:\n        \"\"\"\n        Return the defined virtual (none of static, private, or constructor) methods, represented as a sequence of encoded elements\n\n        :returns: a list `EncodedMethod` objects\n\n        \"\"\"\n\n        return self.virtual_methods\n\n    def get_methods(self) -&gt; list[EncodedMethod]:\n        \"\"\"\n        Return direct and virtual methods\n\n        :returns: a list of `EncodedMethod` objects\n        \"\"\"\n        return [x for x in self.direct_methods] + [\n            x for x in self.virtual_methods\n        ]\n\n    def get_fields(self) -&gt; list[EncodedField]:\n        \"\"\"\n        Return static and instance fields\n\n        :returns: a list of `EncodedField` objects\n        \"\"\"\n        return [x for x in self.static_fields] + [\n            x for x in self.instance_fields\n        ]\n\n    def set_off(self, off: int):\n        self.offset = off\n\n    def set_static_fields(self, value):\n        if value is not None:\n            values = value.get_values()\n            if len(values) &lt;= len(self.static_fields):\n                for i in range(0, len(values)):\n                    self.static_fields[i].set_init_value(values[i])\n\n    def _load_elements(self, size, l, Type, buff, cm):\n        prev = 0\n        for i in range(0, size):\n            el = Type(buff, cm)\n            el.adjust_idx(prev)\n\n            if isinstance(el, EncodedField):\n                prev = el.get_field_idx()\n            else:\n                prev = el.get_method_idx()\n\n            l.append(el)\n\n    def show(self):\n        bytecode._PrintSubBanner(\"Class Data Item\")\n        bytecode._PrintDefault(\n            \"static_fields_size=%d instance_fields_size=%d direct_methods_size=%d virtual_methods_size=%d\\n\"\n            % (\n                self.static_fields_size,\n                self.instance_fields_size,\n                self.direct_methods_size,\n                self.virtual_methods_size,\n            )\n        )\n\n        bytecode._PrintSubBanner(\"Static Fields\")\n        for i in self.static_fields:\n            i.show()\n\n        bytecode._PrintSubBanner(\"Instance Fields\")\n        for i in self.instance_fields:\n            i.show()\n\n        bytecode._PrintSubBanner(\"Direct Methods\")\n        for i in self.direct_methods:\n            i.show()\n\n        bytecode._PrintSubBanner(\"Virtual Methods\")\n        for i in self.virtual_methods:\n            i.show()\n\n    def get_obj(self):\n        return (\n            [i for i in self.static_fields]\n            + [i for i in self.instance_fields]\n            + [i for i in self.direct_methods]\n            + [i for i in self.virtual_methods]\n        )\n\n    def get_raw(self):\n        buff = (\n            writeuleb128(self.CM, self.static_fields_size)\n            + writeuleb128(self.CM, self.instance_fields_size)\n            + writeuleb128(self.CM, self.direct_methods_size)\n            + writeuleb128(self.CM, self.virtual_methods_size)\n            + b''.join(i.get_raw() for i in self.static_fields)\n            + b''.join(i.get_raw() for i in self.instance_fields)\n            + b''.join(i.get_raw() for i in self.direct_methods)\n            + b''.join(i.get_raw() for i in self.virtual_methods)\n        )\n\n        return buff\n\n    def get_length(self):\n        length = (\n            len(writeuleb128(self.CM, self.static_fields_size))\n            + len(writeuleb128(self.CM, self.instance_fields_size))\n            + len(writeuleb128(self.CM, self.direct_methods_size))\n            + len(writeuleb128(self.CM, self.virtual_methods_size))\n        )\n\n        for i in self.static_fields:\n            length += i.get_size()\n\n        for i in self.instance_fields:\n            length += i.get_size()\n\n        for i in self.direct_methods:\n            length += i.get_size()\n\n        for i in self.virtual_methods:\n            length += i.get_size()\n\n        return length\n\n    def get_off(self):\n        return self.offset\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDataItem.__init__","title":"<code>__init__(buff, cm)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a Buff object of the <code>class_data_item</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def __init__(self, buff: BinaryIO, cm:ClassManager) -&gt; None:\n    \"\"\"\n    :param buff: a string which represents a Buff object of the `class_data_item`\n    :param cm: a `ClassManager` object\n    \"\"\"\n    self.CM = cm\n\n    self.offset = buff.tell()\n\n    self.static_fields_size = readuleb128(cm, buff)\n    self.instance_fields_size = readuleb128(cm, buff)\n    self.direct_methods_size = readuleb128(cm, buff)\n    self.virtual_methods_size = readuleb128(cm, buff)\n\n    self.static_fields = []\n    self.instance_fields = []\n    self.direct_methods = []\n    self.virtual_methods = []\n\n    self._load_elements(\n        self.static_fields_size, self.static_fields, EncodedField, buff, cm\n    )\n    self._load_elements(\n        self.instance_fields_size,\n        self.instance_fields,\n        EncodedField,\n        buff,\n        cm,\n    )\n    self._load_elements(\n        self.direct_methods_size,\n        self.direct_methods,\n        EncodedMethod,\n        buff,\n        cm,\n    )\n    self._load_elements(\n        self.virtual_methods_size,\n        self.virtual_methods,\n        EncodedMethod,\n        buff,\n        cm,\n    )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDataItem.get_direct_methods","title":"<code>get_direct_methods()</code>","text":"<p>Return the defined direct (any of static, private, or constructor) methods, represented as a sequence of encoded elements</p> <p>Returns:</p> Type Description <code>list[EncodedMethod]</code> <p>a list of <code>EncodedMethod</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_direct_methods(self) -&gt; list[EncodedMethod]:\n    \"\"\"\n    Return the defined direct (any of static, private, or constructor) methods, represented as a sequence of encoded elements\n\n    :returns: a list of `EncodedMethod` objects\n    \"\"\"\n    return self.direct_methods\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDataItem.get_direct_methods_size","title":"<code>get_direct_methods_size()</code>","text":"<p>Return the number of direct methods defined in this item</p> <p>Returns:</p> Type Description <code>int</code> <p>number of direct methods</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_direct_methods_size(self) -&gt; int:\n    \"\"\"\n    Return the number of direct methods defined in this item\n\n    :returns: number of direct methods\n    \"\"\"\n    return self.direct_methods_size\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDataItem.get_fields","title":"<code>get_fields()</code>","text":"<p>Return static and instance fields</p> <p>Returns:</p> Type Description <code>list[EncodedField]</code> <p>a list of <code>EncodedField</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_fields(self) -&gt; list[EncodedField]:\n    \"\"\"\n    Return static and instance fields\n\n    :returns: a list of `EncodedField` objects\n    \"\"\"\n    return [x for x in self.static_fields] + [\n        x for x in self.instance_fields\n    ]\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDataItem.get_instance_fields","title":"<code>get_instance_fields()</code>","text":"<p>Return the defined instance fields, represented as a sequence of encoded elements</p> <p>Returns:</p> Type Description <code>list[EncodedField]</code> <p>list of <code>EncodedField</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_instance_fields(self) -&gt; list[EncodedField]:\n    \"\"\"\n    Return the defined instance fields, represented as a sequence of encoded elements\n\n    :returns: list of `EncodedField` objects\n    \"\"\"\n    return self.instance_fields\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDataItem.get_instance_fields_size","title":"<code>get_instance_fields_size()</code>","text":"<p>Return the number of instance fields defined in this item</p> <p>Returns:</p> Type Description <code>int</code> <p>number of instance fields</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_instance_fields_size(self) -&gt; int:\n    \"\"\"\n    Return the number of instance fields defined in this item\n\n    :returns: number of instance fields\n    \"\"\"\n    return self.instance_fields_size\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDataItem.get_methods","title":"<code>get_methods()</code>","text":"<p>Return direct and virtual methods</p> <p>Returns:</p> Type Description <code>list[EncodedMethod]</code> <p>a list of <code>EncodedMethod</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_methods(self) -&gt; list[EncodedMethod]:\n    \"\"\"\n    Return direct and virtual methods\n\n    :returns: a list of `EncodedMethod` objects\n    \"\"\"\n    return [x for x in self.direct_methods] + [\n        x for x in self.virtual_methods\n    ]\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDataItem.get_static_fields","title":"<code>get_static_fields()</code>","text":"<p>Return the defined static fields, represented as a sequence of encoded elements</p> <p>Returns:</p> Type Description <code>list[EncodedField]</code> <p>a list of <code>EncodedField</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_static_fields(self) -&gt; list[EncodedField]:\n    \"\"\"\n    Return the defined static fields, represented as a sequence of encoded elements\n\n    :returns: a list of `EncodedField` objects\n    \"\"\"\n    return self.static_fields\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDataItem.get_static_fields_size","title":"<code>get_static_fields_size()</code>","text":"<p>Return the number of static fields defined in this item</p> <p>Returns:</p> Type Description <code>int</code> <p>number of static fields</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_static_fields_size(self) -&gt; int:\n    \"\"\"\n    Return the number of static fields defined in this item\n\n    :returns: number of static fields\n    \"\"\"\n    return self.static_fields_size\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDataItem.get_virtual_methods","title":"<code>get_virtual_methods()</code>","text":"<p>Return the defined virtual (none of static, private, or constructor) methods, represented as a sequence of encoded elements</p> <p>Returns:</p> Type Description <code>list[EncodedMethod]</code> <p>a list <code>EncodedMethod</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_virtual_methods(self) -&gt; list[EncodedMethod]:\n    \"\"\"\n    Return the defined virtual (none of static, private, or constructor) methods, represented as a sequence of encoded elements\n\n    :returns: a list `EncodedMethod` objects\n\n    \"\"\"\n\n    return self.virtual_methods\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDataItem.get_virtual_methods_size","title":"<code>get_virtual_methods_size()</code>","text":"<p>Return the number of virtual methods defined in this item</p> <p>Returns:</p> Type Description <code>int</code> <p>number of virtual methods</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_virtual_methods_size(self) -&gt; int:\n    \"\"\"\n    Return the number of virtual methods defined in this item\n\n    :returns: number of virtual methods\n    \"\"\"\n    return self.virtual_methods_size\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDefItem","title":"<code>ClassDefItem</code>","text":"<p>This class can parse a <code>class_def_item</code> of a dex file</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class ClassDefItem:\n    \"\"\"\n    This class can parse a `class_def_item` of a dex file\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm:ClassManager) -&gt; None:\n        \"\"\"\n        :param buff: a string which represents a Buff object of the `class_def_item`\n        :param cm: a `ClassManager` object\n        \"\"\"\n        self.CM = cm\n        self.offset = buff.tell()\n\n        (\n            self.class_idx,\n            self.access_flags,\n            self.superclass_idx,\n            self.interfaces_off,\n            self.source_file_idx,\n            self.annotations_off,\n            self.class_data_off,\n            self.static_values_off,\n        ) = cm.packer[\"8I\"].unpack(buff.read(32))\n\n        self.interfaces = []\n        self.class_data_item = None\n        self.static_values = None\n        self.annotations_directory_item = None\n\n        self.name = None\n        self.sname = None\n        self.access_flags_string = None\n\n        self.reload()\n\n    def reload(self) -&gt; None:\n        self.name = self.CM.get_type(self.class_idx)\n        self.sname = self.CM.get_type(self.superclass_idx)\n        self.interfaces = self.CM.get_type_list(self.interfaces_off)\n\n        if self.class_data_off != 0:\n            self.class_data_item = self.CM.get_class_data_item(\n                self.class_data_off\n            )\n\n        if self.annotations_off != 0:\n            self.annotations_directory_item = (\n                self.CM.get_annotations_directory_item(self.annotations_off)\n            )\n\n        if self.static_values_off != 0:\n            self.static_values = self.CM.get_encoded_array_item(\n                self.static_values_off\n            )\n\n            if self.class_data_item:\n                self.class_data_item.set_static_fields(\n                    self.static_values.get_value()\n                )\n\n    def __str__(self):\n        return \"{}-&gt;{}\".format(self.get_superclassname(), self.get_name())\n\n    def __repr__(self):\n        return \"&lt;dvm.ClassDefItem {}&gt;\".format(self.__str__())\n\n    def get_methods(self) -&gt; list[EncodedMethod]:\n        \"\"\"\n        Return all [EncodedMethods][androguard.core.dex.EncodedMethod] of this class\n\n        :returns: a list of `EncodedMethod` objects\n        \"\"\"\n        if self.class_data_item is not None:\n            return self.class_data_item.get_methods()\n        return []\n\n    def get_fields(self) -&gt; list[EncodedField]:\n        \"\"\"\n        Return all [EncodedFields][androguard.core.dex.EncodedField] of this class\n\n        :returns: a list of `EncodedField` objects\n        \"\"\"\n        if self.class_data_item is not None:\n            return self.class_data_item.get_fields()\n        return []\n\n    def _get_annotation_type_ids(self) -&gt; list[EncodedAnnotation]:\n        \"\"\"\n        Get the [EncodedAnnotation][androguard.core.dex.EncodedAnnotation] from this class\n\n        :returns: list of `EncodedAnnotation` objects\n        \"\"\"\n        if self.annotations_directory_item is None:\n            return []\n        annotation_set_item = (\n            self.annotations_directory_item.get_annotation_set_item()\n        )\n        if annotation_set_item is None:\n            return []\n\n        annotation_off_item = annotation_set_item.get_annotation_off_item()\n\n        if annotation_off_item is None:\n            return []\n\n        return [\n            annotation.get_annotation_item().annotation\n            for annotation in annotation_off_item\n        ]\n\n    def get_annotations(self) -&gt; list[str]:\n        \"\"\"\n        Returns the class names of the annotations of this class.\n\n        For example, if the class is marked as `@Deprecated`, this will return\n        `['Ljava/lang/Deprecated;']`.\n\n        :returns: list of class names\n        \"\"\"\n        return [\n            self.CM.get_type(x.get_type_idx())\n            for x in self._get_annotation_type_ids()\n        ]\n\n    def get_class_idx(self) -&gt; int:\n        \"\"\"\n        Return the index into the `type_ids` list for this class\n\n        :returns: the index\n        \"\"\"\n        return self.class_idx\n\n    def get_access_flags(self) -&gt; int:\n        \"\"\"\n        Return the access flags for the class (`public`, `final`, etc.)\n\n        :returns: the access flags\n        \"\"\"\n        return self.access_flags\n\n    def get_superclass_idx(self) -&gt; int:\n        \"\"\"\n        Return the index into the `type_ids` list for the superclass\n\n        :returns: the index\n        \"\"\"\n        return self.superclass_idx\n\n    def get_interfaces_off(self) -&gt; int:\n        \"\"\"\n        Return the offset from the start of the file to the list of interfaces, or 0 if there are none\n\n        :returns: the offset\n        \"\"\"\n        return self.interfaces_off\n\n    def get_source_file_idx(self) -&gt; int:\n        \"\"\"\n        Return the index into the `string_ids` list for the name of the file containing the original\n        source for (at least most of) this class, or the special value `NO_INDEX` to represent a lack of this information\n\n        :returns: the index\n        \"\"\"\n        return self.source_file_idx\n\n    def get_annotations_off(self) -&gt; int:\n        \"\"\"\n        Return the offset from the start of the file to the annotations structure for this class,\n        or 0 if there are no annotations on this class.\n\n        :returns: the offset\n        \"\"\"\n        return self.annotations_off\n\n    def get_class_data_off(self) -&gt; int:\n        \"\"\"\n        Return the offset from the start of the file to the associated class data for this item,\n        or 0 if there is no class data for this class\n\n        :returns: the offset\n        \"\"\"\n        return self.class_data_off\n\n    def get_static_values_off(self) -&gt; int:\n        \"\"\"\n        Return the offset from the start of the file to the list of initial values for static fields,\n        or 0 if there are none (and all static fields are to be initialized with 0 or null)\n\n        :returns: the offset\n        \"\"\"\n        return self.static_values_off\n\n    def get_class_data(self) -&gt; ClassDataItem:\n        \"\"\"\n        Return the associated class_data_item\n\n        :returns: the associated `ClassDataItem`\n        \"\"\"\n        return self.class_data_item\n\n    def get_name(self) -&gt; str:\n        \"\"\"\n        Return the name of this class\n\n        :returns: the string name\n        \"\"\"\n        return self.name\n\n    def get_superclassname(self) -&gt; str:\n        \"\"\"\n        Return the name of the super class\n\n        :returns: the string name\n        \"\"\"\n        return self.sname\n\n    def get_interfaces(self) -&gt; list[str]:\n        \"\"\"\n        Return the names of the interfaces\n\n        :returns: a list of string names\n        \"\"\"\n        return self.interfaces\n\n    def get_access_flags_string(self) -&gt; str:\n        \"\"\"\n        Return the access flags string of the class\n\n        :returns: the access flag string\n        \"\"\"\n        if self.access_flags_string is None:\n            self.access_flags_string = get_access_flags_string(\n                self.get_access_flags()\n            )\n\n            if self.access_flags_string == \"\":\n                self.access_flags_string = \"0x%x\" % self.get_access_flags()\n        return self.access_flags_string\n\n    def show(self) -&gt; None:\n        bytecode._PrintSubBanner(\"Class Def Item\")\n        bytecode._PrintDefault(\n            \"name=%s, sname=%s, interfaces=%s, access_flags=%s\\n\"\n            % (\n                self.name,\n                self.sname,\n                self.interfaces,\n                self.get_access_flags_string(),\n            )\n        )\n        bytecode._PrintDefault(\n            \"class_idx=%d, superclass_idx=%d, interfaces_off=%x, source_file_idx=%d, annotations_off=%x, class_data_off=%x, static_values_off=%x\\n\"\n            % (\n                self.class_idx,\n                self.superclass_idx,\n                self.interfaces_off,\n                self.source_file_idx,\n                self.annotations_off,\n                self.class_data_off,\n                self.static_values_off,\n            )\n        )\n\n        for method in self.get_methods():\n            method.show()\n\n    def source(self) -&gt; None:\n        \"\"\"\n        Print the source code of the entire class\n        \"\"\"\n        self.CM.decompiler_ob.display_all(self)\n\n    def get_source(self) -&gt; str:\n        \"\"\"return the source code of this class\n\n        :returns: the source code string\n        \"\"\"\n        return self.CM.decompiler_ob.get_source_class(self)\n\n    def get_source_ext(self) -&gt; list[tuple[str, list]]:\n        return self.CM.decompiler_ob.get_source_class_ext(self)\n\n    def get_ast(self):\n        return self.CM.decompiler_ob.get_ast_class(self)\n\n    def set_name(self, value):\n        self.CM.set_hook_class_name(self, value)\n\n    def get_obj(self):\n        if self.interfaces_off != 0:\n            self.interfaces_off = self.CM.get_obj_by_offset(\n                self.interfaces_off\n            ).get_off()\n\n        if self.annotations_off != 0:\n            self.annotations_off = self.CM.get_obj_by_offset(\n                self.annotations_off\n            ).get_off()\n\n        if self.class_data_off != 0:\n            self.class_data_off = self.CM.get_obj_by_offset(\n                self.class_data_off\n            ).get_off()\n\n        if self.static_values_off != 0:\n            self.static_values_off = self.CM.get_obj_by_offset(\n                self.static_values_off\n            ).get_off()\n\n        return self.CM.packer[\"8I\"].pack(\n            self.class_idx,\n            self.access_flags,\n            self.superclass_idx,\n            self.interfaces_off,\n            self.source_file_idx,\n            self.annotations_off,\n            self.class_data_off,\n            self.static_values_off,\n        )\n\n    def get_raw(self):\n        return self.get_obj()\n\n    def get_length(self):\n        return len(self.get_obj())\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDefItem.__init__","title":"<code>__init__(buff, cm)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a Buff object of the <code>class_def_item</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def __init__(self, buff: BinaryIO, cm:ClassManager) -&gt; None:\n    \"\"\"\n    :param buff: a string which represents a Buff object of the `class_def_item`\n    :param cm: a `ClassManager` object\n    \"\"\"\n    self.CM = cm\n    self.offset = buff.tell()\n\n    (\n        self.class_idx,\n        self.access_flags,\n        self.superclass_idx,\n        self.interfaces_off,\n        self.source_file_idx,\n        self.annotations_off,\n        self.class_data_off,\n        self.static_values_off,\n    ) = cm.packer[\"8I\"].unpack(buff.read(32))\n\n    self.interfaces = []\n    self.class_data_item = None\n    self.static_values = None\n    self.annotations_directory_item = None\n\n    self.name = None\n    self.sname = None\n    self.access_flags_string = None\n\n    self.reload()\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDefItem.get_access_flags","title":"<code>get_access_flags()</code>","text":"<p>Return the access flags for the class (<code>public</code>, <code>final</code>, etc.)</p> <p>Returns:</p> Type Description <code>int</code> <p>the access flags</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_access_flags(self) -&gt; int:\n    \"\"\"\n    Return the access flags for the class (`public`, `final`, etc.)\n\n    :returns: the access flags\n    \"\"\"\n    return self.access_flags\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDefItem.get_access_flags_string","title":"<code>get_access_flags_string()</code>","text":"<p>Return the access flags string of the class</p> <p>Returns:</p> Type Description <code>str</code> <p>the access flag string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_access_flags_string(self) -&gt; str:\n    \"\"\"\n    Return the access flags string of the class\n\n    :returns: the access flag string\n    \"\"\"\n    if self.access_flags_string is None:\n        self.access_flags_string = get_access_flags_string(\n            self.get_access_flags()\n        )\n\n        if self.access_flags_string == \"\":\n            self.access_flags_string = \"0x%x\" % self.get_access_flags()\n    return self.access_flags_string\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDefItem.get_annotations","title":"<code>get_annotations()</code>","text":"<p>Returns the class names of the annotations of this class.</p> <p>For example, if the class is marked as <code>@Deprecated</code>, this will return <code>['Ljava/lang/Deprecated;']</code>.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list of class names</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_annotations(self) -&gt; list[str]:\n    \"\"\"\n    Returns the class names of the annotations of this class.\n\n    For example, if the class is marked as `@Deprecated`, this will return\n    `['Ljava/lang/Deprecated;']`.\n\n    :returns: list of class names\n    \"\"\"\n    return [\n        self.CM.get_type(x.get_type_idx())\n        for x in self._get_annotation_type_ids()\n    ]\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDefItem.get_annotations_off","title":"<code>get_annotations_off()</code>","text":"<p>Return the offset from the start of the file to the annotations structure for this class, or 0 if there are no annotations on this class.</p> <p>Returns:</p> Type Description <code>int</code> <p>the offset</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_annotations_off(self) -&gt; int:\n    \"\"\"\n    Return the offset from the start of the file to the annotations structure for this class,\n    or 0 if there are no annotations on this class.\n\n    :returns: the offset\n    \"\"\"\n    return self.annotations_off\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDefItem.get_class_data","title":"<code>get_class_data()</code>","text":"<p>Return the associated class_data_item</p> <p>Returns:</p> Type Description <code>ClassDataItem</code> <p>the associated <code>ClassDataItem</code></p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_class_data(self) -&gt; ClassDataItem:\n    \"\"\"\n    Return the associated class_data_item\n\n    :returns: the associated `ClassDataItem`\n    \"\"\"\n    return self.class_data_item\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDefItem.get_class_data_off","title":"<code>get_class_data_off()</code>","text":"<p>Return the offset from the start of the file to the associated class data for this item, or 0 if there is no class data for this class</p> <p>Returns:</p> Type Description <code>int</code> <p>the offset</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_class_data_off(self) -&gt; int:\n    \"\"\"\n    Return the offset from the start of the file to the associated class data for this item,\n    or 0 if there is no class data for this class\n\n    :returns: the offset\n    \"\"\"\n    return self.class_data_off\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDefItem.get_class_idx","title":"<code>get_class_idx()</code>","text":"<p>Return the index into the <code>type_ids</code> list for this class</p> <p>Returns:</p> Type Description <code>int</code> <p>the index</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_class_idx(self) -&gt; int:\n    \"\"\"\n    Return the index into the `type_ids` list for this class\n\n    :returns: the index\n    \"\"\"\n    return self.class_idx\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDefItem.get_fields","title":"<code>get_fields()</code>","text":"<p>Return all EncodedFields of this class</p> <p>Returns:</p> Type Description <code>list[EncodedField]</code> <p>a list of <code>EncodedField</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_fields(self) -&gt; list[EncodedField]:\n    \"\"\"\n    Return all [EncodedFields][androguard.core.dex.EncodedField] of this class\n\n    :returns: a list of `EncodedField` objects\n    \"\"\"\n    if self.class_data_item is not None:\n        return self.class_data_item.get_fields()\n    return []\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDefItem.get_interfaces","title":"<code>get_interfaces()</code>","text":"<p>Return the names of the interfaces</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>a list of string names</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_interfaces(self) -&gt; list[str]:\n    \"\"\"\n    Return the names of the interfaces\n\n    :returns: a list of string names\n    \"\"\"\n    return self.interfaces\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDefItem.get_interfaces_off","title":"<code>get_interfaces_off()</code>","text":"<p>Return the offset from the start of the file to the list of interfaces, or 0 if there are none</p> <p>Returns:</p> Type Description <code>int</code> <p>the offset</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_interfaces_off(self) -&gt; int:\n    \"\"\"\n    Return the offset from the start of the file to the list of interfaces, or 0 if there are none\n\n    :returns: the offset\n    \"\"\"\n    return self.interfaces_off\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDefItem.get_methods","title":"<code>get_methods()</code>","text":"<p>Return all EncodedMethods of this class</p> <p>Returns:</p> Type Description <code>list[EncodedMethod]</code> <p>a list of <code>EncodedMethod</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_methods(self) -&gt; list[EncodedMethod]:\n    \"\"\"\n    Return all [EncodedMethods][androguard.core.dex.EncodedMethod] of this class\n\n    :returns: a list of `EncodedMethod` objects\n    \"\"\"\n    if self.class_data_item is not None:\n        return self.class_data_item.get_methods()\n    return []\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDefItem.get_name","title":"<code>get_name()</code>","text":"<p>Return the name of this class</p> <p>Returns:</p> Type Description <code>str</code> <p>the string name</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_name(self) -&gt; str:\n    \"\"\"\n    Return the name of this class\n\n    :returns: the string name\n    \"\"\"\n    return self.name\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDefItem.get_source","title":"<code>get_source()</code>","text":"<p>return the source code of this class</p> <p>Returns:</p> Type Description <code>str</code> <p>the source code string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_source(self) -&gt; str:\n    \"\"\"return the source code of this class\n\n    :returns: the source code string\n    \"\"\"\n    return self.CM.decompiler_ob.get_source_class(self)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDefItem.get_source_file_idx","title":"<code>get_source_file_idx()</code>","text":"<p>Return the index into the <code>string_ids</code> list for the name of the file containing the original source for (at least most of) this class, or the special value <code>NO_INDEX</code> to represent a lack of this information</p> <p>Returns:</p> Type Description <code>int</code> <p>the index</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_source_file_idx(self) -&gt; int:\n    \"\"\"\n    Return the index into the `string_ids` list for the name of the file containing the original\n    source for (at least most of) this class, or the special value `NO_INDEX` to represent a lack of this information\n\n    :returns: the index\n    \"\"\"\n    return self.source_file_idx\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDefItem.get_static_values_off","title":"<code>get_static_values_off()</code>","text":"<p>Return the offset from the start of the file to the list of initial values for static fields, or 0 if there are none (and all static fields are to be initialized with 0 or null)</p> <p>Returns:</p> Type Description <code>int</code> <p>the offset</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_static_values_off(self) -&gt; int:\n    \"\"\"\n    Return the offset from the start of the file to the list of initial values for static fields,\n    or 0 if there are none (and all static fields are to be initialized with 0 or null)\n\n    :returns: the offset\n    \"\"\"\n    return self.static_values_off\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDefItem.get_superclass_idx","title":"<code>get_superclass_idx()</code>","text":"<p>Return the index into the <code>type_ids</code> list for the superclass</p> <p>Returns:</p> Type Description <code>int</code> <p>the index</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_superclass_idx(self) -&gt; int:\n    \"\"\"\n    Return the index into the `type_ids` list for the superclass\n\n    :returns: the index\n    \"\"\"\n    return self.superclass_idx\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDefItem.get_superclassname","title":"<code>get_superclassname()</code>","text":"<p>Return the name of the super class</p> <p>Returns:</p> Type Description <code>str</code> <p>the string name</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_superclassname(self) -&gt; str:\n    \"\"\"\n    Return the name of the super class\n\n    :returns: the string name\n    \"\"\"\n    return self.sname\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassDefItem.source","title":"<code>source()</code>","text":"<p>Print the source code of the entire class</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def source(self) -&gt; None:\n    \"\"\"\n    Print the source code of the entire class\n    \"\"\"\n    self.CM.decompiler_ob.display_all(self)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassHDefItem","title":"<code>ClassHDefItem</code>","text":"<p>This class can parse a list of <code>class_def_item</code> of a dex file</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a Buff object of the list of <code>class_def_item</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class ClassHDefItem:\n    \"\"\"\n    This class can parse a list of `class_def_item` of a dex file\n\n    :param buff: a string which represents a Buff object of the list of `class_def_item`\n    :param cm: a `ClassManager` object\n    \"\"\"\n\n    def __init__(self, size: int, buff: BinaryIO, cm: ClassManager) -&gt; None:\n        self.CM = cm\n\n        self.offset = buff.tell()\n\n        self.class_def = []\n\n        for i in range(0, size):\n            idx = buff.tell()\n\n            class_def = ClassDefItem(buff, cm)\n            self.class_def.append(class_def)\n\n            buff.seek(idx + calcsize(\"8I\"))\n\n    def set_off(self, off: int) -&gt; None:\n        self.offset = off\n\n    def get_off(self) -&gt; int:\n        return self.offset\n\n    def get_class_idx(self, idx: int) -&gt; ClassDefItem:\n        \"\"\"return the associated `ClassDefItem` from the `class_def` list given an index\n\n        :param idx: the index\n        :return: the `ClassDefItem` object , or `None` if not found\n        \"\"\"\n        for i in self.class_def:\n            if i.get_class_idx() == idx:\n                return i\n        return None\n\n    def get_method(\n        self, name_class: str, name_method: str\n    ) -&gt; list[EncodedMethod]:\n        \"\"\"return a list of of `EncodedMethod` objects given a class name and method name\n\n        :param name_class: the name of the class\n        :param name_method: the name of the method\n        :return: a list of `EncodedMethod` objects\n        \"\"\"\n        l = []\n\n        for i in self.class_def:\n            if i.get_name() == name_class:\n                for j in i.get_methods():\n                    if j.get_name() == name_method:\n                        l.append(j)\n        return l\n\n    def get_names(self) -&gt; list[str]:\n        \"\"\"return a list of class names found in `class_def`\n\n        :return: a list of class names\n        \"\"\"\n        return [x.get_name() for x in self.class_def]\n\n    def show(self) -&gt; None:\n        for i in self.class_def:\n            i.show()\n\n    def get_obj(self) -&gt; list[ClassDefItem]:\n        \"\"\"return a list of `ClassDefItem` objects\n\n        :return: list of `ClassDefItem` objects\n        \"\"\"\n        return [i for i in self.class_def]\n\n    def get_raw(self) -&gt; bytes:\n        return b''.join(i.get_raw() for i in self.class_def)\n\n    def get_length(self) -&gt; int:\n        length = 0\n        for i in self.class_def:\n            length += i.get_length()\n        return length\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassHDefItem.get_class_idx","title":"<code>get_class_idx(idx)</code>","text":"<p>return the associated <code>ClassDefItem</code> from the <code>class_def</code> list given an index</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>the index</p> required <p>Returns:</p> Type Description <code>ClassDefItem</code> <p>the <code>ClassDefItem</code> object , or <code>None</code> if not found</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_class_idx(self, idx: int) -&gt; ClassDefItem:\n    \"\"\"return the associated `ClassDefItem` from the `class_def` list given an index\n\n    :param idx: the index\n    :return: the `ClassDefItem` object , or `None` if not found\n    \"\"\"\n    for i in self.class_def:\n        if i.get_class_idx() == idx:\n            return i\n    return None\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassHDefItem.get_method","title":"<code>get_method(name_class, name_method)</code>","text":"<p>return a list of of <code>EncodedMethod</code> objects given a class name and method name</p> <p>Parameters:</p> Name Type Description Default <code>name_class</code> <code>str</code> <p>the name of the class</p> required <code>name_method</code> <code>str</code> <p>the name of the method</p> required <p>Returns:</p> Type Description <code>list[EncodedMethod]</code> <p>a list of <code>EncodedMethod</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_method(\n    self, name_class: str, name_method: str\n) -&gt; list[EncodedMethod]:\n    \"\"\"return a list of of `EncodedMethod` objects given a class name and method name\n\n    :param name_class: the name of the class\n    :param name_method: the name of the method\n    :return: a list of `EncodedMethod` objects\n    \"\"\"\n    l = []\n\n    for i in self.class_def:\n        if i.get_name() == name_class:\n            for j in i.get_methods():\n                if j.get_name() == name_method:\n                    l.append(j)\n    return l\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassHDefItem.get_names","title":"<code>get_names()</code>","text":"<p>return a list of class names found in <code>class_def</code></p> <p>Returns:</p> Type Description <code>list[str]</code> <p>a list of class names</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_names(self) -&gt; list[str]:\n    \"\"\"return a list of class names found in `class_def`\n\n    :return: a list of class names\n    \"\"\"\n    return [x.get_name() for x in self.class_def]\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassHDefItem.get_obj","title":"<code>get_obj()</code>","text":"<p>return a list of <code>ClassDefItem</code> objects</p> <p>Returns:</p> Type Description <code>list[ClassDefItem]</code> <p>list of <code>ClassDefItem</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_obj(self) -&gt; list[ClassDefItem]:\n    \"\"\"return a list of `ClassDefItem` objects\n\n    :return: list of `ClassDefItem` objects\n    \"\"\"\n    return [i for i in self.class_def]\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassManager","title":"<code>ClassManager</code>","text":"<p>This class is used to access to all elements (strings, type, proto ...) of the dex format based on their offset or index.</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class ClassManager:\n    \"\"\"\n    This class is used to access to all elements (strings, type, proto ...) of the dex format\n    based on their offset or index.\n    \"\"\"\n\n    def __init__(self, vm: DEX) -&gt; None:\n        \"\"\"\n        :param DEX vm: the VM to create a `ClassManager` for\n        \"\"\"\n        self.vm = vm\n        self.buff = vm\n\n        self.analysis_dex = None\n        self.decompiler_ob = None\n\n        self.__packer = None\n\n        self.__manage_item = {}\n        self.__manage_item_off = []\n\n        self.__strings_off = {}\n        self.__typelists_off = {}\n        self.__classdata_off = {}\n\n        self.__obj_offset = {}\n        self.__item_offset = {}\n\n        self.__cached_proto = {}\n\n        self.hook_strings = {}\n\n        if self.vm:\n            self.odex_format = self.vm.get_format_type() == \"ODEX\"\n        else:\n            self.odex_format = False\n\n    @property\n    def packer(self):\n        return self.__packer\n\n    @packer.setter\n    def packer(self, p):\n        self.__packer = p\n\n    def get_ascii_string(self, s: str) -&gt; str:\n        # TODO Remove method\n        try:\n            return s.decode(\"ascii\")\n        except UnicodeDecodeError:\n            d = \"\"\n            for i in s:\n                if i &lt; 128:\n                    d += i\n                else:\n                    d += \"%x\" % i\n            return d\n\n    def get_odex_format(self) -&gt; bool:\n        \"\"\"Returns `True` if the underlying VM is ODEX\n\n        :returns: `True` if vm is ODEX, `False` if not\n        \"\"\"\n        return self.odex_format\n\n    def get_obj_by_offset(self, offset: int) -&gt; object:\n        \"\"\"\n        Returns a object from as given offset inside the DEX file\n        \"\"\"\n        return self.__obj_offset[offset]\n\n    def get_item_by_offset(self, offset: int) -&gt; object:\n        return self.__item_offset[offset]\n\n    def get_string_by_offset(self, offset: int) -&gt; object:\n        return self.__strings_off[offset]\n\n    def set_decompiler(self, decompiler: DecompilerDAD) -&gt; None:\n        self.decompiler_ob = decompiler\n\n    def set_analysis(self, analysis_dex: Analysis) -&gt; None:\n        self.analysis_dex = analysis_dex\n\n    def get_analysis(self) -&gt; Analysis:\n        return self.analysis_dex\n\n    def add_type_item(\n        self, type_item: TypeMapItem, c_item: MapItem, item: object\n    ) -&gt; None:\n        self.__manage_item[type_item] = item\n\n        self.__obj_offset[c_item.get_off()] = c_item\n        self.__item_offset[c_item.get_offset()] = item\n\n        if item is None:\n            pass\n        elif isinstance(item, list):\n            for i in item:\n                goff = i.offset\n                self.__manage_item_off.append(goff)\n\n                self.__obj_offset[i.get_off()] = i\n\n                if type_item == TypeMapItem.STRING_DATA_ITEM:\n                    self.__strings_off[goff] = i\n                elif type_item == TypeMapItem.TYPE_LIST:\n                    self.__typelists_off[goff] = i\n                elif type_item == TypeMapItem.CLASS_DATA_ITEM:\n                    self.__classdata_off[goff] = i\n        else:\n            self.__manage_item_off.append(c_item.get_offset())\n\n    def get_code(self, idx: int) -&gt; Union[DalvikCode, None]:\n        try:\n            return self.__manage_item[TypeMapItem.CODE_ITEM].get_code(idx)\n        except KeyError:\n            return None\n\n    def get_class_data_item(self, off: int) -&gt; ClassDataItem:\n        i = self.__classdata_off.get(off)\n        if i is None:\n            logger.warning(\"unknown class data item @ 0x%x\" % off)\n        return i\n\n    def get_encoded_array_item(self, off: int) -&gt; EncodedArrayItem:\n        for i in self.__manage_item[TypeMapItem.ENCODED_ARRAY_ITEM]:\n            if i.get_off() == off:\n                return i\n\n    def get_annotations_directory_item(\n        self, off: int\n    ) -&gt; AnnotationsDirectoryItem:\n        for i in self.__manage_item[TypeMapItem.ANNOTATIONS_DIRECTORY_ITEM]:\n            if i.get_off() == off:\n                return i\n\n    def get_annotation_set_item(self, off: int) -&gt; AnnotationSetItem:\n        for i in self.__manage_item[TypeMapItem.ANNOTATION_SET_ITEM]:\n            if i.get_off() == off:\n                return i\n\n    def get_annotation_off_item(self, off: int) -&gt; AnnotationOffItem:\n        for i in self.__manage_item[TypeMapItem.ANNOTATION_OFF_ITEM]:\n            if i.get_off() == off:\n                return i\n\n    def get_annotation_item(self, off: int) -&gt; AnnotationItem:\n        for i in self.__manage_item[TypeMapItem.ANNOTATION_ITEM]:\n            if i.get_off() == off:\n                return i\n\n    def get_hiddenapi_class_data_item(\n        self, off: int\n    ) -&gt; HiddenApiClassDataItem:\n        for i in self.__manage_item[TypeMapItem.HIDDENAPI_CLASS_DATA_ITEM]:\n            if i.get_off() == off:\n                return i\n\n    def get_string(self, idx: int) -&gt; str:\n        \"\"\"\n        Return a string from the string table at index `idx`\n\n        If string is hooked, the hooked string is returned.\n\n        :param idx: index in the string section\n\n        :returns: string entry\n        \"\"\"\n        if idx in self.hook_strings:\n            return self.hook_strings[idx]\n\n        return self.get_raw_string(idx)\n\n    def get_raw_string(self, idx: int) -&gt; str:\n        \"\"\"\n        Return the (unprocessed) string from the string table at index `idx`.\n\n        :param idx: the index in the string section\n        \"\"\"\n        try:\n            off = self.__manage_item[TypeMapItem.STRING_ID_ITEM][\n                idx\n            ].get_string_data_off()\n        except IndexError:\n            logger.warning(\"unknown string item @ %d\" % idx)\n            return \"AG:IS: invalid string\"\n\n        try:\n            return self.__strings_off[off].get()\n        except KeyError:\n            logger.warning(\"unknown string item @ 0x%x(%d)\" % (off, idx))\n            return \"AG:IS: invalid string\"\n\n    def get_type_list(self, off: int) -&gt; list[str]:\n        if off == 0:\n            return []\n\n        i = self.__typelists_off[off]\n        return [type_.get_string() for type_ in i.get_list()]\n\n    def get_type(self, idx: int) -&gt; str:\n        \"\"\"\n        Return the resolved type name based on the index\n\n        This returns the string associated with the type.\n\n        :param int idx:\n        :returns: the type name\n        \"\"\"\n        _type = self.get_type_ref(idx)\n        if _type == -1:\n            return \"AG:ITI: invalid type\"\n        return self.get_string(_type)\n\n    def get_type_ref(self, idx: int) -&gt; TypeIdItem:\n        \"\"\"\n        Returns the string reference ID for a given type ID.\n\n        This method is similar to [get_type][androguard.core.dex.ClassManager.get_type] but does not resolve\n        the string but returns the ID into the string section.\n\n        If the type IDX is not found, -1 is returned.\n        \"\"\"\n        return self.__manage_item[TypeMapItem.TYPE_ID_ITEM].get(idx)\n\n    def get_proto(self, idx: int) -&gt; list:\n        proto = self.__cached_proto.get(idx)\n        if not proto:\n            proto = self.__manage_item[TypeMapItem.PROTO_ID_ITEM].get(idx)\n            self.__cached_proto[idx] = proto\n\n        return [\n            proto.get_parameters_off_value(),\n            proto.get_return_type_idx_value(),\n        ]\n\n    def get_field(self, idx: int) -&gt; list[str]:\n        field = self.get_field_ref(idx)\n        # return [field.get_class_name(), field.get_type(), field.get_name()]\n        return field.get_list()\n\n    def get_field_ref(self, idx: int) -&gt; FieldIdItem:\n        return self.__manage_item[TypeMapItem.FIELD_ID_ITEM].get(idx)\n\n    def get_method(self, idx: int) -&gt; list[str]:\n        return self.get_method_ref(idx).get_list()\n\n    def get_method_ref(self, idx: int) -&gt; MethodIdItem:\n        return self.__manage_item[TypeMapItem.METHOD_ID_ITEM].get(idx)\n\n    def set_hook_class_name(self, class_def: ClassDefItem, value: str) -&gt; None:\n        python_export = True\n        _type = self.__manage_item[TypeMapItem.TYPE_ID_ITEM].get(\n            class_def.get_class_idx()\n        )\n        self.set_hook_string(_type, value)\n\n        try:\n            self.vm._delete_python_export_class(class_def)\n        except AttributeError:\n            python_export = False\n\n        class_def.reload()\n\n        # FIXME\n        self.__manage_item[TypeMapItem.METHOD_ID_ITEM].reload()\n\n        for i in class_def.get_methods():\n            i.reload()\n\n        for i in class_def.get_fields():\n            i.reload()\n\n        if python_export:\n            self.vm._create_python_export_class(class_def)\n\n    def set_hook_method_name(\n        self, encoded_method: EncodedMethod, value: str\n    ) -&gt; None:\n        python_export = True\n\n        method = self.__manage_item[TypeMapItem.METHOD_ID_ITEM].get(\n            encoded_method.get_method_idx()\n        )\n        self.set_hook_string(method.get_name_idx(), value)\n\n        class_def = self.__manage_item[\n            TypeMapItem.CLASS_DEF_ITEM\n        ].get_class_idx(method.get_class_idx())\n        if class_def is not None:\n            try:\n                name = bytecode.FormatNameToPython(encoded_method.get_name())\n            except AttributeError:\n                name += \"_\" + bytecode.FormatDescriptorToPython(\n                    encoded_method.get_descriptor()\n                )\n\n            logger.debug(\"try deleting old name in python...\")\n            try:\n                delattr(class_def.M, name)\n                logger.debug(\"success with regular name\")\n            except AttributeError:\n                logger.debug(\"WARNING: fail with regular name\")\n                # python_export = False\n\n                try:\n                    name = bytecode.FormatNameToPython(\n                        encoded_method.get_name()\n                        + '_'\n                        + encoded_method.proto.replace(' ', '')\n                        .replace('(', '')\n                        .replace('[', '')\n                        .replace(')', '')\n                        .replace('/', '_')\n                        .replace(';', '')\n                    )\n                except AttributeError:\n                    name += \"_\" + bytecode.FormatDescriptorToPython(\n                        encoded_method.get_descriptor()\n                    )\n\n                try:\n                    delattr(class_def.M, name)\n                    logger.debug(\"success with name containing prototype\")\n                except AttributeError:\n                    logger.debug(\n                        \"WARNING: fail with name containing prototype\"\n                    )\n                    python_export = False\n\n            if python_export:\n                name = bytecode.FormatNameToPython(value)\n                setattr(class_def.M, name, encoded_method)\n                logger.debug(\"new name in python: created: %s.\" % name)\n            else:\n                logger.debug(\"skipping creating new name in python\")\n\n        method.reload()\n\n    def set_hook_field_name(\n        self, encoded_field: EncodedField, value: str\n    ) -&gt; None:\n        python_export = True\n\n        field = self.__manage_item[TypeMapItem.FIELD_ID_ITEM].get(\n            encoded_field.get_field_idx()\n        )\n        self.set_hook_string(field.get_name_idx(), value)\n\n        class_def = self.__manage_item[\n            TypeMapItem.CLASS_DEF_ITEM\n        ].get_class_idx(field.get_class_idx())\n        if class_def is not None:\n            try:\n                name = bytecode.FormatNameToPython(encoded_field.get_name())\n            except AttributeError:\n                name += \"_\" + bytecode.FormatDescriptorToPython(\n                    encoded_field.get_descriptor()\n                )\n\n            try:\n                delattr(class_def.F, name)\n            except AttributeError:\n                python_export = False\n\n            if python_export:\n                name = bytecode.FormatNameToPython(value)\n                setattr(class_def.F, name, encoded_field)\n\n        field.reload()\n\n    def set_hook_string(self, idx: int, value: str) -&gt; None:\n        self.hook_strings[idx] = value\n\n    def get_next_offset_item(self, idx: int) -&gt; int:\n        for i in self.__manage_item_off:\n            if i &gt; idx:\n                return i\n        return idx\n\n    def get_debug_off(self, off: int) -&gt; DebugInfoItem:\n        self.buff.seek(off)\n        return DebugInfoItem(self.buff, self)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassManager.__init__","title":"<code>__init__(vm)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>vm</code> <code>DEX</code> <p>the VM to create a <code>ClassManager</code> for</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def __init__(self, vm: DEX) -&gt; None:\n    \"\"\"\n    :param DEX vm: the VM to create a `ClassManager` for\n    \"\"\"\n    self.vm = vm\n    self.buff = vm\n\n    self.analysis_dex = None\n    self.decompiler_ob = None\n\n    self.__packer = None\n\n    self.__manage_item = {}\n    self.__manage_item_off = []\n\n    self.__strings_off = {}\n    self.__typelists_off = {}\n    self.__classdata_off = {}\n\n    self.__obj_offset = {}\n    self.__item_offset = {}\n\n    self.__cached_proto = {}\n\n    self.hook_strings = {}\n\n    if self.vm:\n        self.odex_format = self.vm.get_format_type() == \"ODEX\"\n    else:\n        self.odex_format = False\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassManager.get_obj_by_offset","title":"<code>get_obj_by_offset(offset)</code>","text":"<p>Returns a object from as given offset inside the DEX file</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_obj_by_offset(self, offset: int) -&gt; object:\n    \"\"\"\n    Returns a object from as given offset inside the DEX file\n    \"\"\"\n    return self.__obj_offset[offset]\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassManager.get_odex_format","title":"<code>get_odex_format()</code>","text":"<p>Returns <code>True</code> if the underlying VM is ODEX</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if vm is ODEX, <code>False</code> if not</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_odex_format(self) -&gt; bool:\n    \"\"\"Returns `True` if the underlying VM is ODEX\n\n    :returns: `True` if vm is ODEX, `False` if not\n    \"\"\"\n    return self.odex_format\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassManager.get_raw_string","title":"<code>get_raw_string(idx)</code>","text":"<p>Return the (unprocessed) string from the string table at index <code>idx</code>.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>the index in the string section</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_raw_string(self, idx: int) -&gt; str:\n    \"\"\"\n    Return the (unprocessed) string from the string table at index `idx`.\n\n    :param idx: the index in the string section\n    \"\"\"\n    try:\n        off = self.__manage_item[TypeMapItem.STRING_ID_ITEM][\n            idx\n        ].get_string_data_off()\n    except IndexError:\n        logger.warning(\"unknown string item @ %d\" % idx)\n        return \"AG:IS: invalid string\"\n\n    try:\n        return self.__strings_off[off].get()\n    except KeyError:\n        logger.warning(\"unknown string item @ 0x%x(%d)\" % (off, idx))\n        return \"AG:IS: invalid string\"\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassManager.get_string","title":"<code>get_string(idx)</code>","text":"<p>Return a string from the string table at index <code>idx</code></p> <p>If string is hooked, the hooked string is returned.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>index in the string section</p> required <p>Returns:</p> Type Description <code>str</code> <p>string entry</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_string(self, idx: int) -&gt; str:\n    \"\"\"\n    Return a string from the string table at index `idx`\n\n    If string is hooked, the hooked string is returned.\n\n    :param idx: index in the string section\n\n    :returns: string entry\n    \"\"\"\n    if idx in self.hook_strings:\n        return self.hook_strings[idx]\n\n    return self.get_raw_string(idx)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassManager.get_type","title":"<code>get_type(idx)</code>","text":"<p>Return the resolved type name based on the index</p> <p>This returns the string associated with the type.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> required <p>Returns:</p> Type Description <code>str</code> <p>the type name</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_type(self, idx: int) -&gt; str:\n    \"\"\"\n    Return the resolved type name based on the index\n\n    This returns the string associated with the type.\n\n    :param int idx:\n    :returns: the type name\n    \"\"\"\n    _type = self.get_type_ref(idx)\n    if _type == -1:\n        return \"AG:ITI: invalid type\"\n    return self.get_string(_type)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ClassManager.get_type_ref","title":"<code>get_type_ref(idx)</code>","text":"<p>Returns the string reference ID for a given type ID.</p> <p>This method is similar to get_type but does not resolve the string but returns the ID into the string section.</p> <p>If the type IDX is not found, -1 is returned.</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_type_ref(self, idx: int) -&gt; TypeIdItem:\n    \"\"\"\n    Returns the string reference ID for a given type ID.\n\n    This method is similar to [get_type][androguard.core.dex.ClassManager.get_type] but does not resolve\n    the string but returns the ID into the string section.\n\n    If the type IDX is not found, -1 is returned.\n    \"\"\"\n    return self.__manage_item[TypeMapItem.TYPE_ID_ITEM].get(idx)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DCode","title":"<code>DCode</code>","text":"<p>This class represents the instructions of a method</p> <p>Parameters:</p> Name Type Description Default <code>class_manager</code> <code>ClassManager</code> <p>the <code>ClassManager</code></p> required <code>offset</code> <code>int</code> <p>the offset of the buffer</p> required <code>size</code> <code>int</code> <p>the total size of the buffer</p> required <code>buff</code> <code>bytes</code> <p>a raw buffer where are the instructions</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class DCode:\n    \"\"\"\n    This class represents the instructions of a method\n\n    :param class_manager: the `ClassManager`\n    :param offset: the offset of the buffer\n    :param size: the total size of the buffer\n    :param buff: a raw buffer where are the instructions\n    \"\"\"\n\n    def __init__(\n        self, class_manager: ClassManager, offset: int, size: int, buff: bytes\n    ) -&gt; None:\n        self.CM = class_manager\n        self.insn = buff\n        self.offset = offset\n        self.size = size\n\n        self.notes = {}\n        self.cached_instructions = None\n\n        self.idx = 0\n\n    def get_insn(self) -&gt; bytes:\n        \"\"\"\n        Get the insn buffer\n\n        :returns: insn bytes\n        \"\"\"\n        return self.insn\n\n    def set_insn(self, insn: bytes) -&gt; None:\n        \"\"\"\n        Set a new raw buffer to disassemble\n\n        :param insn: the buffer\n        \"\"\"\n        self.insn = insn\n        self.size = len(self.insn)\n\n    def seek(self, idx: int) -&gt; None:\n        \"\"\"\n        Set the start address of the buffer\n\n        :param idx: the index\n        \"\"\"\n        self.idx = idx\n\n    def is_cached_instructions(self) -&gt; bool:\n        if self.cached_instructions is not None:\n            return True\n        return False\n\n    def set_instructions(self, instructions: list[Instruction]) -&gt; None:\n        \"\"\"\n        Set the instructions\n\n        :param instructions: the list of instructions\n        \"\"\"\n        self.cached_instructions = instructions\n\n    def get_instructions(self) -&gt; Iterator[Instruction]:\n        \"\"\"\n        Return an iterator over [Instruction][androguard.core.dex.Instruction]\n\n        :returns: a generator of each `Instruction` (or a cached list of instructions if you have setup instructions)\n        \"\"\"\n        # it is possible to a cache for instructions (avoid a new disasm)\n        if self.cached_instructions is None:\n            ins = LinearSweepAlgorithm.get_instructions(\n                self.CM, self.size, self.insn, self.idx\n            )\n            self.cached_instructions = list(ins)\n\n        for i in self.cached_instructions:\n            yield i\n\n    def add_inote(\n        self, msg: str, idx: int, off: Union[int, None] = None\n    ) -&gt; None:\n        \"\"\"\n        Add a message to a specific instruction by using (default) the index of the address if specified\n\n        :param msg: the message\n        :param idx: index of the instruction (the position in the list of the instruction)\n        :param off: address of the instruction\n        \"\"\"\n        if off is not None:\n            idx = self.off_to_pos(off)\n\n        if idx not in self.notes:\n            self.notes[idx] = []\n\n        self.notes[idx].append(msg)\n\n    def get_instruction(\n        self, idx: int, off: Union[int, None] = None\n    ) -&gt; Instruction:\n        \"\"\"\n        Get a particular instruction by using (default) the index of the address if specified\n\n        :param idx: index of the instruction (the position in the list of the instruction)\n        :param off: address of the instruction\n\n        :returns: an `Instruction` object\n        \"\"\"\n        if off is not None:\n            idx = self.off_to_pos(off)\n        if self.cached_instructions is None:\n            self.get_instructions()\n        return self.cached_instructions[idx]\n\n    def off_to_pos(self, off: int) -&gt; int:\n        \"\"\"\n        Get the position of an instruction by using the address\n\n        :param off: address of the instruction\n\n        :returns: the offset\n        \"\"\"\n        idx = 0\n        nb = 0\n        for i in self.get_instructions():\n            if idx == off:\n                return nb\n            nb += 1\n            idx += i.get_length()\n        return -1\n\n    def get_ins_off(self, off: int) -&gt; Instruction:\n        \"\"\"\n        Get a particular instruction by using the address\n\n        :param off: address of the instruction\n\n        :returns: an `Instruction` object\n        \"\"\"\n        idx = 0\n        for i in self.get_instructions():\n            if idx == off:\n                return i\n            idx += i.get_length()\n        return None\n\n    def show(self) -&gt; None:\n        \"\"\"\n        Display (with a pretty print) this object\n        \"\"\"\n        off = 0\n        for n, i in enumerate(self.get_instructions()):\n            print(\n                \"{:8d} (0x{:08x}) {:04x} {:30} {}\".format(\n                    n,\n                    off,\n                    i.get_op_value(),\n                    i.get_name(),\n                    i.get_output(self.idx),\n                )\n            )\n            off += i.get_length()\n\n    def get_raw(self) -&gt; bytearray:\n        \"\"\"\n        Return the raw buffer of this object\n\n        :returns: buffer bytearray\n        \"\"\"\n        buff = bytearray()\n        for i in self.get_instructions():\n            buff += i.get_raw()\n        return buff\n\n    def get_length(self) -&gt; int:\n        \"\"\"\n        Return the length of this object\n\n        :returns: length int\n        \"\"\"\n        return len(self.get_raw())\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DCode.add_inote","title":"<code>add_inote(msg, idx, off=None)</code>","text":"<p>Add a message to a specific instruction by using (default) the index of the address if specified</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>the message</p> required <code>idx</code> <code>int</code> <p>index of the instruction (the position in the list of the instruction)</p> required <code>off</code> <code>Union[int, None]</code> <p>address of the instruction</p> <code>None</code> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def add_inote(\n    self, msg: str, idx: int, off: Union[int, None] = None\n) -&gt; None:\n    \"\"\"\n    Add a message to a specific instruction by using (default) the index of the address if specified\n\n    :param msg: the message\n    :param idx: index of the instruction (the position in the list of the instruction)\n    :param off: address of the instruction\n    \"\"\"\n    if off is not None:\n        idx = self.off_to_pos(off)\n\n    if idx not in self.notes:\n        self.notes[idx] = []\n\n    self.notes[idx].append(msg)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DCode.get_ins_off","title":"<code>get_ins_off(off)</code>","text":"<p>Get a particular instruction by using the address</p> <p>Parameters:</p> Name Type Description Default <code>off</code> <code>int</code> <p>address of the instruction</p> required <p>Returns:</p> Type Description <code>Instruction</code> <p>an <code>Instruction</code> object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_ins_off(self, off: int) -&gt; Instruction:\n    \"\"\"\n    Get a particular instruction by using the address\n\n    :param off: address of the instruction\n\n    :returns: an `Instruction` object\n    \"\"\"\n    idx = 0\n    for i in self.get_instructions():\n        if idx == off:\n            return i\n        idx += i.get_length()\n    return None\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DCode.get_insn","title":"<code>get_insn()</code>","text":"<p>Get the insn buffer</p> <p>Returns:</p> Type Description <code>bytes</code> <p>insn bytes</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_insn(self) -&gt; bytes:\n    \"\"\"\n    Get the insn buffer\n\n    :returns: insn bytes\n    \"\"\"\n    return self.insn\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DCode.get_instruction","title":"<code>get_instruction(idx, off=None)</code>","text":"<p>Get a particular instruction by using (default) the index of the address if specified</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>index of the instruction (the position in the list of the instruction)</p> required <code>off</code> <code>Union[int, None]</code> <p>address of the instruction</p> <code>None</code> <p>Returns:</p> Type Description <code>Instruction</code> <p>an <code>Instruction</code> object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_instruction(\n    self, idx: int, off: Union[int, None] = None\n) -&gt; Instruction:\n    \"\"\"\n    Get a particular instruction by using (default) the index of the address if specified\n\n    :param idx: index of the instruction (the position in the list of the instruction)\n    :param off: address of the instruction\n\n    :returns: an `Instruction` object\n    \"\"\"\n    if off is not None:\n        idx = self.off_to_pos(off)\n    if self.cached_instructions is None:\n        self.get_instructions()\n    return self.cached_instructions[idx]\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DCode.get_instructions","title":"<code>get_instructions()</code>","text":"<p>Return an iterator over Instruction</p> <p>Returns:</p> Type Description <code>Iterator[Instruction]</code> <p>a generator of each <code>Instruction</code> (or a cached list of instructions if you have setup instructions)</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_instructions(self) -&gt; Iterator[Instruction]:\n    \"\"\"\n    Return an iterator over [Instruction][androguard.core.dex.Instruction]\n\n    :returns: a generator of each `Instruction` (or a cached list of instructions if you have setup instructions)\n    \"\"\"\n    # it is possible to a cache for instructions (avoid a new disasm)\n    if self.cached_instructions is None:\n        ins = LinearSweepAlgorithm.get_instructions(\n            self.CM, self.size, self.insn, self.idx\n        )\n        self.cached_instructions = list(ins)\n\n    for i in self.cached_instructions:\n        yield i\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DCode.get_length","title":"<code>get_length()</code>","text":"<p>Return the length of this object</p> <p>Returns:</p> Type Description <code>int</code> <p>length int</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_length(self) -&gt; int:\n    \"\"\"\n    Return the length of this object\n\n    :returns: length int\n    \"\"\"\n    return len(self.get_raw())\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DCode.get_raw","title":"<code>get_raw()</code>","text":"<p>Return the raw buffer of this object</p> <p>Returns:</p> Type Description <code>bytearray</code> <p>buffer bytearray</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_raw(self) -&gt; bytearray:\n    \"\"\"\n    Return the raw buffer of this object\n\n    :returns: buffer bytearray\n    \"\"\"\n    buff = bytearray()\n    for i in self.get_instructions():\n        buff += i.get_raw()\n    return buff\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DCode.off_to_pos","title":"<code>off_to_pos(off)</code>","text":"<p>Get the position of an instruction by using the address</p> <p>Parameters:</p> Name Type Description Default <code>off</code> <code>int</code> <p>address of the instruction</p> required <p>Returns:</p> Type Description <code>int</code> <p>the offset</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def off_to_pos(self, off: int) -&gt; int:\n    \"\"\"\n    Get the position of an instruction by using the address\n\n    :param off: address of the instruction\n\n    :returns: the offset\n    \"\"\"\n    idx = 0\n    nb = 0\n    for i in self.get_instructions():\n        if idx == off:\n            return nb\n        nb += 1\n        idx += i.get_length()\n    return -1\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DCode.seek","title":"<code>seek(idx)</code>","text":"<p>Set the start address of the buffer</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>the index</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def seek(self, idx: int) -&gt; None:\n    \"\"\"\n    Set the start address of the buffer\n\n    :param idx: the index\n    \"\"\"\n    self.idx = idx\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DCode.set_insn","title":"<code>set_insn(insn)</code>","text":"<p>Set a new raw buffer to disassemble</p> <p>Parameters:</p> Name Type Description Default <code>insn</code> <code>bytes</code> <p>the buffer</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def set_insn(self, insn: bytes) -&gt; None:\n    \"\"\"\n    Set a new raw buffer to disassemble\n\n    :param insn: the buffer\n    \"\"\"\n    self.insn = insn\n    self.size = len(self.insn)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DCode.set_instructions","title":"<code>set_instructions(instructions)</code>","text":"<p>Set the instructions</p> <p>Parameters:</p> Name Type Description Default <code>instructions</code> <code>list[Instruction]</code> <p>the list of instructions</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def set_instructions(self, instructions: list[Instruction]) -&gt; None:\n    \"\"\"\n    Set the instructions\n\n    :param instructions: the list of instructions\n    \"\"\"\n    self.cached_instructions = instructions\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DCode.show","title":"<code>show()</code>","text":"<p>Display (with a pretty print) this object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"\n    Display (with a pretty print) this object\n    \"\"\"\n    off = 0\n    for n, i in enumerate(self.get_instructions()):\n        print(\n            \"{:8d} (0x{:08x}) {:04x} {:30} {}\".format(\n                n,\n                off,\n                i.get_op_value(),\n                i.get_name(),\n                i.get_output(self.idx),\n            )\n        )\n        off += i.get_length()\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX","title":"<code>DEX</code>","text":"<p>This class can parse a classes.dex file of an Android application (APK).</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <p>a string which represents the classes.dex file</p> required <code>decompiler</code> <code>Union[DecompilerDAD, None]</code> <p>associate a decompiler object to display the java source code  Example:  &gt;&gt;&gt; d = DEX( read(\"classes.dex\") )</p> <code>None</code> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class DEX:\n    \"\"\"\n    This class can parse a classes.dex file of an Android application (APK).\n\n    :param buff: a string which represents the classes.dex file\n    :param decompiler: associate a decompiler object to display the java source code\n\n    Example:\n\n        &gt;&gt;&gt; d = DEX( read(\"classes.dex\") )\n    \"\"\"\n\n    def __init__(\n        self,\n        buff,\n        decompiler: Union[DecompilerDAD, None] = None,\n        config=None,\n        using_api: Union[int, None] = None,\n    ) -&gt; None:\n        logger.debug(\"DEX {} {} {}\".format(decompiler, config, using_api))\n\n        # to allow to pass apk object ==&gt; we do not need to pass additionally target version\n        if isinstance(buff, apk.APK):\n            self.api_version = buff.get_target_sdk_version()\n            buff = buff.get_dex()  # getting dex from APK file\n        elif using_api:\n            self.api_version = using_api\n        else:\n            self.api_version = CONF[\"DEFAULT_API\"]\n\n        self.raw = io.BufferedReader(io.BytesIO(buff))\n\n        self._flush()\n\n        self.CM = ClassManager(self)\n        self.CM.set_decompiler(decompiler)\n\n        self._preload(buff)\n        self._load(buff)\n\n    def _preload(self, buff):\n        pass\n\n    def _load(self, buff) -&gt; None:\n        self.header = HeaderItem(0, self.raw, self.CM)\n\n        if self.header.map_off == 0:\n            # TODO check if the header specifies items but does not have a map\n            logger.warning(\"no map list! This DEX file is probably empty.\")\n        else:\n            self.map_list = MapList(self.CM, self.header.map_off, self.raw)\n\n            self.classes = self.map_list.get_item_type(\n                TypeMapItem.CLASS_DEF_ITEM\n            )\n            self.methods = self.map_list.get_item_type(\n                TypeMapItem.METHOD_ID_ITEM\n            )\n            self.fields = self.map_list.get_item_type(\n                TypeMapItem.FIELD_ID_ITEM\n            )\n            self.codes = self.map_list.get_item_type(TypeMapItem.CODE_ITEM)\n            self.strings = self.map_list.get_item_type(\n                TypeMapItem.STRING_DATA_ITEM\n            )\n            self.debug = self.map_list.get_item_type(\n                TypeMapItem.DEBUG_INFO_ITEM\n            )\n            self.hidden_api = self.map_list.get_item_type(\n                TypeMapItem.HIDDENAPI_CLASS_DATA_ITEM\n            )\n\n        self._flush()\n\n    def _flush(self) -&gt; None:\n        \"\"\"\n        Flush all caches\n        Might be used after classes, methods or fields are added.\n        \"\"\"\n        self.classes_names = None\n        self.__cache_methods = None\n        self.__cached_methods_idx = None\n        self.__cache_fields = None\n\n        # cache methods and fields as well, otherwise the decompiler is quite slow\n        self.__cache_all_methods = None\n        self.__cache_all_fields = None\n\n    @property\n    def version(self) -&gt; int:\n        \"\"\"\n        Returns the version number of the DEX Format\n        \"\"\"\n        return self.header.dex_version\n\n    def get_api_version(self) -&gt; int:\n        \"\"\"\n        This method returns api version that should be used for loading api\n        specific resources.\n\n        :returns: api version string\n        \"\"\"\n        return self.api_version\n\n    def get_classes_def_item(self) -&gt; ClassHDefItem:\n        \"\"\"\n        This function returns the class def item\n\n        :returns: `ClassHDefItem` object\n        \"\"\"\n        return self.classes\n\n    def get_methods_id_item(self) -&gt; MethodHIdItem:\n        \"\"\"\n        This function returns the method id item\n\n        :returns: `MethodHIdItem` object\n        \"\"\"\n        return self.methods\n\n    def get_fields_id_item(self) -&gt; FieldHIdItem:\n        \"\"\"\n        This function returns the field id item\n\n        :returns: `FieldHIdItem` object\n        \"\"\"\n        return self.fields\n\n    def get_codes_item(self) -&gt; CodeItem:\n        \"\"\"\n        This function returns the code item\n\n        :returns: `CodeItem` object\n        \"\"\"\n        return self.codes\n\n    def get_string_data_item(self) -&gt; StringDataItem:\n        \"\"\"\n        This function returns the string data item\n\n        :returns: `StringDataItem` object\n        \"\"\"\n        return self.strings\n\n    # TODO: this returns DebugInfoItemEmpty, as DebugInfoItem never gets set as a MapItem\n    def get_debug_info_item(self) -&gt; DebugInfoItemEmpty:\n        \"\"\"\n        This function returns the debug info item\n        :returns: `DebugInfoItemEmpty` object\n        \"\"\"\n        return self.debug\n\n    def get_header_item(self) -&gt; HeaderItem:\n        \"\"\"\n        This function returns the header item\n\n        :returns: `HeaderItem` object\n        \"\"\"\n        return self.header\n\n    def get_hidden_api(self) -&gt; HiddenApiClassDataItem:\n        \"\"\"\n        This function returns the hidden api item (from Android 10)\n\n        :returns: `HiddenApiClassDataItem` object\n        \"\"\"\n        return self.hidden_api\n\n    def get_class_manager(self) -&gt; ClassManager:\n        \"\"\"\n        This function returns a ClassManager object which allow you to get\n        access to all index references (strings, methods, fields, ....)\n\n        :returns: `ClassManager` object\n        \"\"\"\n        return self.CM\n\n    def show(self) -&gt; None:\n        \"\"\"\n        Show the all information in the object\n        \"\"\"\n        self.map_list.show()\n\n    def save(self) -&gt; bytes:\n        \"\"\"\n        Return the dex (with the modifications) into raw format (fix checksums)\n        (beta: do not use !)\n\n        :returns: bytes\n        \"\"\"\n        l = []\n        h = {}\n        s = {}\n        h_r = {}\n\n        idx = 0\n        for i in self.map_list.get_obj():\n            length = 0\n\n            if isinstance(i, list):\n                for j in i:\n                    if isinstance(j, AnnotationsDirectoryItem):\n                        if idx % 4 != 0:\n                            idx = idx + (4 - (idx % 4))\n\n                    l.append(j)\n\n                    c_length = j.get_length()\n                    if isinstance(j, StringDataItem):\n                        c_length += 1\n                    h[j] = idx + length\n                    h_r[idx + length] = j\n                    s[idx + length] = c_length\n\n                    length += c_length\n                    # logger.debug(\"SAVE\" + str(j) + \" @ 0x%x\" % (idx+length))\n\n                logger.debug(\n                    \"SAVE \" + str(i[0]) + \" @0x{:x} ({:x})\".format(idx, length)\n                )\n\n            else:\n                if isinstance(i, MapList):\n                    if idx % 4 != 0:\n                        idx = idx + (4 - (idx % 4))\n\n                l.append(i)\n                h[i] = idx\n                h_r[idx] = i\n\n                length = i.get_length()\n\n                s[idx] = length\n\n                logger.debug(\n                    \"SAVE \" + str(i) + \" @0x{:x} ({:x})\".format(idx, length)\n                )\n\n            idx += length\n\n        self.header.file_size = idx\n\n        for i in l:\n            idx = h[i]\n            i.set_off(idx)\n            if isinstance(i, CodeItem):\n                last_idx = idx\n                for j in i.get_obj():\n                    j.set_off(last_idx)\n                    # j.set_debug_info_off(0)\n                    last_idx += j.get_size()\n\n        last_idx = 0\n        buff = bytearray()\n        for i in l:\n            idx = h[i]\n\n            if idx != last_idx:\n                logger.debug(\n                    \"Adjust alignment @{:x} with 00 {:x}\".format(\n                        idx, idx - last_idx\n                    )\n                )\n                buff += bytearray([0] * (idx - last_idx))\n\n            buff += i.get_raw()\n            if isinstance(i, StringDataItem):\n                buff += b\"\\x00\"\n            last_idx = idx + s[idx]\n\n        logger.debug(\"GLOBAL SIZE %d\" % len(buff))\n\n        return self.fix_checksums(buff)\n\n    def fix_checksums(self, buff: bytes) -&gt; bytes:\n        \"\"\"\n        Fix a dex format buffer by setting all checksums\n\n        :returns: bytes\n        \"\"\"\n\n        signature = hashlib.sha1(buff[32:]).digest()\n\n        buff = buff[:12] + signature + buff[32:]\n        checksum = zlib.adler32(buff[12:])\n        buff = buff[:8] + self.CM.packer[\"I\"].pack(checksum) + buff[12:]\n\n        logger.debug(\"NEW SIGNATURE %s\" % repr(signature))\n        logger.debug(\"NEW CHECKSUM %x\" % checksum)\n\n        return buff\n\n    def get_cm_field(self, idx: int) -&gt; list[str]:\n        \"\"\"\n        Get a specific field by using an index\n\n        :param idx: index of the field\n        \"\"\"\n        return self.CM.get_field(idx)\n\n    def get_cm_method(self, idx: int) -&gt; list[str]:\n        \"\"\"\n        Get a specific method by using an index\n\n        :param idx: index of the method\n        \"\"\"\n        return self.CM.get_method(idx)\n\n    def get_cm_string(self, idx: int) -&gt; str:\n        \"\"\"\n        Get a specific string by using an index\n\n        :param idx: index of the string\n\n        :returns: the string\n        \"\"\"\n        return self.CM.get_raw_string(idx)\n\n    def get_cm_type(self, idx: int) -&gt; str:\n        \"\"\"\n        Get a specific type by using an index\n\n        :param idx: index of the type\n\n        :returns: the string type\n        \"\"\"\n        return self.CM.get_type(idx)\n\n    def get_classes_names(self, update: bool = False) -&gt; list[str]:\n        \"\"\"\n        Return the names of classes\n\n        :param update: `True` indicates to recompute the list. Maybe needed after using a MyClass.set_name().\n        :returns: a list of string names\n        \"\"\"\n        if self.classes_names is None or update:\n            self.classes_names = [i.get_name() for i in self.get_classes()]\n        return self.classes_names\n\n    def get_classes(self) -&gt; list[ClassDefItem]:\n        \"\"\"\n        Return all classes\n\n        :returns: a list of `ClassDefItem` objects\n        \"\"\"\n        if self.classes:\n            return self.classes.class_def\n        else:\n            # There is a rare case that the DEX has no classes\n            return []\n\n    def get_len_classes(self) -&gt; int:\n        \"\"\"\n        Return the number of classes\n\n        :returns: int\n        \"\"\"\n        return len(self.get_classes())\n\n    def get_class(self, name: str) -&gt; Union[ClassDefItem, None]:\n        \"\"\"\n        Return a specific class\n\n        :param name: the name of the class\n\n        :returns: a `ClassDefItem`\n        \"\"\"\n        for i in self.get_classes():\n            if i.get_name() == name:\n                return i\n        return None\n\n    def get_field(self, name: str) -&gt; list[FieldIdItem]:\n        \"\"\"get field id item by name\n\n        :param name: the name of the field (a python string regexp)\n        :returns: the list of matching `FieldIdItem` objects\n        \"\"\"\n\n        prog = re.compile(name)\n        l = []\n        for i in self.get_fields():\n            if prog.match(i.name):\n                l.append(i)\n        return l\n\n    def get_fields(self) -&gt; list[FieldIdItem]:\n        \"\"\"\n        Return a list of field items\n\n        :returns: a list of `FieldIdItem` objects\n        \"\"\"\n        try:\n            return self.fields.gets()\n        except AttributeError:\n            return []\n\n    def get_len_fields(self) -&gt; int:\n        \"\"\"\n        Return the number of fields\n\n        :returns: int\n        \"\"\"\n        return len(self.get_fields())\n\n    def get_encoded_field(self, name: str) -&gt; list[EncodedField]:\n        \"\"\"\n        Return a list all fields which corresponds to the regexp\n\n        :param name: the name of the field (a python string regexp)\n\n        :returns: a list with all `EncodedField` objects\n        \"\"\"\n        # TODO could use a generator here\n        prog = re.compile(name)\n        l = []\n        for i in self.get_encoded_fields():\n            if prog.match(i.get_name()):\n                l.append(i)\n        return l\n\n    def get_encoded_fields(self) -&gt; list[EncodedField]:\n        \"\"\"\n        Return all field objects\n\n        :returns: a list of `EncodedField` objects\n        \"\"\"\n        if self.__cache_all_fields is None:\n            self.__cache_all_fields = []\n            for i in self.get_classes():\n                for j in i.get_fields():\n                    self.__cache_all_fields.append(j)\n        return self.__cache_all_fields\n\n    def get_len_encoded_fields(self) -&gt; int:\n        return len(self.get_encoded_fields())\n\n    def get_field(self, name: str) -&gt; list[FieldIdItem]:\n        \"\"\"get field id item by name\n\n        :param name: the name of the field (a python string regexp)\n        :returns: the list of matching `FieldIdItem` objects\n        \"\"\"\n        prog = re.compile(name)\n        l = []\n        for i in self.get_fields():\n            if prog.match(i.name):\n                l.append(i)\n        return l\n\n    def get_method(self, name: str) -&gt; list[MethodIdItem]:\n        \"\"\"get method id item by name\n\n        :param name: the name of the field (a python string regexp)\n        :returns: the list of matching `MethodIdItem` objects\n        \"\"\"\n        prog = re.compile(name)\n        l = []\n        for i in self.get_methods():\n            if prog.match(i.name):\n                l.append(i)\n        return l\n\n    def get_methods(self) -&gt; list[MethodIdItem]:\n        \"\"\"\n        Return a list of method items\n\n        :returns: a list of `MethodIdItem` objects\n        \"\"\"\n        try:\n            return self.methods.gets()\n        except AttributeError:\n            return []\n\n    def get_len_methods(self) -&gt; int:\n        \"\"\"\n        Return the number of methods\n\n        :returns: int\n        \"\"\"\n        return len(self.get_methods())\n\n    def get_encoded_method(self, name: str) -&gt; list[EncodedMethod]:\n        \"\"\"\n        Return a list all encoded methods whose name corresponds to the regexp\n\n        :param name: the name of the method (a python string regexp)\n\n        :returns: a list with all `EncodedMethod` objects\n        \"\"\"\n        prog = re.compile(name)\n        l = []\n        for i in self.get_encoded_methods():\n            if prog.match(i.name):\n                l.append(i)\n        return l\n\n    def get_encoded_methods(self) -&gt; list[EncodedMethod]:\n        \"\"\"\n        Return all encoded method objects\n\n        :returns: a list of `EncodedMethod` objects\n        \"\"\"\n        if self.__cache_all_methods is None:\n            self.__cache_all_methods = []\n            for i in self.get_classes():\n                for j in i.get_methods():\n                    self.__cache_all_methods.append(j)\n        return self.__cache_all_methods\n\n    def get_len_encoded_methods(self) -&gt; int:\n        \"\"\"\n        Return the number of encoded methods\n\n        :returns: int\n        \"\"\"\n        return len(self.get_encoded_methods())\n\n    def get_encoded_method_by_idx(\n        self, idx: int\n    ) -&gt; Union[EncodedMethod, None]:\n        \"\"\"\n        Return a specific encoded method by using an index\n        :param idx: the index of the method\n\n        :returns: `None` or an `EncodedMethod` object\n        \"\"\"\n        if self.__cached_methods_idx is None:\n            self.__cached_methods_idx = {}\n            for i in self.get_classes():\n                for j in i.get_methods():\n                    self.__cached_methods_idx[j.get_method_idx()] = j\n\n        try:\n            return self.__cached_methods_idx[idx]\n        except KeyError:\n            return None\n\n    def get_encoded_method_descriptor(\n        self, class_name: str, method_name: str, descriptor: str\n    ) -&gt; Union[EncodedMethod, None]:\n        \"\"\"\n        Return the specific encoded method given a class name, method name, and descriptor\n\n        :param class_name: the class name of the method\n        :param method_name: the name of the method\n        :param descriptor: the descriptor of the method\n\n        :returns: `None` or a `EncodedMethod` object\n        \"\"\"\n        key = class_name + method_name + descriptor\n\n        if self.__cache_methods is None:\n            self.__cache_methods = {}\n            for i in self.get_classes():\n                for j in i.get_methods():\n                    self.__cache_methods[\n                        j.get_class_name() + j.get_name() + j.get_descriptor()\n                    ] = j\n\n        return self.__cache_methods.get(key)\n\n    def get_encoded_methods_class_method(\n        self, class_name: str, method_name: str\n    ) -&gt; Union[EncodedMethod, None]:\n        \"\"\"\n        Return the specific encoded methods of the class\n\n        :param class_name: the class name of the method\n        :param method_name: the name of the method\n\n        :returns: `None` or a `EncodedMethod` object\n        \"\"\"\n        for i in self.get_encoded_methods():\n            if (\n                i.get_name() == method_name\n                and i.get_class_name() == class_name\n            ):\n                return i\n        return None\n\n    def get_encoded_methods_class(\n        self, class_name: str\n    ) -&gt; list[EncodedMethod]:\n        \"\"\"\n        Return all encoded methods of a specific class by class name\n\n        :param class_name: the class name\n\n        :returns: a list with `EncodedMethod` objects\n        \"\"\"\n        l = []\n        for i in self.get_encoded_methods():\n            if class_name == i.get_class_name():\n                l.append(i)\n        return l\n\n    def get_encoded_fields_class(self, class_name: str) -&gt; list[EncodedField]:\n        \"\"\"\n        Return all encoded fields of a specific class by class name\n\n        :param class_name: the class name\n\n        :returns: a list with `EncodedField` objects\n        \"\"\"\n        l = []\n        for i in self.get_encoded_fields():\n            if class_name == i.get_class_name():\n                l.append(i)\n        return l\n\n    def get_encoded_field_descriptor(\n        self, class_name: str, field_name: str, descriptor: str\n    ) -&gt; EncodedField:\n        \"\"\"\n        Return the specific encoded field given a class name, field name, and descriptor\n\n        :param class_name: the class name of the field\n        :param field_name: the name of the field\n        :param descriptor: the descriptor of the field\n\n        :returns: `None` or a `EncodedField` object\n        \"\"\"\n\n        key = class_name + field_name + descriptor\n\n        if self.__cache_fields is None:\n            self.__cache_fields = {}\n            for i in self.get_classes():\n                for j in i.get_fields():\n                    self.__cache_fields[\n                        j.get_class_name() + j.get_name() + j.get_descriptor()\n                    ] = j\n\n        return self.__cache_fields.get(key)\n\n    def get_strings(self) -&gt; list[str]:\n        \"\"\"\n        Return all strings\n\n        The strings will have escaped surrogates, if only a single high or low surrogate is found.\n        Complete surrogates are put together into the representing 32bit character.\n\n        :returns: a list with all strings used in the format (types, names ...)\n        \"\"\"\n        return (\n            [i.get() for i in self.strings] if self.strings is not None else []\n        )\n\n    def get_len_strings(self) -&gt; int:\n        \"\"\"\n        Return the number of strings\n\n        :returns: int\n        \"\"\"\n        return len(self.get_strings())\n\n    def get_regex_strings(\n        self, regular_expressions: str\n    ) -&gt; Union[list[str], None]:\n        \"\"\"\n        Return all target strings matched the regex\n\n        :param regular_expressions: the python regex string\n\n        :returns: a list of strings matching the regex expression\n        \"\"\"\n        str_list = []\n        if regular_expressions.count is None:\n            return None\n        for i in self.get_strings():\n            if re.match(regular_expressions, i):\n                str_list.append(i)\n        return str_list\n\n    def get_format_type(self) -&gt; str:\n        \"\"\"\n        Return the type\n\n        :returns: a string\n        \"\"\"\n        return \"DEX\"\n\n    def create_python_export(self) -&gt; None:\n        \"\"\"\n        Export classes/methods/fields' names in the python namespace\n        \"\"\"\n        logger.debug(\"Exporting Python objects\")\n        setattr(self, \"C\", ExportObject())\n\n        for _class in self.get_classes():\n            self._create_python_export_class(_class)\n\n    def _delete_python_export_class(self, _class: ClassDefItem) -&gt; None:\n        self._create_python_export_class(_class, True)\n\n    def _create_python_export_class(\n        self, _class: ClassDefItem, delete: bool = False\n    ) -&gt; None:\n        if _class is not None:\n            ### Class\n            name = str(bytecode.FormatClassToPython(_class.get_name()))\n            if delete:\n                delattr(self.C, name)\n                return\n            else:\n                setattr(self.C, name, _class)\n                setattr(_class, \"M\", ExportObject())\n                setattr(_class, \"F\", ExportObject())\n\n            self._create_python_export_methods(_class, delete)\n            self._create_python_export_fields(_class, delete)\n\n    def _create_python_export_methods(\n        self, _class: ClassDefItem, delete\n    ) -&gt; None:\n        m = {}\n        for method in _class.get_methods():\n            if method.get_name() not in m:\n                m[method.get_name()] = []\n            m[method.get_name()].append(method)\n            setattr(method, \"XF\", ExportObject())\n            setattr(method, \"XT\", ExportObject())\n\n        for i in m:\n            if len(m[i]) == 1:\n                j = m[i][0]\n                name = str(bytecode.FormatNameToPython(j.get_name()))\n                setattr(_class.M, name, j)\n            else:\n                for j in m[i]:\n                    name = (\n                        str(bytecode.FormatNameToPython(j.get_name()))\n                        + \"_\"\n                        + str(\n                            bytecode.FormatDescriptorToPython(\n                                j.get_descriptor()\n                            )\n                        )\n                    )\n                    setattr(_class.M, name, j)\n\n    def _create_python_export_fields(\n        self, _class: ClassDefItem, delete\n    ) -&gt; None:\n        f = {}\n        for field in _class.get_fields():\n            if field.get_name() not in f:\n                f[field.get_name()] = []\n            f[field.get_name()].append(field)\n            setattr(field, \"XR\", ExportObject())\n            setattr(field, \"XW\", ExportObject())\n\n        for i in f:\n            if len(f[i]) == 1:\n                j = f[i][0]\n                name = str(bytecode.FormatNameToPython(j.get_name()))\n                setattr(_class.F, name, j)\n            else:\n                for j in f[i]:\n                    name = (\n                        str(bytecode.FormatNameToPython(j.get_name()))\n                        + \"_\"\n                        + str(\n                            bytecode.FormatDescriptorToPython(\n                                j.get_descriptor()\n                            )\n                        )\n                    )\n                    setattr(_class.F, name, j)\n\n    def set_decompiler(self, decompiler: DecompilerDAD) -&gt; None:\n        self.CM.set_decompiler(decompiler)\n\n    def set_analysis(self, analysis_dex: Analysis) -&gt; None:\n        self.CM.set_analysis(analysis_dex)\n\n    def disassemble(self, offset: int, size: int) -&gt; Iterator[Instruction]:\n        \"\"\"\n        Disassembles a given offset in the DEX file\n\n        :param offset: offset to disassemble in the file (from the beginning of the file)\n        :param size:\n\n        :returns: iterator over `Instruction`s at the given offset\n        \"\"\"\n        for i in DCode(\n            self.CM, offset, size, read_at(self.raw, offset, size)\n        ).get_instructions():\n            yield i\n\n    def _get_class_hierarchy(self) -&gt; Node:\n        \"\"\"\n        Constructs a tree out of all the classes.\n        The classes are added to this tree by their superclass.\n\n        :returns: the root `Node` of the tree\n        \"\"\"\n        # Contains the class names as well as their running number\n        ids = dict()\n        present = dict()\n        r_ids = dict()\n        to_add = dict()\n        els = []\n\n        for current_class in self.get_classes():\n            s_name = current_class.get_superclassname()[1:-1]\n            c_name = current_class.get_name()[1:-1]\n\n            if s_name not in ids:\n                ids[s_name] = len(ids) + 1\n                r_ids[ids[s_name]] = s_name\n\n            if c_name not in ids:\n                ids[c_name] = len(ids) + 1\n\n            els.append([ids[c_name], ids[s_name], c_name])\n            present[ids[c_name]] = True\n\n        for i in els:\n            if i[1] not in present:\n                to_add[i[1]] = r_ids[i[1]]\n\n        for i in to_add:\n            els.append([i, 0, to_add[i]])\n\n        treeMap = dict()\n        Root = bytecode.Node(0, \"Root\")\n        treeMap[Root.id] = Root\n        for element in els:\n            nodeId, parentId, title = element\n            if not nodeId in treeMap:\n                treeMap[nodeId] = bytecode.Node(nodeId, title)\n            else:\n                treeMap[nodeId].id = nodeId\n                treeMap[nodeId].title = title\n\n            if not parentId in treeMap:\n                treeMap[parentId] = bytecode.Node(0, '')\n            treeMap[parentId].children.append(treeMap[nodeId])\n\n        return Root\n\n    def list_classes_hierarchy(self) -&gt; dict[str, list[dict[str, list]]]:\n        \"\"\"\n        Get a tree structure of the classes.\n        The parent is always the superclass.\n\n        You can use `pprint.pprint` to print the\n        dictionary in a pretty way.\n\n        :returns: a tree in dictionary format where the key is the class name and the value is a list of dictionaries containing a child class name as a key and subsequent child classes as a value list\n        \"\"\"\n\n        def print_map(node, l):\n            if node.title not in l:\n                l[node.title] = []\n\n            for n in node.children:\n                if len(n.children) &gt; 0:\n                    w = {n.title: []}\n                    l[node.title].append(w)\n\n                    print_map(n, w)\n                else:\n                    l[node.title].append(n.title)\n\n        l = {}\n        print_map(self._get_class_hierarchy(), l)\n\n        return l\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.version","title":"<code>version</code>  <code>property</code>","text":"<p>Returns the version number of the DEX Format</p>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.create_python_export","title":"<code>create_python_export()</code>","text":"<p>Export classes/methods/fields' names in the python namespace</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def create_python_export(self) -&gt; None:\n    \"\"\"\n    Export classes/methods/fields' names in the python namespace\n    \"\"\"\n    logger.debug(\"Exporting Python objects\")\n    setattr(self, \"C\", ExportObject())\n\n    for _class in self.get_classes():\n        self._create_python_export_class(_class)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.disassemble","title":"<code>disassemble(offset, size)</code>","text":"<p>Disassembles a given offset in the DEX file</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>offset to disassemble in the file (from the beginning of the file)</p> required <code>size</code> <code>int</code> required <p>Returns:</p> Type Description <code>Iterator[Instruction]</code> <p>iterator over <code>Instruction</code>s at the given offset</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def disassemble(self, offset: int, size: int) -&gt; Iterator[Instruction]:\n    \"\"\"\n    Disassembles a given offset in the DEX file\n\n    :param offset: offset to disassemble in the file (from the beginning of the file)\n    :param size:\n\n    :returns: iterator over `Instruction`s at the given offset\n    \"\"\"\n    for i in DCode(\n        self.CM, offset, size, read_at(self.raw, offset, size)\n    ).get_instructions():\n        yield i\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.fix_checksums","title":"<code>fix_checksums(buff)</code>","text":"<p>Fix a dex format buffer by setting all checksums</p> <p>Returns:</p> Type Description <code>bytes</code> <p>bytes</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def fix_checksums(self, buff: bytes) -&gt; bytes:\n    \"\"\"\n    Fix a dex format buffer by setting all checksums\n\n    :returns: bytes\n    \"\"\"\n\n    signature = hashlib.sha1(buff[32:]).digest()\n\n    buff = buff[:12] + signature + buff[32:]\n    checksum = zlib.adler32(buff[12:])\n    buff = buff[:8] + self.CM.packer[\"I\"].pack(checksum) + buff[12:]\n\n    logger.debug(\"NEW SIGNATURE %s\" % repr(signature))\n    logger.debug(\"NEW CHECKSUM %x\" % checksum)\n\n    return buff\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_api_version","title":"<code>get_api_version()</code>","text":"<p>This method returns api version that should be used for loading api specific resources.</p> <p>Returns:</p> Type Description <code>int</code> <p>api version string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_api_version(self) -&gt; int:\n    \"\"\"\n    This method returns api version that should be used for loading api\n    specific resources.\n\n    :returns: api version string\n    \"\"\"\n    return self.api_version\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_class","title":"<code>get_class(name)</code>","text":"<p>Return a specific class</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the class</p> required <p>Returns:</p> Type Description <code>Union[ClassDefItem, None]</code> <p>a <code>ClassDefItem</code></p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_class(self, name: str) -&gt; Union[ClassDefItem, None]:\n    \"\"\"\n    Return a specific class\n\n    :param name: the name of the class\n\n    :returns: a `ClassDefItem`\n    \"\"\"\n    for i in self.get_classes():\n        if i.get_name() == name:\n            return i\n    return None\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_class_manager","title":"<code>get_class_manager()</code>","text":"<p>This function returns a ClassManager object which allow you to get access to all index references (strings, methods, fields, ....)</p> <p>Returns:</p> Type Description <code>ClassManager</code> <p><code>ClassManager</code> object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_class_manager(self) -&gt; ClassManager:\n    \"\"\"\n    This function returns a ClassManager object which allow you to get\n    access to all index references (strings, methods, fields, ....)\n\n    :returns: `ClassManager` object\n    \"\"\"\n    return self.CM\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_classes","title":"<code>get_classes()</code>","text":"<p>Return all classes</p> <p>Returns:</p> Type Description <code>list[ClassDefItem]</code> <p>a list of <code>ClassDefItem</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_classes(self) -&gt; list[ClassDefItem]:\n    \"\"\"\n    Return all classes\n\n    :returns: a list of `ClassDefItem` objects\n    \"\"\"\n    if self.classes:\n        return self.classes.class_def\n    else:\n        # There is a rare case that the DEX has no classes\n        return []\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_classes_def_item","title":"<code>get_classes_def_item()</code>","text":"<p>This function returns the class def item</p> <p>Returns:</p> Type Description <code>ClassHDefItem</code> <p><code>ClassHDefItem</code> object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_classes_def_item(self) -&gt; ClassHDefItem:\n    \"\"\"\n    This function returns the class def item\n\n    :returns: `ClassHDefItem` object\n    \"\"\"\n    return self.classes\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_classes_names","title":"<code>get_classes_names(update=False)</code>","text":"<p>Return the names of classes</p> <p>Parameters:</p> Name Type Description Default <code>update</code> <code>bool</code> <p><code>True</code> indicates to recompute the list. Maybe needed after using a MyClass.set_name().</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>a list of string names</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_classes_names(self, update: bool = False) -&gt; list[str]:\n    \"\"\"\n    Return the names of classes\n\n    :param update: `True` indicates to recompute the list. Maybe needed after using a MyClass.set_name().\n    :returns: a list of string names\n    \"\"\"\n    if self.classes_names is None or update:\n        self.classes_names = [i.get_name() for i in self.get_classes()]\n    return self.classes_names\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_cm_field","title":"<code>get_cm_field(idx)</code>","text":"<p>Get a specific field by using an index</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>index of the field</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_cm_field(self, idx: int) -&gt; list[str]:\n    \"\"\"\n    Get a specific field by using an index\n\n    :param idx: index of the field\n    \"\"\"\n    return self.CM.get_field(idx)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_cm_method","title":"<code>get_cm_method(idx)</code>","text":"<p>Get a specific method by using an index</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>index of the method</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_cm_method(self, idx: int) -&gt; list[str]:\n    \"\"\"\n    Get a specific method by using an index\n\n    :param idx: index of the method\n    \"\"\"\n    return self.CM.get_method(idx)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_cm_string","title":"<code>get_cm_string(idx)</code>","text":"<p>Get a specific string by using an index</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>index of the string</p> required <p>Returns:</p> Type Description <code>str</code> <p>the string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_cm_string(self, idx: int) -&gt; str:\n    \"\"\"\n    Get a specific string by using an index\n\n    :param idx: index of the string\n\n    :returns: the string\n    \"\"\"\n    return self.CM.get_raw_string(idx)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_cm_type","title":"<code>get_cm_type(idx)</code>","text":"<p>Get a specific type by using an index</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>index of the type</p> required <p>Returns:</p> Type Description <code>str</code> <p>the string type</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_cm_type(self, idx: int) -&gt; str:\n    \"\"\"\n    Get a specific type by using an index\n\n    :param idx: index of the type\n\n    :returns: the string type\n    \"\"\"\n    return self.CM.get_type(idx)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_codes_item","title":"<code>get_codes_item()</code>","text":"<p>This function returns the code item</p> <p>Returns:</p> Type Description <code>CodeItem</code> <p><code>CodeItem</code> object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_codes_item(self) -&gt; CodeItem:\n    \"\"\"\n    This function returns the code item\n\n    :returns: `CodeItem` object\n    \"\"\"\n    return self.codes\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_debug_info_item","title":"<code>get_debug_info_item()</code>","text":"<p>This function returns the debug info item</p> <p>Returns:</p> Type Description <code>DebugInfoItemEmpty</code> <p><code>DebugInfoItemEmpty</code> object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_debug_info_item(self) -&gt; DebugInfoItemEmpty:\n    \"\"\"\n    This function returns the debug info item\n    :returns: `DebugInfoItemEmpty` object\n    \"\"\"\n    return self.debug\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_encoded_field","title":"<code>get_encoded_field(name)</code>","text":"<p>Return a list all fields which corresponds to the regexp</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the field (a python string regexp)</p> required <p>Returns:</p> Type Description <code>list[EncodedField]</code> <p>a list with all <code>EncodedField</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_encoded_field(self, name: str) -&gt; list[EncodedField]:\n    \"\"\"\n    Return a list all fields which corresponds to the regexp\n\n    :param name: the name of the field (a python string regexp)\n\n    :returns: a list with all `EncodedField` objects\n    \"\"\"\n    # TODO could use a generator here\n    prog = re.compile(name)\n    l = []\n    for i in self.get_encoded_fields():\n        if prog.match(i.get_name()):\n            l.append(i)\n    return l\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_encoded_field_descriptor","title":"<code>get_encoded_field_descriptor(class_name, field_name, descriptor)</code>","text":"<p>Return the specific encoded field given a class name, field name, and descriptor</p> <p>Parameters:</p> Name Type Description Default <code>class_name</code> <code>str</code> <p>the class name of the field</p> required <code>field_name</code> <code>str</code> <p>the name of the field</p> required <code>descriptor</code> <code>str</code> <p>the descriptor of the field</p> required <p>Returns:</p> Type Description <code>EncodedField</code> <p><code>None</code> or a <code>EncodedField</code> object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_encoded_field_descriptor(\n    self, class_name: str, field_name: str, descriptor: str\n) -&gt; EncodedField:\n    \"\"\"\n    Return the specific encoded field given a class name, field name, and descriptor\n\n    :param class_name: the class name of the field\n    :param field_name: the name of the field\n    :param descriptor: the descriptor of the field\n\n    :returns: `None` or a `EncodedField` object\n    \"\"\"\n\n    key = class_name + field_name + descriptor\n\n    if self.__cache_fields is None:\n        self.__cache_fields = {}\n        for i in self.get_classes():\n            for j in i.get_fields():\n                self.__cache_fields[\n                    j.get_class_name() + j.get_name() + j.get_descriptor()\n                ] = j\n\n    return self.__cache_fields.get(key)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_encoded_fields","title":"<code>get_encoded_fields()</code>","text":"<p>Return all field objects</p> <p>Returns:</p> Type Description <code>list[EncodedField]</code> <p>a list of <code>EncodedField</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_encoded_fields(self) -&gt; list[EncodedField]:\n    \"\"\"\n    Return all field objects\n\n    :returns: a list of `EncodedField` objects\n    \"\"\"\n    if self.__cache_all_fields is None:\n        self.__cache_all_fields = []\n        for i in self.get_classes():\n            for j in i.get_fields():\n                self.__cache_all_fields.append(j)\n    return self.__cache_all_fields\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_encoded_fields_class","title":"<code>get_encoded_fields_class(class_name)</code>","text":"<p>Return all encoded fields of a specific class by class name</p> <p>Parameters:</p> Name Type Description Default <code>class_name</code> <code>str</code> <p>the class name</p> required <p>Returns:</p> Type Description <code>list[EncodedField]</code> <p>a list with <code>EncodedField</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_encoded_fields_class(self, class_name: str) -&gt; list[EncodedField]:\n    \"\"\"\n    Return all encoded fields of a specific class by class name\n\n    :param class_name: the class name\n\n    :returns: a list with `EncodedField` objects\n    \"\"\"\n    l = []\n    for i in self.get_encoded_fields():\n        if class_name == i.get_class_name():\n            l.append(i)\n    return l\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_encoded_method","title":"<code>get_encoded_method(name)</code>","text":"<p>Return a list all encoded methods whose name corresponds to the regexp</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the method (a python string regexp)</p> required <p>Returns:</p> Type Description <code>list[EncodedMethod]</code> <p>a list with all <code>EncodedMethod</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_encoded_method(self, name: str) -&gt; list[EncodedMethod]:\n    \"\"\"\n    Return a list all encoded methods whose name corresponds to the regexp\n\n    :param name: the name of the method (a python string regexp)\n\n    :returns: a list with all `EncodedMethod` objects\n    \"\"\"\n    prog = re.compile(name)\n    l = []\n    for i in self.get_encoded_methods():\n        if prog.match(i.name):\n            l.append(i)\n    return l\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_encoded_method_by_idx","title":"<code>get_encoded_method_by_idx(idx)</code>","text":"<p>Return a specific encoded method by using an index</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>the index of the method</p> required <p>Returns:</p> Type Description <code>Union[EncodedMethod, None]</code> <p><code>None</code> or an <code>EncodedMethod</code> object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_encoded_method_by_idx(\n    self, idx: int\n) -&gt; Union[EncodedMethod, None]:\n    \"\"\"\n    Return a specific encoded method by using an index\n    :param idx: the index of the method\n\n    :returns: `None` or an `EncodedMethod` object\n    \"\"\"\n    if self.__cached_methods_idx is None:\n        self.__cached_methods_idx = {}\n        for i in self.get_classes():\n            for j in i.get_methods():\n                self.__cached_methods_idx[j.get_method_idx()] = j\n\n    try:\n        return self.__cached_methods_idx[idx]\n    except KeyError:\n        return None\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_encoded_method_descriptor","title":"<code>get_encoded_method_descriptor(class_name, method_name, descriptor)</code>","text":"<p>Return the specific encoded method given a class name, method name, and descriptor</p> <p>Parameters:</p> Name Type Description Default <code>class_name</code> <code>str</code> <p>the class name of the method</p> required <code>method_name</code> <code>str</code> <p>the name of the method</p> required <code>descriptor</code> <code>str</code> <p>the descriptor of the method</p> required <p>Returns:</p> Type Description <code>Union[EncodedMethod, None]</code> <p><code>None</code> or a <code>EncodedMethod</code> object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_encoded_method_descriptor(\n    self, class_name: str, method_name: str, descriptor: str\n) -&gt; Union[EncodedMethod, None]:\n    \"\"\"\n    Return the specific encoded method given a class name, method name, and descriptor\n\n    :param class_name: the class name of the method\n    :param method_name: the name of the method\n    :param descriptor: the descriptor of the method\n\n    :returns: `None` or a `EncodedMethod` object\n    \"\"\"\n    key = class_name + method_name + descriptor\n\n    if self.__cache_methods is None:\n        self.__cache_methods = {}\n        for i in self.get_classes():\n            for j in i.get_methods():\n                self.__cache_methods[\n                    j.get_class_name() + j.get_name() + j.get_descriptor()\n                ] = j\n\n    return self.__cache_methods.get(key)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_encoded_methods","title":"<code>get_encoded_methods()</code>","text":"<p>Return all encoded method objects</p> <p>Returns:</p> Type Description <code>list[EncodedMethod]</code> <p>a list of <code>EncodedMethod</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_encoded_methods(self) -&gt; list[EncodedMethod]:\n    \"\"\"\n    Return all encoded method objects\n\n    :returns: a list of `EncodedMethod` objects\n    \"\"\"\n    if self.__cache_all_methods is None:\n        self.__cache_all_methods = []\n        for i in self.get_classes():\n            for j in i.get_methods():\n                self.__cache_all_methods.append(j)\n    return self.__cache_all_methods\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_encoded_methods_class","title":"<code>get_encoded_methods_class(class_name)</code>","text":"<p>Return all encoded methods of a specific class by class name</p> <p>Parameters:</p> Name Type Description Default <code>class_name</code> <code>str</code> <p>the class name</p> required <p>Returns:</p> Type Description <code>list[EncodedMethod]</code> <p>a list with <code>EncodedMethod</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_encoded_methods_class(\n    self, class_name: str\n) -&gt; list[EncodedMethod]:\n    \"\"\"\n    Return all encoded methods of a specific class by class name\n\n    :param class_name: the class name\n\n    :returns: a list with `EncodedMethod` objects\n    \"\"\"\n    l = []\n    for i in self.get_encoded_methods():\n        if class_name == i.get_class_name():\n            l.append(i)\n    return l\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_encoded_methods_class_method","title":"<code>get_encoded_methods_class_method(class_name, method_name)</code>","text":"<p>Return the specific encoded methods of the class</p> <p>Parameters:</p> Name Type Description Default <code>class_name</code> <code>str</code> <p>the class name of the method</p> required <code>method_name</code> <code>str</code> <p>the name of the method</p> required <p>Returns:</p> Type Description <code>Union[EncodedMethod, None]</code> <p><code>None</code> or a <code>EncodedMethod</code> object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_encoded_methods_class_method(\n    self, class_name: str, method_name: str\n) -&gt; Union[EncodedMethod, None]:\n    \"\"\"\n    Return the specific encoded methods of the class\n\n    :param class_name: the class name of the method\n    :param method_name: the name of the method\n\n    :returns: `None` or a `EncodedMethod` object\n    \"\"\"\n    for i in self.get_encoded_methods():\n        if (\n            i.get_name() == method_name\n            and i.get_class_name() == class_name\n        ):\n            return i\n    return None\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_field","title":"<code>get_field(name)</code>","text":"<p>get field id item by name</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the field (a python string regexp)</p> required <p>Returns:</p> Type Description <code>list[FieldIdItem]</code> <p>the list of matching <code>FieldIdItem</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_field(self, name: str) -&gt; list[FieldIdItem]:\n    \"\"\"get field id item by name\n\n    :param name: the name of the field (a python string regexp)\n    :returns: the list of matching `FieldIdItem` objects\n    \"\"\"\n    prog = re.compile(name)\n    l = []\n    for i in self.get_fields():\n        if prog.match(i.name):\n            l.append(i)\n    return l\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_fields","title":"<code>get_fields()</code>","text":"<p>Return a list of field items</p> <p>Returns:</p> Type Description <code>list[FieldIdItem]</code> <p>a list of <code>FieldIdItem</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_fields(self) -&gt; list[FieldIdItem]:\n    \"\"\"\n    Return a list of field items\n\n    :returns: a list of `FieldIdItem` objects\n    \"\"\"\n    try:\n        return self.fields.gets()\n    except AttributeError:\n        return []\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_fields_id_item","title":"<code>get_fields_id_item()</code>","text":"<p>This function returns the field id item</p> <p>Returns:</p> Type Description <code>FieldHIdItem</code> <p><code>FieldHIdItem</code> object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_fields_id_item(self) -&gt; FieldHIdItem:\n    \"\"\"\n    This function returns the field id item\n\n    :returns: `FieldHIdItem` object\n    \"\"\"\n    return self.fields\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_format_type","title":"<code>get_format_type()</code>","text":"<p>Return the type</p> <p>Returns:</p> Type Description <code>str</code> <p>a string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_format_type(self) -&gt; str:\n    \"\"\"\n    Return the type\n\n    :returns: a string\n    \"\"\"\n    return \"DEX\"\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_header_item","title":"<code>get_header_item()</code>","text":"<p>This function returns the header item</p> <p>Returns:</p> Type Description <code>HeaderItem</code> <p><code>HeaderItem</code> object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_header_item(self) -&gt; HeaderItem:\n    \"\"\"\n    This function returns the header item\n\n    :returns: `HeaderItem` object\n    \"\"\"\n    return self.header\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_hidden_api","title":"<code>get_hidden_api()</code>","text":"<p>This function returns the hidden api item (from Android 10)</p> <p>Returns:</p> Type Description <code>HiddenApiClassDataItem</code> <p><code>HiddenApiClassDataItem</code> object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_hidden_api(self) -&gt; HiddenApiClassDataItem:\n    \"\"\"\n    This function returns the hidden api item (from Android 10)\n\n    :returns: `HiddenApiClassDataItem` object\n    \"\"\"\n    return self.hidden_api\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_len_classes","title":"<code>get_len_classes()</code>","text":"<p>Return the number of classes</p> <p>Returns:</p> Type Description <code>int</code> <p>int</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_len_classes(self) -&gt; int:\n    \"\"\"\n    Return the number of classes\n\n    :returns: int\n    \"\"\"\n    return len(self.get_classes())\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_len_encoded_methods","title":"<code>get_len_encoded_methods()</code>","text":"<p>Return the number of encoded methods</p> <p>Returns:</p> Type Description <code>int</code> <p>int</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_len_encoded_methods(self) -&gt; int:\n    \"\"\"\n    Return the number of encoded methods\n\n    :returns: int\n    \"\"\"\n    return len(self.get_encoded_methods())\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_len_fields","title":"<code>get_len_fields()</code>","text":"<p>Return the number of fields</p> <p>Returns:</p> Type Description <code>int</code> <p>int</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_len_fields(self) -&gt; int:\n    \"\"\"\n    Return the number of fields\n\n    :returns: int\n    \"\"\"\n    return len(self.get_fields())\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_len_methods","title":"<code>get_len_methods()</code>","text":"<p>Return the number of methods</p> <p>Returns:</p> Type Description <code>int</code> <p>int</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_len_methods(self) -&gt; int:\n    \"\"\"\n    Return the number of methods\n\n    :returns: int\n    \"\"\"\n    return len(self.get_methods())\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_len_strings","title":"<code>get_len_strings()</code>","text":"<p>Return the number of strings</p> <p>Returns:</p> Type Description <code>int</code> <p>int</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_len_strings(self) -&gt; int:\n    \"\"\"\n    Return the number of strings\n\n    :returns: int\n    \"\"\"\n    return len(self.get_strings())\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_method","title":"<code>get_method(name)</code>","text":"<p>get method id item by name</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the field (a python string regexp)</p> required <p>Returns:</p> Type Description <code>list[MethodIdItem]</code> <p>the list of matching <code>MethodIdItem</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_method(self, name: str) -&gt; list[MethodIdItem]:\n    \"\"\"get method id item by name\n\n    :param name: the name of the field (a python string regexp)\n    :returns: the list of matching `MethodIdItem` objects\n    \"\"\"\n    prog = re.compile(name)\n    l = []\n    for i in self.get_methods():\n        if prog.match(i.name):\n            l.append(i)\n    return l\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_methods","title":"<code>get_methods()</code>","text":"<p>Return a list of method items</p> <p>Returns:</p> Type Description <code>list[MethodIdItem]</code> <p>a list of <code>MethodIdItem</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_methods(self) -&gt; list[MethodIdItem]:\n    \"\"\"\n    Return a list of method items\n\n    :returns: a list of `MethodIdItem` objects\n    \"\"\"\n    try:\n        return self.methods.gets()\n    except AttributeError:\n        return []\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_methods_id_item","title":"<code>get_methods_id_item()</code>","text":"<p>This function returns the method id item</p> <p>Returns:</p> Type Description <code>MethodHIdItem</code> <p><code>MethodHIdItem</code> object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_methods_id_item(self) -&gt; MethodHIdItem:\n    \"\"\"\n    This function returns the method id item\n\n    :returns: `MethodHIdItem` object\n    \"\"\"\n    return self.methods\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_regex_strings","title":"<code>get_regex_strings(regular_expressions)</code>","text":"<p>Return all target strings matched the regex</p> <p>Parameters:</p> Name Type Description Default <code>regular_expressions</code> <code>str</code> <p>the python regex string</p> required <p>Returns:</p> Type Description <code>Union[list[str], None]</code> <p>a list of strings matching the regex expression</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_regex_strings(\n    self, regular_expressions: str\n) -&gt; Union[list[str], None]:\n    \"\"\"\n    Return all target strings matched the regex\n\n    :param regular_expressions: the python regex string\n\n    :returns: a list of strings matching the regex expression\n    \"\"\"\n    str_list = []\n    if regular_expressions.count is None:\n        return None\n    for i in self.get_strings():\n        if re.match(regular_expressions, i):\n            str_list.append(i)\n    return str_list\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_string_data_item","title":"<code>get_string_data_item()</code>","text":"<p>This function returns the string data item</p> <p>Returns:</p> Type Description <code>StringDataItem</code> <p><code>StringDataItem</code> object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_string_data_item(self) -&gt; StringDataItem:\n    \"\"\"\n    This function returns the string data item\n\n    :returns: `StringDataItem` object\n    \"\"\"\n    return self.strings\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.get_strings","title":"<code>get_strings()</code>","text":"<p>Return all strings</p> <p>The strings will have escaped surrogates, if only a single high or low surrogate is found. Complete surrogates are put together into the representing 32bit character.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>a list with all strings used in the format (types, names ...)</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_strings(self) -&gt; list[str]:\n    \"\"\"\n    Return all strings\n\n    The strings will have escaped surrogates, if only a single high or low surrogate is found.\n    Complete surrogates are put together into the representing 32bit character.\n\n    :returns: a list with all strings used in the format (types, names ...)\n    \"\"\"\n    return (\n        [i.get() for i in self.strings] if self.strings is not None else []\n    )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.list_classes_hierarchy","title":"<code>list_classes_hierarchy()</code>","text":"<p>Get a tree structure of the classes. The parent is always the superclass.</p> <p>You can use <code>pprint.pprint</code> to print the dictionary in a pretty way.</p> <p>Returns:</p> Type Description <code>dict[str, list[dict[str, list]]]</code> <p>a tree in dictionary format where the key is the class name and the value is a list of dictionaries containing a child class name as a key and subsequent child classes as a value list</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def list_classes_hierarchy(self) -&gt; dict[str, list[dict[str, list]]]:\n    \"\"\"\n    Get a tree structure of the classes.\n    The parent is always the superclass.\n\n    You can use `pprint.pprint` to print the\n    dictionary in a pretty way.\n\n    :returns: a tree in dictionary format where the key is the class name and the value is a list of dictionaries containing a child class name as a key and subsequent child classes as a value list\n    \"\"\"\n\n    def print_map(node, l):\n        if node.title not in l:\n            l[node.title] = []\n\n        for n in node.children:\n            if len(n.children) &gt; 0:\n                w = {n.title: []}\n                l[node.title].append(w)\n\n                print_map(n, w)\n            else:\n                l[node.title].append(n.title)\n\n    l = {}\n    print_map(self._get_class_hierarchy(), l)\n\n    return l\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.save","title":"<code>save()</code>","text":"<p>Return the dex (with the modifications) into raw format (fix checksums) (beta: do not use !)</p> <p>Returns:</p> Type Description <code>bytes</code> <p>bytes</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def save(self) -&gt; bytes:\n    \"\"\"\n    Return the dex (with the modifications) into raw format (fix checksums)\n    (beta: do not use !)\n\n    :returns: bytes\n    \"\"\"\n    l = []\n    h = {}\n    s = {}\n    h_r = {}\n\n    idx = 0\n    for i in self.map_list.get_obj():\n        length = 0\n\n        if isinstance(i, list):\n            for j in i:\n                if isinstance(j, AnnotationsDirectoryItem):\n                    if idx % 4 != 0:\n                        idx = idx + (4 - (idx % 4))\n\n                l.append(j)\n\n                c_length = j.get_length()\n                if isinstance(j, StringDataItem):\n                    c_length += 1\n                h[j] = idx + length\n                h_r[idx + length] = j\n                s[idx + length] = c_length\n\n                length += c_length\n                # logger.debug(\"SAVE\" + str(j) + \" @ 0x%x\" % (idx+length))\n\n            logger.debug(\n                \"SAVE \" + str(i[0]) + \" @0x{:x} ({:x})\".format(idx, length)\n            )\n\n        else:\n            if isinstance(i, MapList):\n                if idx % 4 != 0:\n                    idx = idx + (4 - (idx % 4))\n\n            l.append(i)\n            h[i] = idx\n            h_r[idx] = i\n\n            length = i.get_length()\n\n            s[idx] = length\n\n            logger.debug(\n                \"SAVE \" + str(i) + \" @0x{:x} ({:x})\".format(idx, length)\n            )\n\n        idx += length\n\n    self.header.file_size = idx\n\n    for i in l:\n        idx = h[i]\n        i.set_off(idx)\n        if isinstance(i, CodeItem):\n            last_idx = idx\n            for j in i.get_obj():\n                j.set_off(last_idx)\n                # j.set_debug_info_off(0)\n                last_idx += j.get_size()\n\n    last_idx = 0\n    buff = bytearray()\n    for i in l:\n        idx = h[i]\n\n        if idx != last_idx:\n            logger.debug(\n                \"Adjust alignment @{:x} with 00 {:x}\".format(\n                    idx, idx - last_idx\n                )\n            )\n            buff += bytearray([0] * (idx - last_idx))\n\n        buff += i.get_raw()\n        if isinstance(i, StringDataItem):\n            buff += b\"\\x00\"\n        last_idx = idx + s[idx]\n\n    logger.debug(\"GLOBAL SIZE %d\" % len(buff))\n\n    return self.fix_checksums(buff)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DEX.show","title":"<code>show()</code>","text":"<p>Show the all information in the object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"\n    Show the all information in the object\n    \"\"\"\n    self.map_list.show()\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DalvikCode","title":"<code>DalvikCode</code>","text":"<p>This class represents the instructions of a method</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a raw buffer where are the instructions</p> required <code>cm</code> <code>ClassManager</code> <p>the <code>ClassManager</code></p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class DalvikCode:\n    \"\"\"\n    This class represents the instructions of a method\n\n    :param buff: a raw buffer where are the instructions\n    :param cm: the `ClassManager`\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm: ClassManager) -&gt; None:\n        self.CM = cm\n        self.offset = buff.tell()\n\n        (\n            self.registers_size,\n            self.ins_size,\n            self.outs_size,\n            self.tries_size,\n            self.debug_info_off,\n            self.insns_size,\n        ) = cm.packer[\"4H2I\"].unpack(buff.read(16))\n\n        ushort = calcsize('H')\n\n        self.code = DCode(\n            self.CM,\n            buff.tell(),\n            self.insns_size,\n            buff.read(self.insns_size * ushort),\n        )\n\n        if self.insns_size % 2 == 1 and self.tries_size &gt; 0:\n            (self.padding,) = cm.packer[\"H\"].unpack(buff.read(2))\n\n        self.tries = []\n        self.handlers = None\n        if self.tries_size &gt; 0:\n            for i in range(0, self.tries_size):\n                self.tries.append(TryItem(buff, self.CM))\n\n            self.handlers = EncodedCatchHandlerList(buff, self.CM)\n\n    def get_registers_size(self) -&gt; int:\n        \"\"\"\n        Get the number of registers used by this code\n\n        :returns: number of registers\n        \"\"\"\n        return self.registers_size\n\n    def get_ins_size(self) -&gt; int:\n        \"\"\"\n        Get the number of words of incoming arguments to the method that this code is for\n\n        :returns: number of words\n        \"\"\"\n        return self.ins_size\n\n    def get_outs_size(self) -&gt; int:\n        \"\"\"\n        Get the number of words of outgoing argument space required by this code for method invocation\n\n        :returns: number of words\n        \"\"\"\n        return self.outs_size\n\n    def get_tries_size(self) -&gt; int:\n        \"\"\"\n        Get the number of [TryItem][androguard.core.dex.TryItem] for this instance\n\n        :returns: number of `TryItem`\n        \"\"\"\n        return self.tries_size\n\n    def get_debug_info_off(self) -&gt; int:\n        \"\"\"\n        Get the offset from the start of the file to the debug info (line numbers + local variable info) sequence for this code, or 0 if there simply is no information\n\n        :returns: offset int\n        \"\"\"\n        return self.debug_info_off\n\n    def get_insns_size(self) -&gt; int:\n        \"\"\"\n        Get the size of the instructions list, in 16-bit code units\n\n        :returns: size int\n        \"\"\"\n        return self.insns_size\n\n    def get_handlers(self) -&gt; EncodedCatchHandlerList:\n        \"\"\"\n        Get the bytes representing a list of lists of catch types and associated handler addresses.\n\n        :returns: `EncodedCatchHandlerList` object\n        \"\"\"\n        return self.handlers\n\n    def get_tries(self) -&gt; list[TryItem]:\n        \"\"\"\n        Get the array indicating where in the code exceptions are caught and how to handle them\n\n        :returns: a list of `TryItem` objects\n        \"\"\"\n        return self.tries\n\n    def get_debug(self) -&gt; DebugInfoItem:\n        \"\"\"\n        Return the associated debug object\n\n        :returns: `DebugInfoItem` object\n        \"\"\"\n        return self.CM.get_debug_off(self.debug_info_off)\n\n    def get_bc(self) -&gt; DCode:\n        \"\"\"\n        Return the associated code object\n\n        :returns: `DCode` object\n        \"\"\"\n        return self.code\n\n    def seek(self, idx: int) -&gt; None:\n        self.code.seek(idx)\n\n    def get_length(self) -&gt; int:\n        return self.insns_size\n\n    def _begin_show(self) -&gt; None:\n        logger.debug(\"registers_size: %d\" % self.registers_size)\n        logger.debug(\"ins_size: %d\" % self.ins_size)\n        logger.debug(\"outs_size: %d\" % self.outs_size)\n        logger.debug(\"tries_size: %d\" % self.tries_size)\n        logger.debug(\"debug_info_off: %d\" % self.debug_info_off)\n        logger.debug(\"insns_size: %d\" % self.insns_size)\n\n        bytecode._PrintBanner()\n\n    def show(self) -&gt; None:\n        self._begin_show()\n        self.code.show()\n        self._end_show()\n\n    def _end_show(self) -&gt; None:\n        bytecode._PrintBanner()\n\n    def get_obj(self) -&gt; tuple[DCode, list[TryItem], EncodedCatchHandlerList]:\n        return [self.code, self.tries, self.handlers]\n\n    def get_raw(self) -&gt; bytearray:\n        \"\"\"\n        Get the reconstructed code as bytearray\n\n        :returns: code bytearray\n        \"\"\"\n        code_raw = self.code.get_raw()\n        self.insns_size = (len(code_raw) // 2) + (len(code_raw) % 2)\n\n        buff = bytearray()\n        buff += (\n            self.CM.packer[\"4H2I\"].pack(\n                self.registers_size,\n                self.ins_size,\n                self.outs_size,\n                self.tries_size,\n                self.debug_info_off,\n                self.insns_size,\n            )\n            + code_raw\n        )\n\n        if self.tries_size &gt; 0:\n            if self.insns_size % 2 == 1:\n                buff += self.CM.packer[\"H\"].pack(self.padding)\n\n            for i in self.tries:\n                buff += i.get_raw()\n            buff += self.handlers.get_raw()\n\n        return buff\n\n    def add_inote(self, msg: str, idx: int, off: int = None) -&gt; None:\n        \"\"\"\n        Add a message to a specific instruction by using (default) the index of the address if specified\n\n        :param msg: the message\n        :param idx: index of the instruction (the position in the list of the instruction)\n        :param off: address of the instruction\n        \"\"\"\n        if self.code:\n            return self.code.add_inote(msg, idx, off)\n\n    def get_instruction(\n        self, idx: int, off: Union[int, None] = None\n    ) -&gt; Instruction:\n        if self.code:\n            return self.code.get_instruction(idx, off)\n\n    def get_size(self) -&gt; int:\n        return len(self.get_raw())\n\n    def set_off(self, off: int) -&gt; None:\n        self.offset = off\n\n    def get_off(self) -&gt; int:\n        return self.offset\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DalvikCode.add_inote","title":"<code>add_inote(msg, idx, off=None)</code>","text":"<p>Add a message to a specific instruction by using (default) the index of the address if specified</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>the message</p> required <code>idx</code> <code>int</code> <p>index of the instruction (the position in the list of the instruction)</p> required <code>off</code> <code>int</code> <p>address of the instruction</p> <code>None</code> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def add_inote(self, msg: str, idx: int, off: int = None) -&gt; None:\n    \"\"\"\n    Add a message to a specific instruction by using (default) the index of the address if specified\n\n    :param msg: the message\n    :param idx: index of the instruction (the position in the list of the instruction)\n    :param off: address of the instruction\n    \"\"\"\n    if self.code:\n        return self.code.add_inote(msg, idx, off)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DalvikCode.get_bc","title":"<code>get_bc()</code>","text":"<p>Return the associated code object</p> <p>Returns:</p> Type Description <code>DCode</code> <p><code>DCode</code> object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_bc(self) -&gt; DCode:\n    \"\"\"\n    Return the associated code object\n\n    :returns: `DCode` object\n    \"\"\"\n    return self.code\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DalvikCode.get_debug","title":"<code>get_debug()</code>","text":"<p>Return the associated debug object</p> <p>Returns:</p> Type Description <code>DebugInfoItem</code> <p><code>DebugInfoItem</code> object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_debug(self) -&gt; DebugInfoItem:\n    \"\"\"\n    Return the associated debug object\n\n    :returns: `DebugInfoItem` object\n    \"\"\"\n    return self.CM.get_debug_off(self.debug_info_off)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DalvikCode.get_debug_info_off","title":"<code>get_debug_info_off()</code>","text":"<p>Get the offset from the start of the file to the debug info (line numbers + local variable info) sequence for this code, or 0 if there simply is no information</p> <p>Returns:</p> Type Description <code>int</code> <p>offset int</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_debug_info_off(self) -&gt; int:\n    \"\"\"\n    Get the offset from the start of the file to the debug info (line numbers + local variable info) sequence for this code, or 0 if there simply is no information\n\n    :returns: offset int\n    \"\"\"\n    return self.debug_info_off\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DalvikCode.get_handlers","title":"<code>get_handlers()</code>","text":"<p>Get the bytes representing a list of lists of catch types and associated handler addresses.</p> <p>Returns:</p> Type Description <code>EncodedCatchHandlerList</code> <p><code>EncodedCatchHandlerList</code> object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_handlers(self) -&gt; EncodedCatchHandlerList:\n    \"\"\"\n    Get the bytes representing a list of lists of catch types and associated handler addresses.\n\n    :returns: `EncodedCatchHandlerList` object\n    \"\"\"\n    return self.handlers\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DalvikCode.get_ins_size","title":"<code>get_ins_size()</code>","text":"<p>Get the number of words of incoming arguments to the method that this code is for</p> <p>Returns:</p> Type Description <code>int</code> <p>number of words</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_ins_size(self) -&gt; int:\n    \"\"\"\n    Get the number of words of incoming arguments to the method that this code is for\n\n    :returns: number of words\n    \"\"\"\n    return self.ins_size\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DalvikCode.get_insns_size","title":"<code>get_insns_size()</code>","text":"<p>Get the size of the instructions list, in 16-bit code units</p> <p>Returns:</p> Type Description <code>int</code> <p>size int</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_insns_size(self) -&gt; int:\n    \"\"\"\n    Get the size of the instructions list, in 16-bit code units\n\n    :returns: size int\n    \"\"\"\n    return self.insns_size\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DalvikCode.get_outs_size","title":"<code>get_outs_size()</code>","text":"<p>Get the number of words of outgoing argument space required by this code for method invocation</p> <p>Returns:</p> Type Description <code>int</code> <p>number of words</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_outs_size(self) -&gt; int:\n    \"\"\"\n    Get the number of words of outgoing argument space required by this code for method invocation\n\n    :returns: number of words\n    \"\"\"\n    return self.outs_size\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DalvikCode.get_raw","title":"<code>get_raw()</code>","text":"<p>Get the reconstructed code as bytearray</p> <p>Returns:</p> Type Description <code>bytearray</code> <p>code bytearray</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_raw(self) -&gt; bytearray:\n    \"\"\"\n    Get the reconstructed code as bytearray\n\n    :returns: code bytearray\n    \"\"\"\n    code_raw = self.code.get_raw()\n    self.insns_size = (len(code_raw) // 2) + (len(code_raw) % 2)\n\n    buff = bytearray()\n    buff += (\n        self.CM.packer[\"4H2I\"].pack(\n            self.registers_size,\n            self.ins_size,\n            self.outs_size,\n            self.tries_size,\n            self.debug_info_off,\n            self.insns_size,\n        )\n        + code_raw\n    )\n\n    if self.tries_size &gt; 0:\n        if self.insns_size % 2 == 1:\n            buff += self.CM.packer[\"H\"].pack(self.padding)\n\n        for i in self.tries:\n            buff += i.get_raw()\n        buff += self.handlers.get_raw()\n\n    return buff\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DalvikCode.get_registers_size","title":"<code>get_registers_size()</code>","text":"<p>Get the number of registers used by this code</p> <p>Returns:</p> Type Description <code>int</code> <p>number of registers</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_registers_size(self) -&gt; int:\n    \"\"\"\n    Get the number of registers used by this code\n\n    :returns: number of registers\n    \"\"\"\n    return self.registers_size\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DalvikCode.get_tries","title":"<code>get_tries()</code>","text":"<p>Get the array indicating where in the code exceptions are caught and how to handle them</p> <p>Returns:</p> Type Description <code>list[TryItem]</code> <p>a list of <code>TryItem</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_tries(self) -&gt; list[TryItem]:\n    \"\"\"\n    Get the array indicating where in the code exceptions are caught and how to handle them\n\n    :returns: a list of `TryItem` objects\n    \"\"\"\n    return self.tries\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DalvikCode.get_tries_size","title":"<code>get_tries_size()</code>","text":"<p>Get the number of TryItem for this instance</p> <p>Returns:</p> Type Description <code>int</code> <p>number of <code>TryItem</code></p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_tries_size(self) -&gt; int:\n    \"\"\"\n    Get the number of [TryItem][androguard.core.dex.TryItem] for this instance\n\n    :returns: number of `TryItem`\n    \"\"\"\n    return self.tries_size\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.DalvikPacker","title":"<code>DalvikPacker</code>","text":"<p>Generic Packer class to unpack bytes based on different endianness</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class DalvikPacker:\n    \"\"\"\n    Generic Packer class to unpack bytes based on different endianness\n    \"\"\"\n\n    def __init__(self, endian_tag: int) -&gt; None:\n        if endian_tag == 0x78563412:\n            logger.error(\n                \"DEX file with byte swapped endian tag is not supported!\"\n            )\n            raise NotImplementedError(\"Byte swapped endian tag encountered!\")\n        elif endian_tag == 0x12345678:\n            self.endian_tag = '&lt;'\n        else:\n            raise ValueError(\n                \"This is not a DEX file! Wrong endian tag: '0x{:08x}'\".format(\n                    endian_tag\n                )\n            )\n        self.__structs = {}\n\n    def __getitem__(self, item):\n        try:\n            return self.__structs[item]\n        except KeyError:\n            self.__structs[item] = struct.Struct(self.endian_tag + item)\n        return self.__structs[item]\n\n    def __getstate__(self):\n        return self.endian_tag\n\n    def __setstate__(self, state):\n        self.endian_tag = state\n        self.__structs = {}\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedAnnotation","title":"<code>EncodedAnnotation</code>","text":"<p>This class can parse an <code>encoded_annotation</code> of a dex file</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class EncodedAnnotation:\n    \"\"\"\n    This class can parse an `encoded_annotation` of a dex file\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm:ClassManager) -&gt; None:\n        \"\"\"\n        :param buff: a string which represents a Buff object of the `encoded_annotation`\n        :param cm: a `ClassManager` object\n        \"\"\"\n        self.CM = cm\n        self.offset = buff.tell()\n\n        self.type_idx = readuleb128(cm, buff)\n        self.size = readuleb128(cm, buff)\n\n        self.elements = [AnnotationElement(buff, cm) for _ in range(self.size)]\n\n    def get_type_idx(self):\n        \"\"\"\n        Return the type of the annotation. This must be a class (not array or primitive) type\n\n        :returns: the type of the annotation\n        \"\"\"\n        return self.type_idx\n\n    def get_size(self):\n        \"\"\"\n        Return the number of name-value mappings in this annotation\n\n        :returns: the number of mappings\n        \"\"\"\n        return self.size\n\n    def get_elements(self):\n        \"\"\"\n        Return the elements of the annotation, represented directly in-line (not as offsets)\n\n        :returns: a list of `AnnotationElement` objects\n        \"\"\"\n        return self.elements\n\n    def show(self):\n        bytecode._PrintSubBanner(\"Encoded Annotation\")\n        bytecode._PrintDefault(\n            \"type_idx=%d size=%d\\n\" % (self.type_idx, self.size)\n        )\n\n        for i in self.elements:\n            i.show()\n\n    def get_obj(self):\n        return [i for i in self.elements]\n\n    def get_raw(self):\n        return (\n            writeuleb128(self.CM, self.type_idx)\n            + writeuleb128(self.CM, self.size)\n            + b''.join(i.get_raw() for i in self.elements)\n        )\n\n    def get_length(self):\n        length = len(\n            writeuleb128(self.CM, self.type_idx)\n            + writeuleb128(self.CM, self.size)\n        )\n\n        for i in self.elements:\n            length += i.get_length()\n\n        return length\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedAnnotation.__init__","title":"<code>__init__(buff, cm)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a Buff object of the <code>encoded_annotation</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def __init__(self, buff: BinaryIO, cm:ClassManager) -&gt; None:\n    \"\"\"\n    :param buff: a string which represents a Buff object of the `encoded_annotation`\n    :param cm: a `ClassManager` object\n    \"\"\"\n    self.CM = cm\n    self.offset = buff.tell()\n\n    self.type_idx = readuleb128(cm, buff)\n    self.size = readuleb128(cm, buff)\n\n    self.elements = [AnnotationElement(buff, cm) for _ in range(self.size)]\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedAnnotation.get_elements","title":"<code>get_elements()</code>","text":"<p>Return the elements of the annotation, represented directly in-line (not as offsets)</p> <p>Returns:</p> Type Description <p>a list of <code>AnnotationElement</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_elements(self):\n    \"\"\"\n    Return the elements of the annotation, represented directly in-line (not as offsets)\n\n    :returns: a list of `AnnotationElement` objects\n    \"\"\"\n    return self.elements\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedAnnotation.get_size","title":"<code>get_size()</code>","text":"<p>Return the number of name-value mappings in this annotation</p> <p>Returns:</p> Type Description <p>the number of mappings</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_size(self):\n    \"\"\"\n    Return the number of name-value mappings in this annotation\n\n    :returns: the number of mappings\n    \"\"\"\n    return self.size\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedAnnotation.get_type_idx","title":"<code>get_type_idx()</code>","text":"<p>Return the type of the annotation. This must be a class (not array or primitive) type</p> <p>Returns:</p> Type Description <p>the type of the annotation</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_type_idx(self):\n    \"\"\"\n    Return the type of the annotation. This must be a class (not array or primitive) type\n\n    :returns: the type of the annotation\n    \"\"\"\n    return self.type_idx\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedArray","title":"<code>EncodedArray</code>","text":"<p>This class can parse an <code>encoded_array</code> of a dex file</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class EncodedArray:\n    \"\"\"\n    This class can parse an `encoded_array` of a dex file\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm:ClassManager) -&gt; None:\n        \"\"\"\n        :param buff: a string which represents a buff object of the `encoded_array`\n        :param cm: a ClassManager object\n        \"\"\"\n        self.CM = cm\n        self.offset = buff.tell()\n\n        self.size = readuleb128(cm, buff)\n\n        self.values = [EncodedValue(buff, cm) for _ in range(self.size)]\n\n    def get_size(self):\n        \"\"\"\n        Return the number of elements in the array\n\n        :returns: int\n        \"\"\"\n        return self.size\n\n    def get_values(self) -&gt; list[EncodedValue]:\n        \"\"\"\n        Return a series of size `encoded_value` byte sequences in the format specified by this section,\n        concatenated sequentially\n\n        :returns: a list of `EncodedValue` objects\n        \"\"\"\n        return self.values\n\n    def show(self):\n        bytecode._PrintSubBanner(\"Encoded Array\")\n        bytecode._PrintDefault(\"size=%d\\n\" % self.size)\n\n        for i in self.values:\n            i.show()\n\n    def get_obj(self):\n        return writeuleb128(self.CM, self.size)\n\n    def get_raw(self) -&gt; bytes:\n        return self.get_obj() + b''.join(i.get_raw() for i in self.values)\n\n    def get_length(self):\n        length = len(self.get_obj())\n        for i in self.values:\n            length += i.get_length()\n\n        return length\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedArray.__init__","title":"<code>__init__(buff, cm)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a buff object of the <code>encoded_array</code></p> required <code>cm</code> <code>ClassManager</code> <p>a ClassManager object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def __init__(self, buff: BinaryIO, cm:ClassManager) -&gt; None:\n    \"\"\"\n    :param buff: a string which represents a buff object of the `encoded_array`\n    :param cm: a ClassManager object\n    \"\"\"\n    self.CM = cm\n    self.offset = buff.tell()\n\n    self.size = readuleb128(cm, buff)\n\n    self.values = [EncodedValue(buff, cm) for _ in range(self.size)]\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedArray.get_size","title":"<code>get_size()</code>","text":"<p>Return the number of elements in the array</p> <p>Returns:</p> Type Description <p>int</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_size(self):\n    \"\"\"\n    Return the number of elements in the array\n\n    :returns: int\n    \"\"\"\n    return self.size\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedArray.get_values","title":"<code>get_values()</code>","text":"<p>Return a series of size <code>encoded_value</code> byte sequences in the format specified by this section, concatenated sequentially</p> <p>Returns:</p> Type Description <code>list[EncodedValue]</code> <p>a list of <code>EncodedValue</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_values(self) -&gt; list[EncodedValue]:\n    \"\"\"\n    Return a series of size `encoded_value` byte sequences in the format specified by this section,\n    concatenated sequentially\n\n    :returns: a list of `EncodedValue` objects\n    \"\"\"\n    return self.values\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedArrayItem","title":"<code>EncodedArrayItem</code>","text":"<p>This class can parse an <code>encoded_array_item</code> of a dex file</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class EncodedArrayItem:\n    \"\"\"\n    This class can parse an `encoded_array_item` of a dex file\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm: ClassManager) -&gt; None:\n        \"\"\"\n        :param buff: a string which represents a Buff object of the `encoded_array_item`\n        :param cm: a `ClassManager` object\n        \"\"\"\n        self.CM = cm\n\n        self.offset = buff.tell()\n        self.value = EncodedArray(buff, cm)\n\n    def get_value(self) -&gt; EncodedArray:\n        \"\"\"\n        Return the bytes representing the encoded array value\n\n        :returns: a `EncodedArray` object\n        \"\"\"\n        return self.value\n\n    def set_off(self, off: int) -&gt; None:\n        self.offset = off\n\n    def show(self) -&gt; None:\n        bytecode._PrintSubBanner(\"Encoded Array Item\")\n        self.value.show()\n\n    def get_obj(self) -&gt; list[EncodedArray]:\n        return [self.value]\n\n    def get_raw(self) -&gt; bytes:\n        return self.value.get_raw()\n\n    def get_length(self) -&gt; int:\n        return self.value.get_length()\n\n    def get_off(self) -&gt; int:\n        return self.offset\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedArrayItem.__init__","title":"<code>__init__(buff, cm)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a Buff object of the <code>encoded_array_item</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def __init__(self, buff: BinaryIO, cm: ClassManager) -&gt; None:\n    \"\"\"\n    :param buff: a string which represents a Buff object of the `encoded_array_item`\n    :param cm: a `ClassManager` object\n    \"\"\"\n    self.CM = cm\n\n    self.offset = buff.tell()\n    self.value = EncodedArray(buff, cm)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedArrayItem.get_value","title":"<code>get_value()</code>","text":"<p>Return the bytes representing the encoded array value</p> <p>Returns:</p> Type Description <code>EncodedArray</code> <p>a <code>EncodedArray</code> object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_value(self) -&gt; EncodedArray:\n    \"\"\"\n    Return the bytes representing the encoded array value\n\n    :returns: a `EncodedArray` object\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedCatchHandler","title":"<code>EncodedCatchHandler</code>","text":"<p>This class can parse an <code>encoded_catch_handler</code> of a dex file</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a Buff object of the <code>encoded_catch_handler</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class EncodedCatchHandler:\n    \"\"\"\n    This class can parse an `encoded_catch_handler` of a dex file\n\n    :param buff: a string which represents a Buff object of the `encoded_catch_handler`\n    :param cm: a `ClassManager` object\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm: ClassManager) -&gt; None:\n        self.CM = cm\n        self.offset = buff.tell()\n\n        self.size = readsleb128(cm, buff)\n\n        self.handlers = []\n\n        for i in range(0, abs(self.size)):\n            self.handlers.append(EncodedTypeAddrPair(cm, buff))\n\n        if self.size &lt;= 0:\n            self.catch_all_addr = readuleb128(cm, buff)\n\n    def get_size(self) -&gt; int:\n        \"\"\"\n        Return the number of catch types in this list\n\n        :returns: the number of catch types\n        \"\"\"\n        return self.size\n\n    def get_handlers(self) -&gt; list[EncodedTypeAddrPair]:\n        \"\"\"\n        Return the stream of `abs(size)` encoded items, one for each caught type, in the order that the types should be tested.\n\n        :returns: a list of `EncodedTypeAddrPair` objects\n        \"\"\"\n        return self.handlers\n\n    def get_catch_all_addr(self) -&gt; int:\n        \"\"\"\n        Return the bytecode address of the catch-all handler. This element is only present if size is non-positive.\n\n        :returns: the bytecode address\n        \"\"\"\n        return self.catch_all_addr\n\n    def get_off(self) -&gt; int:\n        return self.offset\n\n    def set_off(self, off: int) -&gt; None:\n        self.offset = off\n\n    def show(self) -&gt; None:\n        bytecode._PrintSubBanner(\"Encoded Catch Handler\")\n        bytecode._PrintDefault(\"size=%d\\n\" % self.size)\n\n        for i in self.handlers:\n            i.show()\n\n        if self.size &lt;= 0:\n            bytecode._PrintDefault(\"catch_all_addr=%x\\n\" % self.catch_all_addr)\n\n    def get_raw(self) -&gt; bytearray:\n        buff = bytearray()\n        buff += writesleb128(self.CM, self.size)\n        for i in self.handlers:\n            buff += i.get_raw()\n\n        if self.size &lt;= 0:\n            buff += writeuleb128(self.CM, self.catch_all_addr)\n\n        return buff\n\n    def get_length(self) -&gt; int:\n        length = len(writesleb128(self.CM, self.size))\n\n        for i in self.handlers:\n            length += i.get_length()\n\n        if self.size &lt;= 0:\n            length += len(writeuleb128(self.CM, self.catch_all_addr))\n\n        return length\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedCatchHandler.get_catch_all_addr","title":"<code>get_catch_all_addr()</code>","text":"<p>Return the bytecode address of the catch-all handler. This element is only present if size is non-positive.</p> <p>Returns:</p> Type Description <code>int</code> <p>the bytecode address</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_catch_all_addr(self) -&gt; int:\n    \"\"\"\n    Return the bytecode address of the catch-all handler. This element is only present if size is non-positive.\n\n    :returns: the bytecode address\n    \"\"\"\n    return self.catch_all_addr\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedCatchHandler.get_handlers","title":"<code>get_handlers()</code>","text":"<p>Return the stream of <code>abs(size)</code> encoded items, one for each caught type, in the order that the types should be tested.</p> <p>Returns:</p> Type Description <code>list[EncodedTypeAddrPair]</code> <p>a list of <code>EncodedTypeAddrPair</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_handlers(self) -&gt; list[EncodedTypeAddrPair]:\n    \"\"\"\n    Return the stream of `abs(size)` encoded items, one for each caught type, in the order that the types should be tested.\n\n    :returns: a list of `EncodedTypeAddrPair` objects\n    \"\"\"\n    return self.handlers\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedCatchHandler.get_size","title":"<code>get_size()</code>","text":"<p>Return the number of catch types in this list</p> <p>Returns:</p> Type Description <code>int</code> <p>the number of catch types</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_size(self) -&gt; int:\n    \"\"\"\n    Return the number of catch types in this list\n\n    :returns: the number of catch types\n    \"\"\"\n    return self.size\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedCatchHandlerList","title":"<code>EncodedCatchHandlerList</code>","text":"<p>This class can parse an <code>encoded_catch_handler_list</code> of a dex file</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a Buff object of the <code>encoded_catch_handler_list</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class EncodedCatchHandlerList:\n    \"\"\"\n    This class can parse an `encoded_catch_handler_list` of a dex file\n\n    :param buff: a string which represents a Buff object of the `encoded_catch_handler_list`\n    :param cm: a `ClassManager` object\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm: ClassManager) -&gt; None:\n        self.CM = cm\n        self.offset = buff.tell()\n\n        self.size = readuleb128(cm, buff)\n        self.list = [EncodedCatchHandler(buff, cm) for _ in range(self.size)]\n\n    def get_size(self) -&gt; int:\n        \"\"\"\n        Return the size of this list, in entries\n\n        :returns: int\n        \"\"\"\n        return self.size\n\n    def get_list(self) -&gt; list[EncodedCatchHandler]:\n        \"\"\"\n        Return the actual list of handler lists, represented directly (not as offsets), and concatenated sequentially\n\n        :returns: a list of `EncodedCatchHandler` objects\n        \"\"\"\n        return self.list\n\n    def show(self) -&gt; None:\n        bytecode._PrintSubBanner(\"Encoded Catch Handler List\")\n        bytecode._PrintDefault(\"size=%d\\n\" % self.size)\n\n        for i in self.list:\n            i.show()\n\n    def get_off(self) -&gt; int:\n        return self.offset\n\n    def set_off(self, off: int) -&gt; None:\n        self.offset = off\n\n    def get_obj(self) -&gt; bytearray:\n        return writeuleb128(self.CM, self.size)\n\n    def get_raw(self) -&gt; bytearray:\n        buff = bytearray()\n        buff += self.get_obj()\n        for i in self.list:\n            buff += i.get_raw()\n        return buff\n\n    def get_length(self) -&gt; int:\n        length = len(self.get_obj())\n\n        for i in self.list:\n            length += i.get_length()\n        return length\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedCatchHandlerList.get_list","title":"<code>get_list()</code>","text":"<p>Return the actual list of handler lists, represented directly (not as offsets), and concatenated sequentially</p> <p>Returns:</p> Type Description <code>list[EncodedCatchHandler]</code> <p>a list of <code>EncodedCatchHandler</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_list(self) -&gt; list[EncodedCatchHandler]:\n    \"\"\"\n    Return the actual list of handler lists, represented directly (not as offsets), and concatenated sequentially\n\n    :returns: a list of `EncodedCatchHandler` objects\n    \"\"\"\n    return self.list\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedCatchHandlerList.get_size","title":"<code>get_size()</code>","text":"<p>Return the size of this list, in entries</p> <p>Returns:</p> Type Description <code>int</code> <p>int</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_size(self) -&gt; int:\n    \"\"\"\n    Return the size of this list, in entries\n\n    :returns: int\n    \"\"\"\n    return self.size\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedField","title":"<code>EncodedField</code>","text":"<p>This class can parse an <code>encoded_field</code> of a dex file</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class EncodedField:\n    \"\"\"\n    This class can parse an `encoded_field` of a dex file\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm:ClassManager) -&gt; None:\n        \"\"\"\n        :param buff: a string which represents a buff object of the `encoded_field`\n        :param cm: a `ClassManager` object\n        \"\"\"\n        self.CM = cm\n        self.offset = buff.tell()\n\n        self.field_idx_diff = readuleb128(cm, buff)\n        self.access_flags = readuleb128(cm, buff)\n\n        self.field_idx = 0\n\n        self.name = None\n        self.proto = None\n        self.class_name = None\n\n        self.init_value = None\n        self.access_flags_string = None\n        self.loaded = False\n\n    def load(self) -&gt; None:\n        if self.loaded:\n            return\n        self.reload()\n        self.loaded = True\n\n    def reload(self) -&gt; None:\n        name = self.CM.get_field(self.field_idx)\n        self.class_name = name[0]\n        self.name = name[2]\n        self.proto = name[1]\n\n    def set_init_value(self, value: EncodedValue) -&gt; None:\n        \"\"\"\n        Setup the init value object of the field\n\n        :param value: the init value\n        \"\"\"\n        self.init_value = value\n\n    def get_init_value(self) -&gt; EncodedValue:\n        \"\"\"\n        Return the init value object of the field\n\n        :returns: an `EncodedValue` object\n        \"\"\"\n        return self.init_value\n\n    def adjust_idx(self, val: int) -&gt; None:\n        self.field_idx = self.field_idx_diff + val\n\n    def get_field_idx_diff(self) -&gt; int:\n        \"\"\"\n        Return the index into the field_ids list for the identity of this field (includes the name and descriptor),\n        represented as a difference from the index of previous element in the list\n\n        :returns: the index\n        \"\"\"\n        return self.field_idx_diff\n\n    def get_field_idx(self) -&gt; int:\n        \"\"\"\n        Return the real index of the method\n\n        :returns: the real index\n        \"\"\"\n        return self.field_idx\n\n    def get_access_flags(self) -&gt; int:\n        \"\"\"\n        Return the access flags of the field\n\n        :returns: the access flags\n        \"\"\"\n        return self.access_flags\n\n    def get_class_name(self) -&gt; str:\n        \"\"\"\n        Return the class name of the field\n\n        :returns: the class name\n        \"\"\"\n        if not self.loaded:\n            self.load()\n        return self.class_name\n\n    def get_descriptor(self) -&gt; str:\n        \"\"\"\n        Return the descriptor of the field\n\n        The descriptor of a field is the type of the field.\n\n        :returns: the descriptor\n        \"\"\"\n        if not self.loaded:\n            self.load()\n        return self.proto\n\n    def get_name(self) -&gt; str:\n        \"\"\"\n        Return the name of the field\n\n        :returns: the name\n        \"\"\"\n        if not self.loaded:\n            self.load()\n        return self.name\n\n    def get_access_flags_string(self) -&gt; str:\n        \"\"\"\n        Return the access flags string of the field\n\n        :returns: the access flags\n        \"\"\"\n        if self.access_flags_string is None:\n            if self.get_access_flags() == 0:\n                # No access flags, i.e. Java defaults apply\n                self.access_flags_string = \"\"\n                return self.access_flags_string\n\n            # Try to parse the string\n            self.access_flags_string = get_access_flags_string(\n                self.get_access_flags()\n            )\n\n            # Fallback for unknown strings\n            if self.access_flags_string == \"\":\n                self.access_flags_string = \"0x{:06x}\".format(\n                    self.get_access_flags()\n                )\n        return self.access_flags_string\n\n    def set_name(self, value: str) -&gt; None:\n        self.CM.set_hook_field_name(self, value)\n        self.reload()\n\n    def get_obj(self) -&gt; list:\n        return []\n\n    def get_raw(self) -&gt; bytes:\n        return writeuleb128(self.CM, self.field_idx_diff) + writeuleb128(\n            self.CM, self.access_flags\n        )\n\n    def get_size(self) -&gt; bytes:\n        return len(self.get_raw())\n\n    def show(self) -&gt; None:\n        \"\"\"\n        Display the information (with a pretty print) about the field\n        \"\"\"\n        bytecode._PrintSubBanner(\"Field Information\")\n        bytecode._PrintDefault(\n            \"{}-&gt;{} {} [access_flags={}]\\n\".format(\n                self.get_class_name(),\n                self.get_name(),\n                self.get_descriptor(),\n                self.get_access_flags_string(),\n            )\n        )\n\n        init_value = self.get_init_value()\n        if init_value is not None:\n            bytecode._PrintDefault(\n                \"\\tinit value: %s\\n\" % str(init_value.get_value())\n            )\n\n    def __str__(self):\n        return \"{}-&gt;{} {} [access_flags={}]\\n\".format(\n            self.get_class_name(),\n            self.get_name(),\n            self.get_descriptor(),\n            self.get_access_flags_string(),\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedField.__init__","title":"<code>__init__(buff, cm)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a buff object of the <code>encoded_field</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def __init__(self, buff: BinaryIO, cm:ClassManager) -&gt; None:\n    \"\"\"\n    :param buff: a string which represents a buff object of the `encoded_field`\n    :param cm: a `ClassManager` object\n    \"\"\"\n    self.CM = cm\n    self.offset = buff.tell()\n\n    self.field_idx_diff = readuleb128(cm, buff)\n    self.access_flags = readuleb128(cm, buff)\n\n    self.field_idx = 0\n\n    self.name = None\n    self.proto = None\n    self.class_name = None\n\n    self.init_value = None\n    self.access_flags_string = None\n    self.loaded = False\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedField.get_access_flags","title":"<code>get_access_flags()</code>","text":"<p>Return the access flags of the field</p> <p>Returns:</p> Type Description <code>int</code> <p>the access flags</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_access_flags(self) -&gt; int:\n    \"\"\"\n    Return the access flags of the field\n\n    :returns: the access flags\n    \"\"\"\n    return self.access_flags\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedField.get_access_flags_string","title":"<code>get_access_flags_string()</code>","text":"<p>Return the access flags string of the field</p> <p>Returns:</p> Type Description <code>str</code> <p>the access flags</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_access_flags_string(self) -&gt; str:\n    \"\"\"\n    Return the access flags string of the field\n\n    :returns: the access flags\n    \"\"\"\n    if self.access_flags_string is None:\n        if self.get_access_flags() == 0:\n            # No access flags, i.e. Java defaults apply\n            self.access_flags_string = \"\"\n            return self.access_flags_string\n\n        # Try to parse the string\n        self.access_flags_string = get_access_flags_string(\n            self.get_access_flags()\n        )\n\n        # Fallback for unknown strings\n        if self.access_flags_string == \"\":\n            self.access_flags_string = \"0x{:06x}\".format(\n                self.get_access_flags()\n            )\n    return self.access_flags_string\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedField.get_class_name","title":"<code>get_class_name()</code>","text":"<p>Return the class name of the field</p> <p>Returns:</p> Type Description <code>str</code> <p>the class name</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_class_name(self) -&gt; str:\n    \"\"\"\n    Return the class name of the field\n\n    :returns: the class name\n    \"\"\"\n    if not self.loaded:\n        self.load()\n    return self.class_name\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedField.get_descriptor","title":"<code>get_descriptor()</code>","text":"<p>Return the descriptor of the field</p> <p>The descriptor of a field is the type of the field.</p> <p>Returns:</p> Type Description <code>str</code> <p>the descriptor</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_descriptor(self) -&gt; str:\n    \"\"\"\n    Return the descriptor of the field\n\n    The descriptor of a field is the type of the field.\n\n    :returns: the descriptor\n    \"\"\"\n    if not self.loaded:\n        self.load()\n    return self.proto\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedField.get_field_idx","title":"<code>get_field_idx()</code>","text":"<p>Return the real index of the method</p> <p>Returns:</p> Type Description <code>int</code> <p>the real index</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_field_idx(self) -&gt; int:\n    \"\"\"\n    Return the real index of the method\n\n    :returns: the real index\n    \"\"\"\n    return self.field_idx\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedField.get_field_idx_diff","title":"<code>get_field_idx_diff()</code>","text":"<p>Return the index into the field_ids list for the identity of this field (includes the name and descriptor), represented as a difference from the index of previous element in the list</p> <p>Returns:</p> Type Description <code>int</code> <p>the index</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_field_idx_diff(self) -&gt; int:\n    \"\"\"\n    Return the index into the field_ids list for the identity of this field (includes the name and descriptor),\n    represented as a difference from the index of previous element in the list\n\n    :returns: the index\n    \"\"\"\n    return self.field_idx_diff\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedField.get_init_value","title":"<code>get_init_value()</code>","text":"<p>Return the init value object of the field</p> <p>Returns:</p> Type Description <code>EncodedValue</code> <p>an <code>EncodedValue</code> object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_init_value(self) -&gt; EncodedValue:\n    \"\"\"\n    Return the init value object of the field\n\n    :returns: an `EncodedValue` object\n    \"\"\"\n    return self.init_value\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedField.get_name","title":"<code>get_name()</code>","text":"<p>Return the name of the field</p> <p>Returns:</p> Type Description <code>str</code> <p>the name</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_name(self) -&gt; str:\n    \"\"\"\n    Return the name of the field\n\n    :returns: the name\n    \"\"\"\n    if not self.loaded:\n        self.load()\n    return self.name\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedField.set_init_value","title":"<code>set_init_value(value)</code>","text":"<p>Setup the init value object of the field</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>EncodedValue</code> <p>the init value</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def set_init_value(self, value: EncodedValue) -&gt; None:\n    \"\"\"\n    Setup the init value object of the field\n\n    :param value: the init value\n    \"\"\"\n    self.init_value = value\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedField.show","title":"<code>show()</code>","text":"<p>Display the information (with a pretty print) about the field</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"\n    Display the information (with a pretty print) about the field\n    \"\"\"\n    bytecode._PrintSubBanner(\"Field Information\")\n    bytecode._PrintDefault(\n        \"{}-&gt;{} {} [access_flags={}]\\n\".format(\n            self.get_class_name(),\n            self.get_name(),\n            self.get_descriptor(),\n            self.get_access_flags_string(),\n        )\n    )\n\n    init_value = self.get_init_value()\n    if init_value is not None:\n        bytecode._PrintDefault(\n            \"\\tinit value: %s\\n\" % str(init_value.get_value())\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod","title":"<code>EncodedMethod</code>","text":"<p>This class can parse an <code>encoded_method</code> of a dex file</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class EncodedMethod:\n    \"\"\"\n    This class can parse an `encoded_method` of a dex file\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm:ClassManager) -&gt; None:\n        \"\"\"\n        :param buff: a string which represents a buff object of the `encoded_method`\n        :param cm: a `ClassManager` object\n        \"\"\"\n        self.CM = cm\n        self.offset = buff.tell()\n\n        self.method_idx_diff = readuleb128(\n            cm, buff\n        )  #: method index diff in the corresponding section\n        self.access_flags = readuleb128(\n            cm, buff\n        )  #: access flags of the method\n        self.code_off = readuleb128(cm, buff)  #: offset of the code section\n\n        self.method_idx = 0\n\n        self.name = None\n        self.proto = None\n        self.class_name = None\n\n        self.code = None\n\n        self.access_flags_string = None\n\n        self.notes = []\n        self.loaded = False\n\n    def adjust_idx(self, val: int) -&gt; None:\n        self.method_idx = self.method_idx_diff + val\n\n    def get_method_idx(self) -&gt; int:\n        \"\"\"\n        Return the real index of the method\n\n        :returns: the real index\n        \"\"\"\n        return self.method_idx\n\n    def get_method_idx_diff(self) -&gt; int:\n        \"\"\"\n        Return index into the `method_ids` list for the identity of this method (includes the name and descriptor),\n        represented as a difference from the index of previous element in the lis\n\n        :returns: the index\n        \"\"\"\n        return self.method_idx_diff\n\n    def get_access_flags(self) -&gt; int:\n        \"\"\"\n        Return the access flags of the method\n\n        :returns: the access flags\n        \"\"\"\n        return self.access_flags\n\n    def get_code_off(self) -&gt; int:\n        \"\"\"\n        Return the offset from the start of the file to the code structure for this method,\n        or 0 if this method is either abstract or native\n\n        :returns: the offset\n        \"\"\"\n        return self.code_off\n\n    def get_address(self) -&gt; int:\n        \"\"\"\n        Return the offset from the start of the file to the code structure for this method,\n        or 0 if this method is either abstract or native\n\n        :returns: the offset\n        \"\"\"\n        return self.code_off + 0x10\n\n    def get_access_flags_string(self) -&gt; str:\n        \"\"\"\n        Return the access flags string of the method\n\n        A description of all access flags can be found here:\n        https://source.android.com/devices/tech/dalvik/dex-format#access-flags\n\n        :returns: the access flags\n        \"\"\"\n        if self.access_flags_string is None:\n            self.access_flags_string = get_access_flags_string(\n                self.get_access_flags()\n            )\n\n            if (\n                self.access_flags_string == \"\"\n                and self.get_access_flags() != 0x0\n            ):\n                self.access_flags_string = \"0x%x\" % self.get_access_flags()\n        return self.access_flags_string\n\n    def load(self) -&gt; None:\n        if self.loaded:\n            return\n        self.reload()\n        self.loaded = True\n\n    def reload(self) -&gt; None:\n        v = self.CM.get_method(self.method_idx)\n        # TODO this can probably be more elegant:\n        # get_method returns an array with the already resolved types.\n        # But for example to count the number of parameters, we need to split the string now.\n        # This is quite tedious and could be avoided if we would return the type IDs\n        # instead and resolve them here.\n        if v and len(v) &gt;= 3:\n            self.class_name = v[0]\n            self.name = v[1]\n            self.proto = ''.join(i for i in v[2])\n        else:\n            self.class_name = 'CLASS_NAME_ERROR'\n            self.name = 'NAME_ERROR'\n            self.proto = 'PROTO_ERROR'\n\n        self.code = self.CM.get_code(self.code_off)\n\n    def get_locals(self) -&gt; int:\n        \"\"\"\n        Get the number of local registers used by the method\n\n        This number is equal to the number of registers minus the number of parameters minus 1.\n\n        :returns: number of local registers\n        \"\"\"\n        ret = self.proto.split(')')\n        params = ret[0][1:].split()\n\n        return self.code.get_registers_size() - len(params) - 1\n\n    def get_information(self) -&gt; dict[str, Union[str, tuple[int, int], list]]:\n        \"\"\"\n        Get brief information about the method's register use,\n        parameters and return type.\n\n        The resulting dictionary has the form:\n\n            &gt;&gt;&gt; {\n            &gt;&gt;&gt;    registers: (start, end),\n            &gt;&gt;&gt;    params: [(reg_1, type_1), (reg_2, type_2), ..., (reg_n, type_n)],\n            &gt;&gt;&gt;    return: type\n            &gt;&gt;&gt; }\n\n        The end register is not the last register used, but the last register\n        used not for parameters. Hence, they represent the local registers.\n        The start register is always zero.\n        The register numbers for the parameters can be found in the tuples\n        for each parameter.\n\n        :returns: a dictionary with the basic information about the method\n        \"\"\"\n        info = dict()\n        if self.code:\n            nb = self.code.get_registers_size()\n            proto = self.get_descriptor()\n\n            ret = proto.split(')')\n            params = ret[0][1:].split()\n\n            info[\"return\"] = get_type(ret[1])\n\n            if params:\n                info[\"registers\"] = (0, nb - len(params) - 1)\n                j = 0\n                info[\"params\"] = []\n                for i in range(nb - len(params), nb):\n                    info[\"params\"].append((i, get_type(params[j])))\n                    j += 1\n            else:\n                info[\"registers\"] = (0, nb - 1)\n\n        return info\n\n    def each_params_by_register(self, nb: int, proto: str) -&gt; None:\n        \"\"\"\n        From the Dalvik Bytecode documentation:\n\n        &gt; The N arguments to a method land in the last N registers\n        &gt; of the method's invocation frame, in order.\n        &gt; Wide arguments consume two registers.\n        &gt; Instance methods are passed a this reference as their first argument.\n\n        This method will print a description of the register usage to stdout.\n\n        :param nb: number of registers\n        :param proto: descriptor of method\n        \"\"\"\n        bytecode._PrintSubBanner(\"Params\")\n\n        ret = proto.split(')')\n        params = ret[0][1:].split()\n        if params:\n            bytecode._PrintDefault(\n                \"- local registers: v%d...v%d\\n\" % (0, nb - len(params) - 1)\n            )\n            j = 0\n            for i in range(nb - len(params), nb):\n                bytecode._PrintDefault(\n                    \"- v%d: %s\\n\" % (i, get_type(params[j]))\n                )\n                j += 1\n        else:\n            bytecode._PrintDefault(\n                \"local registers: v%d...v%d\\n\" % (0, nb - 1)\n            )\n\n        bytecode._PrintDefault(\"- return: %s\\n\" % get_type(ret[1]))\n        bytecode._PrintSubBanner()\n\n    def __str__(self):\n        return \"{}-&gt;{}{} [access_flags={}] @ 0x{:x}\".format(\n            self.get_class_name(),\n            self.get_name(),\n            self.get_descriptor(),\n            self.get_access_flags_string(),\n            self.get_code_off(),\n        )\n\n    @property\n    def full_name(self) -&gt; str:\n        \"\"\"Return class_name + name + descriptor, separated by spaces (no access flags)\"\"\"\n        return ' '.join([self.class_name, self.name, self.get_descriptor()])\n\n    @property\n    def descriptor(self) -&gt; str:\n        \"\"\"Get the descriptor of the method\"\"\"\n        return self.get_descriptor()\n\n    def get_short_string(self) -&gt; str:\n        \"\"\"\n        Return a shorter formatted String which encodes this method.\n        The returned name has the form:\n        &lt;classname&gt; &lt;methodname&gt; ([arguments ...])&lt;returntype&gt;\n\n        * All Class names are condensed to the actual name (no package).\n        * Access flags are not returned.\n        * &lt;init&gt; and &lt;clinit&gt; are NOT replaced by the classname!\n\n        This name might not be unique!\n\n        :returns: str\n        \"\"\"\n\n        def _fmt_classname(cls) -&gt; str:\n            arr = \"\"\n            # Test for arrays\n            while cls.startswith(\"[\"):\n                arr += \"[\"\n                cls = cls[1:]\n\n            # is a object type\n            if cls.startswith(\"L\"):\n                cls = cls[1:-1]\n            # only return last element\n            if \"/\" in cls:\n                cls = cls.rsplit(\"/\", 1)[1]\n            return arr + cls\n\n        clsname = _fmt_classname(str(self.get_class_name()))\n\n        param, ret = str(self.get_descriptor())[1:].split(\")\")\n        params = map(_fmt_classname, param.split(\" \"))\n        desc = \"({}){}\".format(''.join(params), _fmt_classname(ret))\n        return \"{cls} {meth} {desc}\".format(\n            cls=clsname, meth=self.get_name(), desc=desc\n        )\n\n    def show_info(self) -&gt; None:\n        \"\"\"\n        Display the basic information about the method\n        \"\"\"\n        bytecode._PrintSubBanner(\"Method Information\")\n        bytecode._PrintDefault(\n            \"{}-&gt;{}{} [access_flags={}]\\n\".format(\n                self.get_class_name(),\n                self.get_name(),\n                self.get_descriptor(),\n                self.get_access_flags_string(),\n            )\n        )\n\n    def show(self) -&gt; None:\n        \"\"\"\n        Display the information (with a pretty print) about the method\n        \"\"\"\n        self.show_info()\n        self.show_notes()\n\n        if self.CM.get_analysis():\n            self.CM.get_analysis().methods[self].show()\n        else:\n            if self.code:\n                self.each_params_by_register(\n                    self.code.get_registers_size(), self.get_descriptor()\n                )\n                self.code.show()\n\n    def show_notes(self) -&gt; None:\n        \"\"\"\n        Display the notes about the method\n        \"\"\"\n        if self.notes:\n            bytecode._PrintSubBanner(\"Notes\")\n            for i in self.notes:\n                bytecode._PrintNote(i)\n            bytecode._PrintSubBanner()\n\n    def source(self) -&gt; str:\n        \"\"\"\n        Return the source code of this method\n\n        :returns: the source code\n        \"\"\"\n        self.CM.decompiler_ob.display_source(self)\n\n    def get_source(self) -&gt; str:\n        return self.CM.decompiler_ob.get_source_method(self)\n\n    def get_length(self) -&gt; int:\n        \"\"\"\n        Return the length of the associated code of the method\n\n        :returns: the length of the source code\n        \"\"\"\n        if self.code is not None:\n            return self.code.get_length()\n        return 0\n\n    def get_code(self) -&gt; Union[DalvikCode, None]:\n        \"\"\"\n        Return the code object associated to the method\n\n\n        :returns: the `DalvikCode` object or None if no Code\n        \"\"\"\n        if not self.loaded:\n            self.load()\n        return self.code\n\n    def is_cached_instructions(self) -&gt; bool:\n        if self.code is None:\n            return False\n\n        return self.code.get_bc().is_cached_instructions()\n\n    def get_instructions(self) -&gt; Iterator[Instruction]:\n        \"\"\"\n        Get the instructions\n\n        :returns: a generator of each `Instruction` (or a cached list of instructions if you have setup instructions)\n        \"\"\"\n        if self.get_code() is None:\n            return []\n        return self.get_code().get_bc().get_instructions()\n\n    def get_instructions_idx(self) -&gt; Iterator[tuple[int, Instruction]]:\n        \"\"\"\n        Iterate over all instructions of the method, but also return the current index.\n        This is the same as using [get_instructions][androguard.core.dex.EncodedMethod.get_instructions] and adding the instruction length\n        to a variable each time.\n\n        :returns: iterator over index and instructions\n        \"\"\"\n        if self.get_code() is None:\n            return []\n        idx = 0\n        for ins in self.get_code().get_bc().get_instructions():\n            yield idx, ins\n            idx += ins.get_length()\n\n    def set_instructions(self, instructions: list[Instruction]) -&gt; None:\n        \"\"\"\n        Set the instructions\n\n        :param instructions: the list of `Instructions`\n        \"\"\"\n        if self.code is None:\n            return []\n        return self.code.get_bc().set_instructions(instructions)\n\n    def get_instruction(\n        self, idx, off: Union[int, None] = None\n    ) -&gt; Iterator[Instruction]:\n        \"\"\"\n        Get a particular instruction by using (default) the index of the address if specified\n\n        :param idx: index of the instruction (the position in the list of the instruction)\n        :param off: address of the instruction\n\n        :returns: a generator of `Instructions`\n        \"\"\"\n        if self.get_code() is not None:\n            return self.get_code().get_bc().get_instruction(idx, off)\n        return None\n\n    def get_debug(self) -&gt; DebugInfoItem:\n        \"\"\"\n        Return the debug object associated to this method\n\n        :returns: `DebugInfoItem` object\n        \"\"\"\n        if self.get_code() is None:\n            return None\n        return self.get_code().get_debug()\n\n    def get_descriptor(self) -&gt; str:\n        \"\"\"\n        Return the descriptor of the method\n        A method descriptor will have the form `(A A A ...)R`\n        Where A are the arguments to the method and R is the return type.\n        Basic types will have the short form, i.e. I for integer, V for void\n        and class types will be named like a classname, e.g. `Ljava/lang/String;`.\n\n        Typical descriptors will look like this:\n        ```\n        (I)I   // one integer argument, integer return\n        (C)Z   // one char argument, boolean as return\n        (Ljava/lang/CharSequence; I)I   // CharSequence and integer as\n        argyument, integer as return\n        (C)Ljava/lang/String;  // char as argument, String as return.\n        ```\n\n        More information about type descriptors are found here:\n        https://source.android.com/devices/tech/dalvik/dex-format#typedescriptor\n\n        :returns: the descriptor\n        \"\"\"\n        if not self.loaded:\n            self.load()\n        return self.proto\n\n    def get_class_name(self) -&gt; str:\n        \"\"\"\n        Return the class name of the method\n\n        :returns: the class name\n        \"\"\"\n        if not self.loaded:\n            self.load()\n        return self.class_name\n\n    def get_name(self) -&gt; str:\n        \"\"\"\n        Return the name of the method\n\n        :returns: the name\n        \"\"\"\n        if not self.loaded:\n            self.load()\n        return self.name\n\n    def get_triple(self) -&gt; tuple[str, str, str]:\n        return self.CM.get_method_ref(self.method_idx).get_triple()\n\n    def add_inote(\n        self, msg: str, idx: int, off: Union[int, None] = None\n    ) -&gt; None:\n        \"\"\"\n        Add a message to a specific instruction by using (default) the index of the address if specified\n\n        :param msg: the message\n        :param idx: index of the instruction (the position in the list of the instruction)\n        :param off: address of the instruction\n        \"\"\"\n        if self.code is not None:\n            self.code.add_inote(msg, idx, off)\n\n    def add_note(self, msg: str) -&gt; None:\n        \"\"\"\n        Add a message to this method\n\n        :param msg: the message\n        \"\"\"\n        self.notes.append(msg)\n\n    def set_code_idx(self, idx: int) -&gt; None:\n        \"\"\"\n        Set the start address of the buffer to disassemble\n\n        :param idx: the index\n        \"\"\"\n        if self.code is not None:\n            self.code.seek(idx)\n\n    def set_name(self, value):\n        self.CM.set_hook_method_name(self, value)\n        self.reload()\n\n    def get_raw(self):\n        if self.code is not None:\n            self.code_off = self.code.get_off()\n\n        return (\n            writeuleb128(self.CM, self.method_idx_diff)\n            + writeuleb128(self.CM, self.access_flags)\n            + writeuleb128(self.CM, self.code_off)\n        )\n\n    def get_size(self):\n        return len(self.get_raw())\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.descriptor","title":"<code>descriptor</code>  <code>property</code>","text":"<p>Get the descriptor of the method</p>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.full_name","title":"<code>full_name</code>  <code>property</code>","text":"<p>Return class_name + name + descriptor, separated by spaces (no access flags)</p>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.__init__","title":"<code>__init__(buff, cm)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a buff object of the <code>encoded_method</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def __init__(self, buff: BinaryIO, cm:ClassManager) -&gt; None:\n    \"\"\"\n    :param buff: a string which represents a buff object of the `encoded_method`\n    :param cm: a `ClassManager` object\n    \"\"\"\n    self.CM = cm\n    self.offset = buff.tell()\n\n    self.method_idx_diff = readuleb128(\n        cm, buff\n    )  #: method index diff in the corresponding section\n    self.access_flags = readuleb128(\n        cm, buff\n    )  #: access flags of the method\n    self.code_off = readuleb128(cm, buff)  #: offset of the code section\n\n    self.method_idx = 0\n\n    self.name = None\n    self.proto = None\n    self.class_name = None\n\n    self.code = None\n\n    self.access_flags_string = None\n\n    self.notes = []\n    self.loaded = False\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.add_inote","title":"<code>add_inote(msg, idx, off=None)</code>","text":"<p>Add a message to a specific instruction by using (default) the index of the address if specified</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>the message</p> required <code>idx</code> <code>int</code> <p>index of the instruction (the position in the list of the instruction)</p> required <code>off</code> <code>Union[int, None]</code> <p>address of the instruction</p> <code>None</code> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def add_inote(\n    self, msg: str, idx: int, off: Union[int, None] = None\n) -&gt; None:\n    \"\"\"\n    Add a message to a specific instruction by using (default) the index of the address if specified\n\n    :param msg: the message\n    :param idx: index of the instruction (the position in the list of the instruction)\n    :param off: address of the instruction\n    \"\"\"\n    if self.code is not None:\n        self.code.add_inote(msg, idx, off)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.add_note","title":"<code>add_note(msg)</code>","text":"<p>Add a message to this method</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>the message</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def add_note(self, msg: str) -&gt; None:\n    \"\"\"\n    Add a message to this method\n\n    :param msg: the message\n    \"\"\"\n    self.notes.append(msg)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.each_params_by_register","title":"<code>each_params_by_register(nb, proto)</code>","text":"<p>From the Dalvik Bytecode documentation:</p> <p>The N arguments to a method land in the last N registers of the method's invocation frame, in order. Wide arguments consume two registers. Instance methods are passed a this reference as their first argument.</p> <p>This method will print a description of the register usage to stdout.</p> <p>Parameters:</p> Name Type Description Default <code>nb</code> <code>int</code> <p>number of registers</p> required <code>proto</code> <code>str</code> <p>descriptor of method</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def each_params_by_register(self, nb: int, proto: str) -&gt; None:\n    \"\"\"\n    From the Dalvik Bytecode documentation:\n\n    &gt; The N arguments to a method land in the last N registers\n    &gt; of the method's invocation frame, in order.\n    &gt; Wide arguments consume two registers.\n    &gt; Instance methods are passed a this reference as their first argument.\n\n    This method will print a description of the register usage to stdout.\n\n    :param nb: number of registers\n    :param proto: descriptor of method\n    \"\"\"\n    bytecode._PrintSubBanner(\"Params\")\n\n    ret = proto.split(')')\n    params = ret[0][1:].split()\n    if params:\n        bytecode._PrintDefault(\n            \"- local registers: v%d...v%d\\n\" % (0, nb - len(params) - 1)\n        )\n        j = 0\n        for i in range(nb - len(params), nb):\n            bytecode._PrintDefault(\n                \"- v%d: %s\\n\" % (i, get_type(params[j]))\n            )\n            j += 1\n    else:\n        bytecode._PrintDefault(\n            \"local registers: v%d...v%d\\n\" % (0, nb - 1)\n        )\n\n    bytecode._PrintDefault(\"- return: %s\\n\" % get_type(ret[1]))\n    bytecode._PrintSubBanner()\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.get_access_flags","title":"<code>get_access_flags()</code>","text":"<p>Return the access flags of the method</p> <p>Returns:</p> Type Description <code>int</code> <p>the access flags</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_access_flags(self) -&gt; int:\n    \"\"\"\n    Return the access flags of the method\n\n    :returns: the access flags\n    \"\"\"\n    return self.access_flags\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.get_access_flags_string","title":"<code>get_access_flags_string()</code>","text":"<p>Return the access flags string of the method</p> <p>A description of all access flags can be found here: https://source.android.com/devices/tech/dalvik/dex-format#access-flags</p> <p>Returns:</p> Type Description <code>str</code> <p>the access flags</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_access_flags_string(self) -&gt; str:\n    \"\"\"\n    Return the access flags string of the method\n\n    A description of all access flags can be found here:\n    https://source.android.com/devices/tech/dalvik/dex-format#access-flags\n\n    :returns: the access flags\n    \"\"\"\n    if self.access_flags_string is None:\n        self.access_flags_string = get_access_flags_string(\n            self.get_access_flags()\n        )\n\n        if (\n            self.access_flags_string == \"\"\n            and self.get_access_flags() != 0x0\n        ):\n            self.access_flags_string = \"0x%x\" % self.get_access_flags()\n    return self.access_flags_string\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.get_address","title":"<code>get_address()</code>","text":"<p>Return the offset from the start of the file to the code structure for this method, or 0 if this method is either abstract or native</p> <p>Returns:</p> Type Description <code>int</code> <p>the offset</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_address(self) -&gt; int:\n    \"\"\"\n    Return the offset from the start of the file to the code structure for this method,\n    or 0 if this method is either abstract or native\n\n    :returns: the offset\n    \"\"\"\n    return self.code_off + 0x10\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.get_class_name","title":"<code>get_class_name()</code>","text":"<p>Return the class name of the method</p> <p>Returns:</p> Type Description <code>str</code> <p>the class name</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_class_name(self) -&gt; str:\n    \"\"\"\n    Return the class name of the method\n\n    :returns: the class name\n    \"\"\"\n    if not self.loaded:\n        self.load()\n    return self.class_name\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.get_code","title":"<code>get_code()</code>","text":"<p>Return the code object associated to the method</p> <p>Returns:</p> Type Description <code>Union[DalvikCode, None]</code> <p>the <code>DalvikCode</code> object or None if no Code</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_code(self) -&gt; Union[DalvikCode, None]:\n    \"\"\"\n    Return the code object associated to the method\n\n\n    :returns: the `DalvikCode` object or None if no Code\n    \"\"\"\n    if not self.loaded:\n        self.load()\n    return self.code\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.get_code_off","title":"<code>get_code_off()</code>","text":"<p>Return the offset from the start of the file to the code structure for this method, or 0 if this method is either abstract or native</p> <p>Returns:</p> Type Description <code>int</code> <p>the offset</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_code_off(self) -&gt; int:\n    \"\"\"\n    Return the offset from the start of the file to the code structure for this method,\n    or 0 if this method is either abstract or native\n\n    :returns: the offset\n    \"\"\"\n    return self.code_off\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.get_debug","title":"<code>get_debug()</code>","text":"<p>Return the debug object associated to this method</p> <p>Returns:</p> Type Description <code>DebugInfoItem</code> <p><code>DebugInfoItem</code> object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_debug(self) -&gt; DebugInfoItem:\n    \"\"\"\n    Return the debug object associated to this method\n\n    :returns: `DebugInfoItem` object\n    \"\"\"\n    if self.get_code() is None:\n        return None\n    return self.get_code().get_debug()\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.get_descriptor","title":"<code>get_descriptor()</code>","text":"<p>Return the descriptor of the method A method descriptor will have the form <code>(A A A ...)R</code> Where A are the arguments to the method and R is the return type. Basic types will have the short form, i.e. I for integer, V for void and class types will be named like a classname, e.g. <code>Ljava/lang/String;</code>.</p> <p>Typical descriptors will look like this: <pre><code>(I)I   // one integer argument, integer return\n(C)Z   // one char argument, boolean as return\n(Ljava/lang/CharSequence; I)I   // CharSequence and integer as\nargyument, integer as return\n(C)Ljava/lang/String;  // char as argument, String as return.\n</code></pre></p> <p>More information about type descriptors are found here: https://source.android.com/devices/tech/dalvik/dex-format#typedescriptor</p> <p>Returns:</p> Type Description <code>str</code> <p>the descriptor</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_descriptor(self) -&gt; str:\n    \"\"\"\n    Return the descriptor of the method\n    A method descriptor will have the form `(A A A ...)R`\n    Where A are the arguments to the method and R is the return type.\n    Basic types will have the short form, i.e. I for integer, V for void\n    and class types will be named like a classname, e.g. `Ljava/lang/String;`.\n\n    Typical descriptors will look like this:\n    ```\n    (I)I   // one integer argument, integer return\n    (C)Z   // one char argument, boolean as return\n    (Ljava/lang/CharSequence; I)I   // CharSequence and integer as\n    argyument, integer as return\n    (C)Ljava/lang/String;  // char as argument, String as return.\n    ```\n\n    More information about type descriptors are found here:\n    https://source.android.com/devices/tech/dalvik/dex-format#typedescriptor\n\n    :returns: the descriptor\n    \"\"\"\n    if not self.loaded:\n        self.load()\n    return self.proto\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.get_information","title":"<code>get_information()</code>","text":"<p>Get brief information about the method's register use, parameters and return type.</p> <p>The resulting dictionary has the form:</p> <pre><code>&gt;&gt;&gt; {\n&gt;&gt;&gt;    registers: (start, end),\n&gt;&gt;&gt;    params: [(reg_1, type_1), (reg_2, type_2), ..., (reg_n, type_n)],\n&gt;&gt;&gt;    return: type\n&gt;&gt;&gt; }\n</code></pre> <p>The end register is not the last register used, but the last register used not for parameters. Hence, they represent the local registers. The start register is always zero. The register numbers for the parameters can be found in the tuples for each parameter.</p> <p>Returns:</p> Type Description <code>dict[str, Union[str, tuple[int, int], list]]</code> <p>a dictionary with the basic information about the method</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_information(self) -&gt; dict[str, Union[str, tuple[int, int], list]]:\n    \"\"\"\n    Get brief information about the method's register use,\n    parameters and return type.\n\n    The resulting dictionary has the form:\n\n        &gt;&gt;&gt; {\n        &gt;&gt;&gt;    registers: (start, end),\n        &gt;&gt;&gt;    params: [(reg_1, type_1), (reg_2, type_2), ..., (reg_n, type_n)],\n        &gt;&gt;&gt;    return: type\n        &gt;&gt;&gt; }\n\n    The end register is not the last register used, but the last register\n    used not for parameters. Hence, they represent the local registers.\n    The start register is always zero.\n    The register numbers for the parameters can be found in the tuples\n    for each parameter.\n\n    :returns: a dictionary with the basic information about the method\n    \"\"\"\n    info = dict()\n    if self.code:\n        nb = self.code.get_registers_size()\n        proto = self.get_descriptor()\n\n        ret = proto.split(')')\n        params = ret[0][1:].split()\n\n        info[\"return\"] = get_type(ret[1])\n\n        if params:\n            info[\"registers\"] = (0, nb - len(params) - 1)\n            j = 0\n            info[\"params\"] = []\n            for i in range(nb - len(params), nb):\n                info[\"params\"].append((i, get_type(params[j])))\n                j += 1\n        else:\n            info[\"registers\"] = (0, nb - 1)\n\n    return info\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.get_instruction","title":"<code>get_instruction(idx, off=None)</code>","text":"<p>Get a particular instruction by using (default) the index of the address if specified</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <p>index of the instruction (the position in the list of the instruction)</p> required <code>off</code> <code>Union[int, None]</code> <p>address of the instruction</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[Instruction]</code> <p>a generator of <code>Instructions</code></p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_instruction(\n    self, idx, off: Union[int, None] = None\n) -&gt; Iterator[Instruction]:\n    \"\"\"\n    Get a particular instruction by using (default) the index of the address if specified\n\n    :param idx: index of the instruction (the position in the list of the instruction)\n    :param off: address of the instruction\n\n    :returns: a generator of `Instructions`\n    \"\"\"\n    if self.get_code() is not None:\n        return self.get_code().get_bc().get_instruction(idx, off)\n    return None\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.get_instructions","title":"<code>get_instructions()</code>","text":"<p>Get the instructions</p> <p>Returns:</p> Type Description <code>Iterator[Instruction]</code> <p>a generator of each <code>Instruction</code> (or a cached list of instructions if you have setup instructions)</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_instructions(self) -&gt; Iterator[Instruction]:\n    \"\"\"\n    Get the instructions\n\n    :returns: a generator of each `Instruction` (or a cached list of instructions if you have setup instructions)\n    \"\"\"\n    if self.get_code() is None:\n        return []\n    return self.get_code().get_bc().get_instructions()\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.get_instructions_idx","title":"<code>get_instructions_idx()</code>","text":"<p>Iterate over all instructions of the method, but also return the current index. This is the same as using get_instructions and adding the instruction length to a variable each time.</p> <p>Returns:</p> Type Description <code>Iterator[tuple[int, Instruction]]</code> <p>iterator over index and instructions</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_instructions_idx(self) -&gt; Iterator[tuple[int, Instruction]]:\n    \"\"\"\n    Iterate over all instructions of the method, but also return the current index.\n    This is the same as using [get_instructions][androguard.core.dex.EncodedMethod.get_instructions] and adding the instruction length\n    to a variable each time.\n\n    :returns: iterator over index and instructions\n    \"\"\"\n    if self.get_code() is None:\n        return []\n    idx = 0\n    for ins in self.get_code().get_bc().get_instructions():\n        yield idx, ins\n        idx += ins.get_length()\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.get_length","title":"<code>get_length()</code>","text":"<p>Return the length of the associated code of the method</p> <p>Returns:</p> Type Description <code>int</code> <p>the length of the source code</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_length(self) -&gt; int:\n    \"\"\"\n    Return the length of the associated code of the method\n\n    :returns: the length of the source code\n    \"\"\"\n    if self.code is not None:\n        return self.code.get_length()\n    return 0\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.get_locals","title":"<code>get_locals()</code>","text":"<p>Get the number of local registers used by the method</p> <p>This number is equal to the number of registers minus the number of parameters minus 1.</p> <p>Returns:</p> Type Description <code>int</code> <p>number of local registers</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_locals(self) -&gt; int:\n    \"\"\"\n    Get the number of local registers used by the method\n\n    This number is equal to the number of registers minus the number of parameters minus 1.\n\n    :returns: number of local registers\n    \"\"\"\n    ret = self.proto.split(')')\n    params = ret[0][1:].split()\n\n    return self.code.get_registers_size() - len(params) - 1\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.get_method_idx","title":"<code>get_method_idx()</code>","text":"<p>Return the real index of the method</p> <p>Returns:</p> Type Description <code>int</code> <p>the real index</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_method_idx(self) -&gt; int:\n    \"\"\"\n    Return the real index of the method\n\n    :returns: the real index\n    \"\"\"\n    return self.method_idx\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.get_method_idx_diff","title":"<code>get_method_idx_diff()</code>","text":"<p>Return index into the <code>method_ids</code> list for the identity of this method (includes the name and descriptor), represented as a difference from the index of previous element in the lis</p> <p>Returns:</p> Type Description <code>int</code> <p>the index</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_method_idx_diff(self) -&gt; int:\n    \"\"\"\n    Return index into the `method_ids` list for the identity of this method (includes the name and descriptor),\n    represented as a difference from the index of previous element in the lis\n\n    :returns: the index\n    \"\"\"\n    return self.method_idx_diff\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.get_name","title":"<code>get_name()</code>","text":"<p>Return the name of the method</p> <p>Returns:</p> Type Description <code>str</code> <p>the name</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_name(self) -&gt; str:\n    \"\"\"\n    Return the name of the method\n\n    :returns: the name\n    \"\"\"\n    if not self.loaded:\n        self.load()\n    return self.name\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.get_short_string","title":"<code>get_short_string()</code>","text":"<p>Return a shorter formatted String which encodes this method. The returned name has the form:   ([arguments ...]) <ul> <li>All Class names are condensed to the actual name (no package).</li> <li>Access flags are not returned.</li> <li> and  are NOT replaced by the classname! <p>This name might not be unique!</p> <p>Returns:</p> Type Description <code>str</code> <p>str</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_short_string(self) -&gt; str:\n    \"\"\"\n    Return a shorter formatted String which encodes this method.\n    The returned name has the form:\n    &lt;classname&gt; &lt;methodname&gt; ([arguments ...])&lt;returntype&gt;\n\n    * All Class names are condensed to the actual name (no package).\n    * Access flags are not returned.\n    * &lt;init&gt; and &lt;clinit&gt; are NOT replaced by the classname!\n\n    This name might not be unique!\n\n    :returns: str\n    \"\"\"\n\n    def _fmt_classname(cls) -&gt; str:\n        arr = \"\"\n        # Test for arrays\n        while cls.startswith(\"[\"):\n            arr += \"[\"\n            cls = cls[1:]\n\n        # is a object type\n        if cls.startswith(\"L\"):\n            cls = cls[1:-1]\n        # only return last element\n        if \"/\" in cls:\n            cls = cls.rsplit(\"/\", 1)[1]\n        return arr + cls\n\n    clsname = _fmt_classname(str(self.get_class_name()))\n\n    param, ret = str(self.get_descriptor())[1:].split(\")\")\n    params = map(_fmt_classname, param.split(\" \"))\n    desc = \"({}){}\".format(''.join(params), _fmt_classname(ret))\n    return \"{cls} {meth} {desc}\".format(\n        cls=clsname, meth=self.get_name(), desc=desc\n    )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.set_code_idx","title":"<code>set_code_idx(idx)</code>","text":"<p>Set the start address of the buffer to disassemble</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>the index</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def set_code_idx(self, idx: int) -&gt; None:\n    \"\"\"\n    Set the start address of the buffer to disassemble\n\n    :param idx: the index\n    \"\"\"\n    if self.code is not None:\n        self.code.seek(idx)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.set_instructions","title":"<code>set_instructions(instructions)</code>","text":"<p>Set the instructions</p> <p>Parameters:</p> Name Type Description Default <code>instructions</code> <code>list[Instruction]</code> <p>the list of <code>Instructions</code></p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def set_instructions(self, instructions: list[Instruction]) -&gt; None:\n    \"\"\"\n    Set the instructions\n\n    :param instructions: the list of `Instructions`\n    \"\"\"\n    if self.code is None:\n        return []\n    return self.code.get_bc().set_instructions(instructions)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.show","title":"<code>show()</code>","text":"<p>Display the information (with a pretty print) about the method</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"\n    Display the information (with a pretty print) about the method\n    \"\"\"\n    self.show_info()\n    self.show_notes()\n\n    if self.CM.get_analysis():\n        self.CM.get_analysis().methods[self].show()\n    else:\n        if self.code:\n            self.each_params_by_register(\n                self.code.get_registers_size(), self.get_descriptor()\n            )\n            self.code.show()\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.show_info","title":"<code>show_info()</code>","text":"<p>Display the basic information about the method</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def show_info(self) -&gt; None:\n    \"\"\"\n    Display the basic information about the method\n    \"\"\"\n    bytecode._PrintSubBanner(\"Method Information\")\n    bytecode._PrintDefault(\n        \"{}-&gt;{}{} [access_flags={}]\\n\".format(\n            self.get_class_name(),\n            self.get_name(),\n            self.get_descriptor(),\n            self.get_access_flags_string(),\n        )\n    )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.show_notes","title":"<code>show_notes()</code>","text":"<p>Display the notes about the method</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def show_notes(self) -&gt; None:\n    \"\"\"\n    Display the notes about the method\n    \"\"\"\n    if self.notes:\n        bytecode._PrintSubBanner(\"Notes\")\n        for i in self.notes:\n            bytecode._PrintNote(i)\n        bytecode._PrintSubBanner()\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedMethod.source","title":"<code>source()</code>","text":"<p>Return the source code of this method</p> <p>Returns:</p> Type Description <code>str</code> <p>the source code</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def source(self) -&gt; str:\n    \"\"\"\n    Return the source code of this method\n\n    :returns: the source code\n    \"\"\"\n    self.CM.decompiler_ob.display_source(self)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedTypeAddrPair","title":"<code>EncodedTypeAddrPair</code>","text":"<p>This class can parse an <code>encoded_type_addr_pair</code> of a dex file</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a Buff object of the <code>encoded_type_addr_pair</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class EncodedTypeAddrPair:\n    \"\"\"\n    This class can parse an `encoded_type_addr_pair` of a dex file\n\n    :param buff: a string which represents a Buff object of the `encoded_type_addr_pair`\n    :param cm: a `ClassManager` object\n    \"\"\"\n\n    def __init__(self, cm: ClassManager, buff: BinaryIO) -&gt; None:\n        self.CM = cm\n        self.type_idx = readuleb128(cm, buff)\n        self.addr = readuleb128(cm, buff)\n\n    def get_type_idx(self) -&gt; int:\n        \"\"\"\n        Return the index into the `type_ids` list for the type of the exception to catch\n\n        :returns: the index\n        \"\"\"\n        return self.type_idx\n\n    def get_addr(self) -&gt; int:\n        \"\"\"\n        Return the bytecode address of the associated exception handler\n\n        :returns: the bytecode address\n        \"\"\"\n        return self.addr\n\n    def get_obj(self) -&gt; list:\n        return []\n\n    def show(self) -&gt; None:\n        bytecode._PrintSubBanner(\"Encoded Type Addr Pair\")\n        bytecode._PrintDefault(\n            \"type_idx=%d addr=%x\\n\" % (self.type_idx, self.addr)\n        )\n\n    def get_raw(self) -&gt; bytearray:\n        return writeuleb128(self.CM, self.type_idx) + writeuleb128(\n            self.CM, self.addr\n        )\n\n    def get_length(self) -&gt; int:\n        return len(self.get_raw())\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedTypeAddrPair.get_addr","title":"<code>get_addr()</code>","text":"<p>Return the bytecode address of the associated exception handler</p> <p>Returns:</p> Type Description <code>int</code> <p>the bytecode address</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_addr(self) -&gt; int:\n    \"\"\"\n    Return the bytecode address of the associated exception handler\n\n    :returns: the bytecode address\n    \"\"\"\n    return self.addr\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedTypeAddrPair.get_type_idx","title":"<code>get_type_idx()</code>","text":"<p>Return the index into the <code>type_ids</code> list for the type of the exception to catch</p> <p>Returns:</p> Type Description <code>int</code> <p>the index</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_type_idx(self) -&gt; int:\n    \"\"\"\n    Return the index into the `type_ids` list for the type of the exception to catch\n\n    :returns: the index\n    \"\"\"\n    return self.type_idx\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedValue","title":"<code>EncodedValue</code>","text":"<p>This class can parse an <code>encoded_value</code> of a dex file</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class EncodedValue:\n    \"\"\"\n    This class can parse an `encoded_value` of a dex file\n    \"\"\"\n    def __init__(self, buff: BinaryIO, cm:ClassManager) -&gt; None:\n        \"\"\"\n        :param buff: a string which represents a Buff object of the `encoded_value`\n        :param cm: a `ClassManager` object\n        \"\"\"\n        self.CM = cm\n\n        self.val = get_byte(cm, buff)\n        self.value_arg = self.val &gt;&gt; 5\n        self.value_type = self.val &amp; 0x1F\n\n        self.raw_value = None\n        self.value = \"\"\n\n        #  TODO: parse floats/doubles correctly\n        if VALUE_SHORT &lt;= self.value_type &lt; VALUE_STRING:\n            self.value, self.raw_value = self._getintvalue(\n                buff.read(self.value_arg + 1)\n            )\n        elif self.value_type == VALUE_STRING:\n            id, self.raw_value = self._getintvalue(\n                buff.read(self.value_arg + 1)\n            )\n            self.value = cm.get_raw_string(id)\n        elif self.value_type == VALUE_TYPE:\n            id, self.raw_value = self._getintvalue(\n                buff.read(self.value_arg + 1)\n            )\n            self.value = cm.get_type(id)\n        elif self.value_type == VALUE_FIELD:\n            id, self.raw_value = self._getintvalue(\n                buff.read(self.value_arg + 1)\n            )\n            self.value = cm.get_field(id)\n        elif self.value_type == VALUE_METHOD:\n            id, self.raw_value = self._getintvalue(\n                buff.read(self.value_arg + 1)\n            )\n            self.value = cm.get_method(id)\n        elif self.value_type == VALUE_ENUM:\n            id, self.raw_value = self._getintvalue(\n                buff.read(self.value_arg + 1)\n            )\n            self.value = cm.get_field(id)\n        elif self.value_type == VALUE_ARRAY:\n            self.value = EncodedArray(buff, cm)\n        elif self.value_type == VALUE_ANNOTATION:\n            self.value = EncodedAnnotation(buff, cm)\n        elif self.value_type == VALUE_BYTE:\n            self.value = get_byte(cm, buff)\n        elif self.value_type == VALUE_NULL:\n            self.value = None\n        elif self.value_type == VALUE_BOOLEAN:\n            if self.value_arg:\n                self.value = True\n            else:\n                self.value = False\n        else:\n            logger.warning(\"Unknown value 0x%x\" % self.value_type)\n\n    def get_value(self):\n        \"\"\"\n        Return the bytes representing the value, variable in length and interpreted differently for different `value_type` bytes,\n        though always little-endian\n\n        :returns: an object representing the value\n        \"\"\"\n        return self.value\n\n    def get_value_type(self):\n        return self.value_type\n\n    def get_value_arg(self):\n        return self.value_arg\n\n    def _getintvalue(self, buf):\n        ret = 0\n        shift = 0\n        for b in buf:\n            ret |= b &lt;&lt; shift\n            shift += 8\n\n        return ret, buf\n\n    def show(self):\n        bytecode._PrintSubBanner(\"Encoded Value\")\n        bytecode._PrintDefault(\n            \"val=%x value_arg=%x value_type=%x\\n\"\n            % (self.val, self.value_arg, self.value_type)\n        )\n\n    def get_obj(self):\n        if not isinstance(self.value, str):\n            return [self.value]\n        return []\n\n    def get_raw(self):\n        if self.raw_value is None:\n            return self.CM.packer[\"B\"].pack(\n                self.val\n            ) + bytecode.object_to_bytes(self.value)\n        else:\n            return self.CM.packer[\"B\"].pack(\n                self.val\n            ) + bytecode.object_to_bytes(self.raw_value)\n\n    def get_length(self):\n        return len(self.get_raw())\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedValue.__init__","title":"<code>__init__(buff, cm)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a Buff object of the <code>encoded_value</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def __init__(self, buff: BinaryIO, cm:ClassManager) -&gt; None:\n    \"\"\"\n    :param buff: a string which represents a Buff object of the `encoded_value`\n    :param cm: a `ClassManager` object\n    \"\"\"\n    self.CM = cm\n\n    self.val = get_byte(cm, buff)\n    self.value_arg = self.val &gt;&gt; 5\n    self.value_type = self.val &amp; 0x1F\n\n    self.raw_value = None\n    self.value = \"\"\n\n    #  TODO: parse floats/doubles correctly\n    if VALUE_SHORT &lt;= self.value_type &lt; VALUE_STRING:\n        self.value, self.raw_value = self._getintvalue(\n            buff.read(self.value_arg + 1)\n        )\n    elif self.value_type == VALUE_STRING:\n        id, self.raw_value = self._getintvalue(\n            buff.read(self.value_arg + 1)\n        )\n        self.value = cm.get_raw_string(id)\n    elif self.value_type == VALUE_TYPE:\n        id, self.raw_value = self._getintvalue(\n            buff.read(self.value_arg + 1)\n        )\n        self.value = cm.get_type(id)\n    elif self.value_type == VALUE_FIELD:\n        id, self.raw_value = self._getintvalue(\n            buff.read(self.value_arg + 1)\n        )\n        self.value = cm.get_field(id)\n    elif self.value_type == VALUE_METHOD:\n        id, self.raw_value = self._getintvalue(\n            buff.read(self.value_arg + 1)\n        )\n        self.value = cm.get_method(id)\n    elif self.value_type == VALUE_ENUM:\n        id, self.raw_value = self._getintvalue(\n            buff.read(self.value_arg + 1)\n        )\n        self.value = cm.get_field(id)\n    elif self.value_type == VALUE_ARRAY:\n        self.value = EncodedArray(buff, cm)\n    elif self.value_type == VALUE_ANNOTATION:\n        self.value = EncodedAnnotation(buff, cm)\n    elif self.value_type == VALUE_BYTE:\n        self.value = get_byte(cm, buff)\n    elif self.value_type == VALUE_NULL:\n        self.value = None\n    elif self.value_type == VALUE_BOOLEAN:\n        if self.value_arg:\n            self.value = True\n        else:\n            self.value = False\n    else:\n        logger.warning(\"Unknown value 0x%x\" % self.value_type)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.EncodedValue.get_value","title":"<code>get_value()</code>","text":"<p>Return the bytes representing the value, variable in length and interpreted differently for different <code>value_type</code> bytes, though always little-endian</p> <p>Returns:</p> Type Description <p>an object representing the value</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_value(self):\n    \"\"\"\n    Return the bytes representing the value, variable in length and interpreted differently for different `value_type` bytes,\n    though always little-endian\n\n    :returns: an object representing the value\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ExportObject","title":"<code>ExportObject</code>","text":"<p>Wrapper object for ipython exports</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class ExportObject:\n    \"\"\"\n    Wrapper object for ipython exports\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.FieldAnnotation","title":"<code>FieldAnnotation</code>","text":"<p>This class can parse a <code>field_annotation</code> of a dex file</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a buff object of the <code>field_annotation</code></p> required <code>cm</code> <code>ClassManager</code> <p>a ClassManager object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class FieldAnnotation:\n    \"\"\"\n    This class can parse a `field_annotation` of a dex file\n\n    :param buff: a string which represents a buff object of the `field_annotation`\n    :param cm: a ClassManager object\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm: ClassManager) -&gt; None:\n        self.offset = buff.tell()\n\n        self.CM = cm\n        self.field_idx, self.annotations_off = cm.packer[\"2I\"].unpack(\n            buff.read(8)\n        )\n\n    def get_field_idx(self) -&gt; int:\n        \"\"\"\n        Return the index into the `field_ids` list for the identity of the field being annotated\n\n        :returns: the index\n        \"\"\"\n        return self.field_idx\n\n    def get_annotations_off(self) -&gt; int:\n        \"\"\"\n        Return the offset from the start of the file to the list of annotations for the field\n\n        :returns: the offset\n        \"\"\"\n        return self.annotations_off\n\n    def set_off(self, off: int) -&gt; None:\n        self.offset = off\n\n    def get_off(self) -&gt; int:\n        return self.offset\n\n    def show(self) -&gt; None:\n        bytecode._PrintSubBanner(\"Field Annotation\")\n        bytecode._PrintDefault(\n            \"field_idx=0x%x annotations_off=0x%x\\n\"\n            % (self.field_idx, self.annotations_off)\n        )\n\n    def get_obj(self) -&gt; bytes:\n        if self.annotations_off != 0:\n            self.annotations_off = self.CM.get_obj_by_offset(\n                self.annotations_off\n            ).get_off()\n\n        return self.CM.packer[\"2I\"].pack(self.field_idx, self.annotations_off)\n\n    def get_raw(self) -&gt; bytes:\n        return self.get_obj()\n\n    def get_length(self) -&gt; int:\n        return len(self.get_raw())\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.FieldAnnotation.get_annotations_off","title":"<code>get_annotations_off()</code>","text":"<p>Return the offset from the start of the file to the list of annotations for the field</p> <p>Returns:</p> Type Description <code>int</code> <p>the offset</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_annotations_off(self) -&gt; int:\n    \"\"\"\n    Return the offset from the start of the file to the list of annotations for the field\n\n    :returns: the offset\n    \"\"\"\n    return self.annotations_off\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.FieldAnnotation.get_field_idx","title":"<code>get_field_idx()</code>","text":"<p>Return the index into the <code>field_ids</code> list for the identity of the field being annotated</p> <p>Returns:</p> Type Description <code>int</code> <p>the index</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_field_idx(self) -&gt; int:\n    \"\"\"\n    Return the index into the `field_ids` list for the identity of the field being annotated\n\n    :returns: the index\n    \"\"\"\n    return self.field_idx\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.FieldHIdItem","title":"<code>FieldHIdItem</code>","text":"<p>This class can parse a list of <code>field_id_item</code> of a dex file</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class FieldHIdItem:\n    \"\"\"\n    This class can parse a list of `field_id_item` of a dex file\n    \"\"\"\n\n    def __init__(self, size:int, buff: BinaryIO, cm:ClassManager) -&gt; None:\n        \"\"\"\n        :param buff: a string which represents a buff object of the list of `field_id_item`\n        :param cm: a `ClassManager` object\n        \"\"\"\n        self.offset = buff.tell()\n\n        self.field_id_items = [FieldIdItem(buff, cm) for i in range(0, size)]\n\n    def set_off(self, off: int) -&gt; None:\n        self.offset = off\n\n    def get_off(self) -&gt; int:\n        return self.offset\n\n    def gets(self) -&gt; list[FieldIdItem]:\n        return self.field_id_items\n\n    def get(self, idx: int) -&gt; Union[FieldIdItem, FieldIdItemInvalid]:\n        try:\n            return self.field_id_items[idx]\n        except IndexError:\n            return FieldIdItemInvalid()\n\n    def show(self) -&gt; None:\n        nb = 0\n        for i in self.field_id_items:\n            print(nb, end=' ')\n            i.show()\n            nb = nb + 1\n\n    def get_obj(self) -&gt; list[FieldIdItem]:\n        return [i for i in self.field_id_items]\n\n    def get_raw(self) -&gt; bytes:\n        return b''.join(i.get_raw() for i in self.field_id_items)\n\n    def get_length(self) -&gt; int:\n        length = 0\n        for i in self.field_id_items:\n            length += i.get_length()\n        return length\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.FieldHIdItem.__init__","title":"<code>__init__(size, buff, cm)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a buff object of the list of <code>field_id_item</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def __init__(self, size:int, buff: BinaryIO, cm:ClassManager) -&gt; None:\n    \"\"\"\n    :param buff: a string which represents a buff object of the list of `field_id_item`\n    :param cm: a `ClassManager` object\n    \"\"\"\n    self.offset = buff.tell()\n\n    self.field_id_items = [FieldIdItem(buff, cm) for i in range(0, size)]\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.FieldIdItem","title":"<code>FieldIdItem</code>","text":"<p>This class can parse a <code>field_id_item</code> of a dex file</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class FieldIdItem:\n    \"\"\"\n    This class can parse a `field_id_item` of a dex file\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm: ClassManager) -&gt; None:\n        \"\"\"\"\n        :param buff: a string which represents a Buff object of the `field_id_item`\n        :param cm: a `ClassManager` object\n        \"\"\"\n        self.CM = cm\n        self.offset = buff.tell()\n\n        self.class_idx, self.type_idx, self.name_idx = cm.packer[\"2HI\"].unpack(\n            buff.read(8)\n        )\n\n        self.reload()\n\n    def reload(self) -&gt; None:\n        self.class_idx_value = self.CM.get_type(self.class_idx)\n        self.type_idx_value = self.CM.get_type(self.type_idx)\n        self.name_idx_value = self.CM.get_string(self.name_idx)\n\n    def get_class_idx(self) -&gt; int:\n        \"\"\"\n        Return the index into the `type_ids` list for the definer of this field\n\n        :returns: the index\n        \"\"\"\n        return self.class_idx\n\n    def get_type_idx(self) -&gt; int:\n        \"\"\"\n        Return the index into the `type_ids` list for the type of this field\n\n        :returns: the index\n        \"\"\"\n        return self.type_idx\n\n    def get_name_idx(self) -&gt; int:\n        \"\"\"\n        Return the index into the `string_ids` list for the name of this field\n\n        :returns: the index\n        \"\"\"\n        return self.name_idx\n\n    def get_class_name(self) -&gt; str:\n        \"\"\"\n        Return the class name of the field\n\n        :returns: the class name\n        \"\"\"\n        if self.class_idx_value is None:\n            self.class_idx_value = self.CM.get_type(self.class_idx)\n        return self.class_idx_value\n\n    def get_type(self) -&gt; str:\n        \"\"\"\n        Return the type of the field\n\n        :returns: the type\n        \"\"\"\n        if self.type_idx_value is None:\n            self.type_idx_value = self.CM.get_type(self.type_idx)\n        return self.type_idx_value\n\n    def get_descriptor(self) -&gt; str:\n        \"\"\"\n        Return the descriptor of the field\n\n        :returns: the desciptor\n        \"\"\"\n        if self.type_idx_value is None:\n            self.type_idx_value = self.CM.get_type(self.type_idx)\n        return self.type_idx_value\n\n    def get_name(self) -&gt; str:\n        \"\"\"\n        Return the name of the field\n\n        :returns: the name\n        \"\"\"\n        if self.name_idx_value is None:\n            self.name_idx_value = self.CM.get_string(self.name_idx)\n        return self.name_idx_value\n\n    def get_list(self) -&gt; list[str]:\n        return [self.get_class_name(), self.get_type(), self.get_name()]\n\n    def show(self) -&gt; None:\n        bytecode._PrintSubBanner(\"Field Id Item\")\n        bytecode._PrintDefault(\n            \"class_idx=%d type_idx=%d name_idx=%d\\n\"\n            % (self.class_idx, self.type_idx, self.name_idx)\n        )\n        bytecode._PrintDefault(\n            \"class_idx_value=%s type_idx_value=%s name_idx_value=%s\\n\"\n            % (self.class_idx_value, self.type_idx_value, self.name_idx_value)\n        )\n\n    def get_obj(self) -&gt; bytes:\n        return self.CM.packer[\"2HI\"].pack(\n            self.class_idx, self.type_idx, self.name_idx\n        )\n\n    def get_raw(self) -&gt; bytes:\n        return self.get_obj()\n\n    def get_length(self) -&gt; int:\n        return len(self.get_obj())\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.FieldIdItem.__init__","title":"<code>__init__(buff, cm)</code>","text":"<p>\"</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a Buff object of the <code>field_id_item</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def __init__(self, buff: BinaryIO, cm: ClassManager) -&gt; None:\n    \"\"\"\"\n    :param buff: a string which represents a Buff object of the `field_id_item`\n    :param cm: a `ClassManager` object\n    \"\"\"\n    self.CM = cm\n    self.offset = buff.tell()\n\n    self.class_idx, self.type_idx, self.name_idx = cm.packer[\"2HI\"].unpack(\n        buff.read(8)\n    )\n\n    self.reload()\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.FieldIdItem.get_class_idx","title":"<code>get_class_idx()</code>","text":"<p>Return the index into the <code>type_ids</code> list for the definer of this field</p> <p>Returns:</p> Type Description <code>int</code> <p>the index</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_class_idx(self) -&gt; int:\n    \"\"\"\n    Return the index into the `type_ids` list for the definer of this field\n\n    :returns: the index\n    \"\"\"\n    return self.class_idx\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.FieldIdItem.get_class_name","title":"<code>get_class_name()</code>","text":"<p>Return the class name of the field</p> <p>Returns:</p> Type Description <code>str</code> <p>the class name</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_class_name(self) -&gt; str:\n    \"\"\"\n    Return the class name of the field\n\n    :returns: the class name\n    \"\"\"\n    if self.class_idx_value is None:\n        self.class_idx_value = self.CM.get_type(self.class_idx)\n    return self.class_idx_value\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.FieldIdItem.get_descriptor","title":"<code>get_descriptor()</code>","text":"<p>Return the descriptor of the field</p> <p>Returns:</p> Type Description <code>str</code> <p>the desciptor</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_descriptor(self) -&gt; str:\n    \"\"\"\n    Return the descriptor of the field\n\n    :returns: the desciptor\n    \"\"\"\n    if self.type_idx_value is None:\n        self.type_idx_value = self.CM.get_type(self.type_idx)\n    return self.type_idx_value\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.FieldIdItem.get_name","title":"<code>get_name()</code>","text":"<p>Return the name of the field</p> <p>Returns:</p> Type Description <code>str</code> <p>the name</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_name(self) -&gt; str:\n    \"\"\"\n    Return the name of the field\n\n    :returns: the name\n    \"\"\"\n    if self.name_idx_value is None:\n        self.name_idx_value = self.CM.get_string(self.name_idx)\n    return self.name_idx_value\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.FieldIdItem.get_name_idx","title":"<code>get_name_idx()</code>","text":"<p>Return the index into the <code>string_ids</code> list for the name of this field</p> <p>Returns:</p> Type Description <code>int</code> <p>the index</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_name_idx(self) -&gt; int:\n    \"\"\"\n    Return the index into the `string_ids` list for the name of this field\n\n    :returns: the index\n    \"\"\"\n    return self.name_idx\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.FieldIdItem.get_type","title":"<code>get_type()</code>","text":"<p>Return the type of the field</p> <p>Returns:</p> Type Description <code>str</code> <p>the type</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_type(self) -&gt; str:\n    \"\"\"\n    Return the type of the field\n\n    :returns: the type\n    \"\"\"\n    if self.type_idx_value is None:\n        self.type_idx_value = self.CM.get_type(self.type_idx)\n    return self.type_idx_value\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.FieldIdItem.get_type_idx","title":"<code>get_type_idx()</code>","text":"<p>Return the index into the <code>type_ids</code> list for the type of this field</p> <p>Returns:</p> Type Description <code>int</code> <p>the index</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_type_idx(self) -&gt; int:\n    \"\"\"\n    Return the index into the `type_ids` list for the type of this field\n\n    :returns: the index\n    \"\"\"\n    return self.type_idx\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.FillArrayData","title":"<code>FillArrayData</code>","text":"<p>This class can parse a <code>FillArrayData</code> instruction</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a Buff object which represents a buffer where the instruction is stored</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class FillArrayData:\n    \"\"\"\n    This class can parse a `FillArrayData` instruction\n\n    :param buff: a Buff object which represents a buffer where the instruction is stored\n    \"\"\"\n\n    # FIXME: why is this not a subclass of Instruction?\n    def __init__(self, cm: ClassManager, buff: BinaryIO) -&gt; None:\n        self.OP = 0x0\n        self.notes = []\n        self.CM = cm\n\n        self.format_general_size = calcsize(\"2HI\")\n        self.ident, self.element_width, self.size = cm.packer[\"2HI\"].unpack(\n            buff[0:8]\n        )\n\n        buf_len = self.size * self.element_width\n        if buf_len % 2:\n            buf_len += 1\n\n        self.data = buff[\n            self.format_general_size : self.format_general_size + buf_len\n        ]\n\n    def add_note(self, msg: str) -&gt; None:\n        \"\"\"\n        Add a note to this instruction\n\n        :param msg: the message\n        \"\"\"\n        self.notes.append(msg)\n\n    def get_notes(self) -&gt; list[str]:\n        \"\"\"\n        Get all notes from this instruction\n\n        :returns: a list of string notes\n        \"\"\"\n        return self.notes\n\n    def get_op_value(self) -&gt; int:\n        \"\"\"\n        Get the value of the opcode\n\n        :returns: the value\n        \"\"\"\n        return self.ident\n\n    def get_data(self) -&gt; bytes:\n        \"\"\"\n        Return the data of this instruction (the payload)\n\n        :returns: the instruction payload bytes\n        \"\"\"\n        return self.data\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        \"\"\"\n        Return an additional output of the instruction\n\n        :returns: additional output of the instruction\n        \"\"\"\n        buff = \"\"\n\n        data = self.get_data()\n\n        buff += repr(data) + \" | \"\n        for i in range(0, len(data)):\n            buff += \"\\\\x{:02x}\".format(data[i])\n\n        return buff\n\n    def get_operands(self, idx: int=-1) -&gt; tuple[Operand, str]:\n        # FIXME: not sure of binascii is the right choice here,\n        # but before it was repr(), which lead to weird outputs of bytearrays\n        if isinstance(self.get_data(), bytearray):\n            return [\n                (\n                    Operand.RAW,\n                    binascii.hexlify(self.get_data()).decode('ascii'),\n                )\n            ]\n        else:\n            return [(Operand.RAW, repr(self.get_data()))]\n\n    def get_formatted_operands(self) -&gt; None:\n        return None\n\n    def get_name(self) -&gt; str:\n        \"\"\"\n        Return the name of the instruction\n\n        :returns: name string\n        \"\"\"\n        return \"fill-array-data-payload\"\n\n    def show_buff(self, pos: int) -&gt; str:\n        \"\"\"\n        Return the display of the instruction\n\n        :returns: display string\n        \"\"\"\n        buff = self.get_name() + \" \"\n\n        for i in range(0, len(self.data)):\n            buff += \"\\\\x%02x\" % self.data[i]\n        return buff\n\n    def show(self, pos: int) -&gt; None:\n        \"\"\"\n        Print the instruction\n\n        :param pos: the position of the instruction\n        \"\"\"\n        print(self.show_buff(pos), end=' ')\n\n    def get_length(self) -&gt; int:\n        \"\"\"\n        Return the length of the instruction\n\n        :returns: the length\n        \"\"\"\n        return ((self.size * self.element_width + 1) // 2 + 4) * 2\n\n    def get_raw(self) -&gt; bytes:\n        return (\n            self.CM.packer[\"2HI\"].pack(\n                self.ident, self.element_width, self.size\n            )\n            + self.data\n        )\n\n    def get_hex(self) -&gt; str:\n        \"\"\"\n        Returns a HEX String, separated by spaces every byte\n        \"\"\"\n        s = binascii.hexlify(self.get_raw()).decode(\"ascii\")\n        return \" \".join(s[i : i + 2] for i in range(0, len(s), 2))\n\n    def disasm(self) -&gt; str:\n        # FIXME:\n        return self.show_buff(None)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.FillArrayData.add_note","title":"<code>add_note(msg)</code>","text":"<p>Add a note to this instruction</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>the message</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def add_note(self, msg: str) -&gt; None:\n    \"\"\"\n    Add a note to this instruction\n\n    :param msg: the message\n    \"\"\"\n    self.notes.append(msg)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.FillArrayData.get_data","title":"<code>get_data()</code>","text":"<p>Return the data of this instruction (the payload)</p> <p>Returns:</p> Type Description <code>bytes</code> <p>the instruction payload bytes</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_data(self) -&gt; bytes:\n    \"\"\"\n    Return the data of this instruction (the payload)\n\n    :returns: the instruction payload bytes\n    \"\"\"\n    return self.data\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.FillArrayData.get_hex","title":"<code>get_hex()</code>","text":"<p>Returns a HEX String, separated by spaces every byte</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_hex(self) -&gt; str:\n    \"\"\"\n    Returns a HEX String, separated by spaces every byte\n    \"\"\"\n    s = binascii.hexlify(self.get_raw()).decode(\"ascii\")\n    return \" \".join(s[i : i + 2] for i in range(0, len(s), 2))\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.FillArrayData.get_length","title":"<code>get_length()</code>","text":"<p>Return the length of the instruction</p> <p>Returns:</p> Type Description <code>int</code> <p>the length</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_length(self) -&gt; int:\n    \"\"\"\n    Return the length of the instruction\n\n    :returns: the length\n    \"\"\"\n    return ((self.size * self.element_width + 1) // 2 + 4) * 2\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.FillArrayData.get_name","title":"<code>get_name()</code>","text":"<p>Return the name of the instruction</p> <p>Returns:</p> Type Description <code>str</code> <p>name string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_name(self) -&gt; str:\n    \"\"\"\n    Return the name of the instruction\n\n    :returns: name string\n    \"\"\"\n    return \"fill-array-data-payload\"\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.FillArrayData.get_notes","title":"<code>get_notes()</code>","text":"<p>Get all notes from this instruction</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>a list of string notes</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_notes(self) -&gt; list[str]:\n    \"\"\"\n    Get all notes from this instruction\n\n    :returns: a list of string notes\n    \"\"\"\n    return self.notes\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.FillArrayData.get_op_value","title":"<code>get_op_value()</code>","text":"<p>Get the value of the opcode</p> <p>Returns:</p> Type Description <code>int</code> <p>the value</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_op_value(self) -&gt; int:\n    \"\"\"\n    Get the value of the opcode\n\n    :returns: the value\n    \"\"\"\n    return self.ident\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.FillArrayData.get_output","title":"<code>get_output(idx=-1)</code>","text":"<p>Return an additional output of the instruction</p> <p>Returns:</p> Type Description <code>str</code> <p>additional output of the instruction</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_output(self, idx: int = -1) -&gt; str:\n    \"\"\"\n    Return an additional output of the instruction\n\n    :returns: additional output of the instruction\n    \"\"\"\n    buff = \"\"\n\n    data = self.get_data()\n\n    buff += repr(data) + \" | \"\n    for i in range(0, len(data)):\n        buff += \"\\\\x{:02x}\".format(data[i])\n\n    return buff\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.FillArrayData.show","title":"<code>show(pos)</code>","text":"<p>Print the instruction</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>int</code> <p>the position of the instruction</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def show(self, pos: int) -&gt; None:\n    \"\"\"\n    Print the instruction\n\n    :param pos: the position of the instruction\n    \"\"\"\n    print(self.show_buff(pos), end=' ')\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.FillArrayData.show_buff","title":"<code>show_buff(pos)</code>","text":"<p>Return the display of the instruction</p> <p>Returns:</p> Type Description <code>str</code> <p>display string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def show_buff(self, pos: int) -&gt; str:\n    \"\"\"\n    Return the display of the instruction\n\n    :returns: display string\n    \"\"\"\n    buff = self.get_name() + \" \"\n\n    for i in range(0, len(self.data)):\n        buff += \"\\\\x%02x\" % self.data[i]\n    return buff\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.HeaderItem","title":"<code>HeaderItem</code>","text":"<p>This class can parse an <code>header_item</code> of a dex file. Several checks are performed to detect if this is not an <code>header_item</code>. Also the Adler32 checksum of the file is calculated in order to detect file corruption.</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a Buff object of the <code>header_item</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if DEX file header is incorrect</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class HeaderItem:\n    \"\"\"\n    This class can parse an `header_item` of a dex file.\n    Several checks are performed to detect if this is not an `header_item`.\n    Also the Adler32 checksum of the file is calculated in order to detect file\n    corruption.\n\n    :raises ValueError: if DEX file header is incorrect\n    :param buff: a string which represents a Buff object of the `header_item`\n    :param cm: a `ClassManager` object\n    \"\"\"\n\n    def __init__(self, size, buff: BinaryIO, cm: ClassManager) -&gt; None:\n        logger.debug(\"HeaderItem\")\n\n        self.CM = cm\n\n        self.offset = buff.tell()\n\n        if self.offset != 0:\n            logger.warning(\n                \"Unusual DEX file, does not have the header at offset 0\"\n            )\n\n        if buff.raw.getbuffer().nbytes &lt; self.get_length():\n            raise ValueError(\"Not a DEX file, Header too small.\")\n\n        (self.endian_tag,) = unpack('&lt;I', read_at(buff, 40, 4))\n        cm.packer = DalvikPacker(self.endian_tag)\n\n        # Q is actually wrong, but we do not change it here and unpack our own\n        # stuff...\n        (\n            self.magic,\n            self.checksum,\n            self.signature,\n            self.file_size,\n            self.header_size,\n            endian_tag,\n            self.link_size,\n            self.link_off,\n            self.map_off,\n            self.string_ids_size,\n            self.string_ids_off,\n            self.type_ids_size,\n            self.type_ids_off,\n            self.proto_ids_size,\n            self.proto_ids_off,\n            self.field_ids_size,\n            self.field_ids_off,\n            self.method_ids_size,\n            self.method_ids_off,\n            self.class_defs_size,\n            self.class_defs_off,\n            self.data_size,\n            self.data_off,\n        ) = cm.packer['8sI20s20I'].unpack(buff.read(112))\n\n        # possible dex or dey:\n        if (\n            self.magic[:2] != b'de'\n            or self.magic[2] not in [0x78, 0x79]\n            or self.magic[3] != 0x0A\n            or self.magic[7] != 0x00\n        ):\n            raise ValueError(\n                \"This is not a DEX file! Wrong magic: {}\".format(\n                    repr(self.magic)\n                )\n            )\n\n        try:\n            self.dex_version = int(self.magic[4:7].decode('ascii'), 10)\n        except (UnicodeDecodeError, ValueError):\n            logger.warning(\n                \"Wrong DEX version: {}, trying to parse anyways\".format(\n                    repr(self.magic)\n                )\n            )\n            self.dex_version = 35  # assume a common version...\n\n        if zlib.adler32(read_at(buff, self.offset + 12)) != self.checksum:\n            raise ValueError(\"Wrong Adler32 checksum for DEX file!\")\n\n        if self.file_size != buff.raw.getbuffer().nbytes:\n            # Maybe raise an error here too...\n            logger.warning(\n                \"DEX file size is different to the buffer. Trying to parse anyways.\"\n            )\n\n        if self.header_size != 0x70:\n            raise ValueError(\n                \"This is not a DEX file! Wrong header size: '{}'\".format(\n                    self.header_size\n                )\n            )\n\n        if self.type_ids_size &gt; 65535:\n            raise ValueError(\n                \"DEX file contains too many ({}) TYPE_IDs to be valid!\".format(\n                    self.type_ids_size\n                )\n            )\n\n        if self.proto_ids_size &gt; 65535:\n            raise ValueError(\n                \"DEX file contains too many ({}) PROTO_IDs to be valid!\".format(\n                    self.proto_ids_size\n                )\n            )\n\n        if self.data_size % 4 != 0:\n            logger.warning(\n                \"data_size is not a multiple of sizeof(uint32_t), but try to parse anyways.\"\n            )\n\n        self.map_off_obj = None\n        self.string_off_obj = None\n        self.type_off_obj = None\n        self.proto_off_obj = None\n        self.field_off_obj = None\n        self.method_off_obj = None\n        self.class_off_obj = None\n        self.data_off_obj = None\n\n    def get_obj(self) -&gt; bytes:\n        if self.map_off_obj is None:\n            self.map_off_obj = self.CM.get_item_by_offset(self.map_off)\n\n        if self.string_off_obj is None:\n            self.string_off_obj = self.CM.get_item_by_offset(\n                self.string_ids_off\n            )\n\n        if self.type_off_obj is None:\n            self.type_off_obj = self.CM.get_item_by_offset(self.type_ids_off)\n\n        if self.proto_off_obj is None:\n            self.proto_off_obj = self.CM.get_item_by_offset(self.proto_ids_off)\n\n        if self.field_off_obj is None:\n            self.field_off_obj = self.CM.get_item_by_offset(self.field_ids_off)\n\n        if self.method_off_obj is None:\n            self.method_off_obj = self.CM.get_item_by_offset(\n                self.method_ids_off\n            )\n\n        if self.class_off_obj is None:\n            self.class_off_obj = self.CM.get_item_by_offset(\n                self.class_defs_off\n            )\n\n        if self.data_off_obj is None:\n            self.data_off_obj = self.CM.get_item_by_offset(self.data_off)\n\n        # FIXME: has no object map_off_obj!\n        self.map_off = self.map_off_obj.get_off()\n\n        self.string_ids_size = len(self.string_off_obj)\n        self.string_ids_off = self.string_off_obj[0].get_off()\n\n        self.type_ids_size = len(self.type_off_obj.type)\n        self.type_ids_off = self.type_off_obj.get_off()\n\n        self.proto_ids_size = len(self.proto_off_obj.proto)\n        self.proto_ids_off = self.proto_off_obj.get_off()\n\n        self.field_ids_size = len(self.field_off_obj.elem)\n        self.field_ids_off = self.field_off_obj.get_off()\n\n        self.method_ids_size = len(self.method_off_obj.methods)\n        self.method_ids_off = self.method_off_obj.get_off()\n\n        self.class_defs_size = len(self.class_off_obj.class_def)\n        self.class_defs_off = self.class_off_obj.get_off()\n\n        # FIXME: data_off_obj has no map_item!!!\n        self.data_size = len(self.data_off_obj.map_item)\n        self.data_off = self.data_off_obj.get_off()\n\n        return (\n            pack(\"&lt;Q\", self.magic)\n            + pack(\"&lt;I\", self.checksum)\n            + pack(\"&lt;20s\", self.signature)\n            + pack(\"&lt;I\", self.file_size)\n            + pack(\"&lt;I\", self.header_size)\n            + pack(\"&lt;I\", self.endian_tag)\n            + pack(\"&lt;I\", self.link_size)\n            + pack(\"&lt;I\", self.link_off)\n            + pack(\"&lt;I\", self.map_off)\n            + pack(\"&lt;I\", self.string_ids_size)\n            + pack(\"&lt;I\", self.string_ids_off)\n            + pack(\"&lt;I\", self.type_ids_size)\n            + pack(\"&lt;I\", self.type_ids_off)\n            + pack(\"&lt;I\", self.proto_ids_size)\n            + pack(\"&lt;I\", self.proto_ids_off)\n            + pack(\"&lt;I\", self.field_ids_size)\n            + pack(\"&lt;I\", self.field_ids_off)\n            + pack(\"&lt;I\", self.method_ids_size)\n            + pack(\"&lt;I\", self.method_ids_off)\n            + pack(\"&lt;I\", self.class_defs_size)\n            + pack(\"&lt;I\", self.class_defs_off)\n            + pack(\"&lt;I\", self.data_size)\n            + pack(\"&lt;I\", self.data_off)\n        )\n\n    def get_raw(self) -&gt; bytes:\n        return self.get_obj()\n\n    def get_length(self) -&gt; int:\n        return 112\n\n    def show(self) -&gt; None:\n        bytecode._PrintSubBanner(\"Header Item\")\n        bytecode._PrintDefault(\n            \"magic=%s, checksum=%s, signature=%s\\n\"\n            % (\n                self.magic,\n                self.checksum,\n                binascii.hexlify(self.signature).decode(\"ASCII\"),\n            )\n        )\n        bytecode._PrintDefault(\n            \"file_size=%x, header_size=%x, endian_tag=%x\\n\"\n            % (self.file_size, self.header_size, self.endian_tag)\n        )\n        bytecode._PrintDefault(\n            \"link_size=%x, link_off=%x\\n\" % (self.link_size, self.link_off)\n        )\n        bytecode._PrintDefault(\"map_off=%x\\n\" % self.map_off)\n        bytecode._PrintDefault(\n            \"string_ids_size=%x, string_ids_off=%x\\n\"\n            % (self.string_ids_size, self.string_ids_off)\n        )\n        bytecode._PrintDefault(\n            \"type_ids_size=%x, type_ids_off=%x\\n\"\n            % (self.type_ids_size, self.type_ids_off)\n        )\n        bytecode._PrintDefault(\n            \"proto_ids_size=%x, proto_ids_off=%x\\n\"\n            % (self.proto_ids_size, self.proto_ids_off)\n        )\n        bytecode._PrintDefault(\n            \"field_ids_size=%x, field_ids_off=%x\\n\"\n            % (self.field_ids_size, self.field_ids_off)\n        )\n        bytecode._PrintDefault(\n            \"method_ids_size=%x, method_ids_off=%x\\n\"\n            % (self.method_ids_size, self.method_ids_off)\n        )\n        bytecode._PrintDefault(\n            \"class_defs_size=%x, class_defs_off=%x\\n\"\n            % (self.class_defs_size, self.class_defs_off)\n        )\n        bytecode._PrintDefault(\n            \"data_size=%x, data_off=%x\\n\" % (self.data_size, self.data_off)\n        )\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __str__(self):\n        return (\n            \"Header Item magic={}, checksum={}, signature={} file_size={:X}, header_size={:X}, endian_tag={:X},\"\n            \"link_size={:X}, link_off={:X}, map_off={:X}, string_ids_size={:X}, string_ids_off={:X},  \"\n            \"type_ids_size={:X}, type_ids_off={:X}, proto_ids_size={:X}, proto_ids_off={:X}, \"\n            \"field_ids_size={:X}, field_ids_off={:X}, method_ids_size={:X}, method_ids_off={:X}, \"\n            \"class_defs_size={:X}, class_defs_off={:X}, data_size={:X}, data_off={:X}\".format(\n                self.magic,\n                self.checksum,\n                binascii.hexlify(self.signature).decode(\"ASCII\"),\n                self.file_size,\n                self.header_size,\n                self.endian_tag,\n                self.link_size,\n                self.link_off,\n                self.map_off,\n                self.string_ids_size,\n                self.string_ids_off,\n                self.type_ids_size,\n                self.type_ids_off,\n                self.proto_ids_size,\n                self.proto_ids_off,\n                self.field_ids_size,\n                self.field_ids_off,\n                self.method_ids_size,\n                self.method_ids_off,\n                self.class_defs_size,\n                self.class_defs_off,\n                self.data_size,\n                self.data_off,\n            )\n        )\n\n    def set_off(self, off: int) -&gt; None:\n        self.offset = off\n\n    def get_off(self) -&gt; int:\n        return self.offset\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.HiddenApiClassDataItem","title":"<code>HiddenApiClassDataItem</code>","text":"<p>This class can parse an <code>hiddenapi_class_data_item</code> of a dex file (from Android 10 dex version 039)</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a Buff object of the <code>hiddenapi_class_data_item</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class HiddenApiClassDataItem:\n    \"\"\"\n    This class can parse an `hiddenapi_class_data_item` of a dex file (from Android 10 dex version 039)\n\n    :param buff: a string which represents a Buff object of the `hiddenapi_class_data_item`\n    :param cm: a `ClassManager` object\n    \"\"\"\n\n    class RestrictionApiFlag(IntEnum):\n        WHITELIST = 0\n        GREYLIST = 1\n        BLACKLIST = 2\n        GREYLIST_MAX_O = 3\n        GREYLIST_MAX_P = 4\n        GREYLIST_MAX_Q = 5\n        GREYLIST_MAX_R = 6\n\n    class DomapiApiFlag(IntEnum):\n        NONE = 0\n        CORE_PLATFORM_API = 1\n        TEST_API = 2\n\n    def __init__(self, buff: BinaryIO, cm: ClassManager) -&gt; None:\n        self.CM = cm\n\n        self.offset = buff.tell()\n\n        (self.section_size,) = cm.packer[\"I\"].unpack(buff.read(4))\n\n        # Find the end of the offsets array (first non-zero offset entry is the start of `flags`)\n        offsets_size = 0\n        i = 0\n        while buff.tell() - self.offset &lt; self.section_size:\n            if offsets_size != 0 and i &gt;= offsets_size:\n                break\n            (offset,) = cm.packer[\"I\"].unpack(buff.read(4))\n            if offset != 0 and offsets_size == 0:\n                offsets_size = (offset - 4) // 4\n            i += 1\n\n        self.flags = []\n        for i in range(offsets_size):\n            flag = readuleb128(cm, buff)\n            self.flags.append(\n                (\n                    self.RestrictionApiFlag(flag &amp; 0b111),\n                    self.DomapiApiFlag(flag &gt;&gt; 3),\n                )\n            )\n\n    def get_section_size(self):\n        \"\"\"\n        Return the total size of this section\n\n        :returns: the total size\n        \"\"\"\n        return self.section_size\n\n    def get_flags(self, idx) -&gt; tuple[RestrictionApiFlag, DomapiApiFlag]:\n        \"\"\"\n        Return a tuple of the flags per class\n\n        :param idx: The index to return the flags of (index of the class)\n\n        :returns: tuple of `RestrictionApiFlag`, `DomapiApiFlag`\n        \"\"\"\n        return self.flags[idx]\n\n    def set_off(self, off: int):\n        self.offset = off\n\n    def get_off(self):\n        return self.offset\n\n    def show(self):\n        bytecode._PrintSubBanner(\"HiddenApi Class Data Item\")\n        bytecode._PrintDefault(\"section_size=0x%x\\n\" % (self.section_size,))\n\n        for i, (rf, df) in enumerate(self.flags):\n            bytecode._PrintDefault(\"[%u] %s, %s\\n\" % (i, rf, df))\n\n    def get_obj(self):\n        base = 4 + len(self.flags)\n        raw_offsets = b''\n        raw_flags = b''\n        for rf, df in self.flags:\n            raw_offsets += self.CM.packer[\"I\"].pack(base + len(raw_flags))\n            raw_flags += writeuleb128(self.CM, (df.value &lt;&lt; 3) | rf.value)\n\n        return (\n            self.CM.packer[\"I\"].pack(self.section_size)\n            + raw_offsets\n            + raw_flags\n        )\n\n    def get_raw(self):\n        return self.get_obj()\n\n    def get_length(self):\n        return self.section_size\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.HiddenApiClassDataItem.get_flags","title":"<code>get_flags(idx)</code>","text":"<p>Return a tuple of the flags per class</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <p>The index to return the flags of (index of the class)</p> required <p>Returns:</p> Type Description <code>tuple[RestrictionApiFlag, DomapiApiFlag]</code> <p>tuple of <code>RestrictionApiFlag</code>, <code>DomapiApiFlag</code></p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_flags(self, idx) -&gt; tuple[RestrictionApiFlag, DomapiApiFlag]:\n    \"\"\"\n    Return a tuple of the flags per class\n\n    :param idx: The index to return the flags of (index of the class)\n\n    :returns: tuple of `RestrictionApiFlag`, `DomapiApiFlag`\n    \"\"\"\n    return self.flags[idx]\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.HiddenApiClassDataItem.get_section_size","title":"<code>get_section_size()</code>","text":"<p>Return the total size of this section</p> <p>Returns:</p> Type Description <p>the total size</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_section_size(self):\n    \"\"\"\n    Return the total size of this section\n\n    :returns: the total size\n    \"\"\"\n    return self.section_size\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction","title":"<code>Instruction</code>","text":"<p>This class represents a Dalvik instruction</p> <p>It can both handle normal instructions as well as optimized instructions.</p> <p>WARNING: There is not much documentation about the optimized opcodes! Hence, it relies on reverese engineered specification!</p> <p>More information about the instruction format can be found in the official documentation: https://source.android.com/devices/tech/dalvik/instruction-formats.html</p> <p>WARNING: Values stored in the instructions are already interpreted at this stage.</p> <p>The Dalvik VM has a eight opcodes to create constant integer values. There are four variants for 32bit values and four for 64bit. If floating point numbers are required, you have to use the conversion opcodes like <code>int-to-float</code>, <code>int-to-double</code> or the variants using <code>long</code>.</p> <p>Androguard will always show the values as they are used in the opcode and also extend signs and shift values! As an example: The opcode <code>const/high16</code> can be used to create constant values where the lower 16 bits are all zero. In this case, androguard will process bytecode <code>15 00 CD AB</code> as beeing <code>const/high16 v0, 0xABCD0000</code>. For the sign-extension, nothing is really done here, as it only affects the bit represenation in the virtual machine. As androguard parses the values and uses python types internally, we are not bound to specific size.</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction:\n    \"\"\"\n    This class represents a Dalvik instruction\n\n    It can both handle normal instructions as well as optimized instructions.\n\n    WARNING: There is not much documentation about the optimized opcodes! Hence, it relies on reverese engineered specification!\n\n    More information about the instruction format can be found in the official documentation:\n    https://source.android.com/devices/tech/dalvik/instruction-formats.html\n\n    WARNING: Values stored in the instructions are already interpreted at this stage.\n\n    The Dalvik VM has a eight opcodes to create constant integer values.\n    There are four variants for 32bit values and four for 64bit.\n    If floating point numbers are required, you have to use the conversion opcodes\n    like `int-to-float`, `int-to-double` or the variants using `long`.\n\n    Androguard will always show the values as they are used in the opcode and also extend signs\n    and shift values!\n    As an example: The opcode `const/high16` can be used to create constant values\n    where the lower 16 bits are all zero.\n    In this case, androguard will process bytecode `15 00 CD AB` as beeing\n    `const/high16 v0, 0xABCD0000`.\n    For the sign-extension, nothing is really done here, as it only affects the bit represenation\n    in the virtual machine. As androguard parses the values and uses python types internally,\n    we are not bound to specific size.\n    \"\"\"\n\n    length = 0\n    OP = 0\n\n    def get_kind(self) -&gt; int:\n        \"\"\"\n        Return the 'kind' argument of the instruction\n\n        This is the type of the argument, i.e. in which kind of table you have\n        to look up the argument in the `ClassManager`\n\n        :returns: the kind\n        \"\"\"\n        if self.OP &gt;= 0xF2FF:\n            return DALVIK_OPCODES_OPTIMIZED[self.OP][1][1]\n        return DALVIK_OPCODES_FORMAT[self.OP][1][1]\n\n    def get_name(self) -&gt; str:\n        \"\"\"\n        Return the mnemonic of the instruction\n\n        :returns: the mnemonic\n        \"\"\"\n        if self.OP &gt;= 0xF2FF:\n            return DALVIK_OPCODES_OPTIMIZED[self.OP][1][0]\n        return DALVIK_OPCODES_FORMAT[self.OP][1][0]\n\n    def get_op_value(self) -&gt; int:\n        \"\"\"\n        Return the numerical value of the opcode\n\n        :returns: the numerical opcode\n        \"\"\"\n        return self.OP\n\n    def get_literals(self) -&gt; list:\n        \"\"\"\n        Not Implemented\n\n        Return the associated literals\n\n        :returns: list of int\n        \"\"\"\n        return []\n\n    def show(self, idx: int) -&gt; None:\n        \"\"\"\n        Print the instruction\n\n        No Line ending is printed.\n        \"\"\"\n        print(self.get_name() + \" \" + self.get_output(idx), end=' ')\n\n    def show_buff(self, idx: int) -&gt; str:\n        \"\"\"\n        Return the display of the instruction\n\n        :returns: the display of the instruction\n        \"\"\"\n        return self.get_output(idx)\n\n    def get_translated_kind(self) -&gt; str:\n        \"\"\"\n        Return the translated value of the 'kind' argument\n\n        :returns: the translated value\n        \"\"\"\n        return get_kind(self.cm, self.get_kind(), self.get_ref_kind())\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        \"\"\"\n        Not Implemented\n\n        Return an additional output of the instruction\n\n        :returns: the additional output as a string\n        \"\"\"\n        return \"\"\n\n    def get_operands(self, idx:int=-1) -&gt; list[tuple[Operand, object]]:\n        \"\"\"\n        Not Implemented\n\n        Return all operands\n\n        This will return a list of tuples, containing the Enum [Operand][androguard.core.dex.dex_types.Operand]\n        at the first position and the objects afterwards.\n\n        :returns: List[Tuple(Operand, object, ...)]\n        \"\"\"\n        return []\n\n    def get_length(self) -&gt; int:\n        \"\"\"\n        Return the length of the instruction in bytes\n\n        :returns: the length\n        \"\"\"\n        return self.length\n\n    def get_raw(self):\n        \"\"\"\n        Return the object in a raw format\n\n        :returns: the raw format\n        \"\"\"\n        raise Exception(\"not implemented\")\n\n    def get_ref_kind(self):\n        \"\"\"\n        Return the value of the 'kind' argument\n\n        :returns: value\n        \"\"\"\n        raise Exception(\"not implemented\")\n\n    def get_hex(self) -&gt; str:\n        \"\"\"\n        Returns a HEX String, separated by spaces every byte\n\n        The hex string contains the raw bytes of the instruction,\n        including the opcode and all arguments.\n\n        :returns: the hex string\n        \"\"\"\n        s = binascii.hexlify(self.get_raw()).decode('ascii')\n        return \" \".join(s[i : i + 2] for i in range(0, len(s), 2))\n\n    def __str__(self):\n        return \"{} {}\".format(self.get_name(), self.get_output())\n\n    # FIXME Better name\n    def disasm(self) -&gt; str:\n        \"\"\"Some small line for disassembly view\"\"\"\n        s = binascii.hexlify(self.get_raw()).decode('ascii')\n        byteview = \" \".join(s[i : i + 4] for i in range(0, len(s), 4))\n        return '{:24s}  {:24s} {}'.format(\n            byteview, self.get_name(), self.get_output()\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction.disasm","title":"<code>disasm()</code>","text":"<p>Some small line for disassembly view</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def disasm(self) -&gt; str:\n    \"\"\"Some small line for disassembly view\"\"\"\n    s = binascii.hexlify(self.get_raw()).decode('ascii')\n    byteview = \" \".join(s[i : i + 4] for i in range(0, len(s), 4))\n    return '{:24s}  {:24s} {}'.format(\n        byteview, self.get_name(), self.get_output()\n    )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction.get_hex","title":"<code>get_hex()</code>","text":"<p>Returns a HEX String, separated by spaces every byte</p> <p>The hex string contains the raw bytes of the instruction, including the opcode and all arguments.</p> <p>Returns:</p> Type Description <code>str</code> <p>the hex string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_hex(self) -&gt; str:\n    \"\"\"\n    Returns a HEX String, separated by spaces every byte\n\n    The hex string contains the raw bytes of the instruction,\n    including the opcode and all arguments.\n\n    :returns: the hex string\n    \"\"\"\n    s = binascii.hexlify(self.get_raw()).decode('ascii')\n    return \" \".join(s[i : i + 2] for i in range(0, len(s), 2))\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction.get_kind","title":"<code>get_kind()</code>","text":"<p>Return the 'kind' argument of the instruction</p> <p>This is the type of the argument, i.e. in which kind of table you have to look up the argument in the <code>ClassManager</code></p> <p>Returns:</p> Type Description <code>int</code> <p>the kind</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_kind(self) -&gt; int:\n    \"\"\"\n    Return the 'kind' argument of the instruction\n\n    This is the type of the argument, i.e. in which kind of table you have\n    to look up the argument in the `ClassManager`\n\n    :returns: the kind\n    \"\"\"\n    if self.OP &gt;= 0xF2FF:\n        return DALVIK_OPCODES_OPTIMIZED[self.OP][1][1]\n    return DALVIK_OPCODES_FORMAT[self.OP][1][1]\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction.get_length","title":"<code>get_length()</code>","text":"<p>Return the length of the instruction in bytes</p> <p>Returns:</p> Type Description <code>int</code> <p>the length</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_length(self) -&gt; int:\n    \"\"\"\n    Return the length of the instruction in bytes\n\n    :returns: the length\n    \"\"\"\n    return self.length\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction.get_literals","title":"<code>get_literals()</code>","text":"<p>Not Implemented</p> <p>Return the associated literals</p> <p>Returns:</p> Type Description <code>list</code> <p>list of int</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_literals(self) -&gt; list:\n    \"\"\"\n    Not Implemented\n\n    Return the associated literals\n\n    :returns: list of int\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction.get_name","title":"<code>get_name()</code>","text":"<p>Return the mnemonic of the instruction</p> <p>Returns:</p> Type Description <code>str</code> <p>the mnemonic</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_name(self) -&gt; str:\n    \"\"\"\n    Return the mnemonic of the instruction\n\n    :returns: the mnemonic\n    \"\"\"\n    if self.OP &gt;= 0xF2FF:\n        return DALVIK_OPCODES_OPTIMIZED[self.OP][1][0]\n    return DALVIK_OPCODES_FORMAT[self.OP][1][0]\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction.get_op_value","title":"<code>get_op_value()</code>","text":"<p>Return the numerical value of the opcode</p> <p>Returns:</p> Type Description <code>int</code> <p>the numerical opcode</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_op_value(self) -&gt; int:\n    \"\"\"\n    Return the numerical value of the opcode\n\n    :returns: the numerical opcode\n    \"\"\"\n    return self.OP\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction.get_operands","title":"<code>get_operands(idx=-1)</code>","text":"<p>Not Implemented</p> <p>Return all operands</p> <p>This will return a list of tuples, containing the Enum Operand at the first position and the objects afterwards.</p> <p>Returns:</p> Type Description <code>list[tuple[Operand, object]]</code> <p>List[Tuple(Operand, object, ...)]</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_operands(self, idx:int=-1) -&gt; list[tuple[Operand, object]]:\n    \"\"\"\n    Not Implemented\n\n    Return all operands\n\n    This will return a list of tuples, containing the Enum [Operand][androguard.core.dex.dex_types.Operand]\n    at the first position and the objects afterwards.\n\n    :returns: List[Tuple(Operand, object, ...)]\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction.get_output","title":"<code>get_output(idx=-1)</code>","text":"<p>Not Implemented</p> <p>Return an additional output of the instruction</p> <p>Returns:</p> Type Description <code>str</code> <p>the additional output as a string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_output(self, idx: int = -1) -&gt; str:\n    \"\"\"\n    Not Implemented\n\n    Return an additional output of the instruction\n\n    :returns: the additional output as a string\n    \"\"\"\n    return \"\"\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction.get_raw","title":"<code>get_raw()</code>","text":"<p>Return the object in a raw format</p> <p>Returns:</p> Type Description <p>the raw format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_raw(self):\n    \"\"\"\n    Return the object in a raw format\n\n    :returns: the raw format\n    \"\"\"\n    raise Exception(\"not implemented\")\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction.get_ref_kind","title":"<code>get_ref_kind()</code>","text":"<p>Return the value of the 'kind' argument</p> <p>Returns:</p> Type Description <p>value</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_ref_kind(self):\n    \"\"\"\n    Return the value of the 'kind' argument\n\n    :returns: value\n    \"\"\"\n    raise Exception(\"not implemented\")\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction.get_translated_kind","title":"<code>get_translated_kind()</code>","text":"<p>Return the translated value of the 'kind' argument</p> <p>Returns:</p> Type Description <code>str</code> <p>the translated value</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_translated_kind(self) -&gt; str:\n    \"\"\"\n    Return the translated value of the 'kind' argument\n\n    :returns: the translated value\n    \"\"\"\n    return get_kind(self.cm, self.get_kind(), self.get_ref_kind())\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction.show","title":"<code>show(idx)</code>","text":"<p>Print the instruction</p> <p>No Line ending is printed.</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def show(self, idx: int) -&gt; None:\n    \"\"\"\n    Print the instruction\n\n    No Line ending is printed.\n    \"\"\"\n    print(self.get_name() + \" \" + self.get_output(idx), end=' ')\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction.show_buff","title":"<code>show_buff(idx)</code>","text":"<p>Return the display of the instruction</p> <p>Returns:</p> Type Description <code>str</code> <p>the display of the instruction</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def show_buff(self, idx: int) -&gt; str:\n    \"\"\"\n    Return the display of the instruction\n\n    :returns: the display of the instruction\n    \"\"\"\n    return self.get_output(idx)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction00x","title":"<code>Instruction00x</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>A class for unused instructions, has zero length and raises an error on initialization</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction00x(Instruction):\n    \"\"\"A class for unused instructions, has zero length and raises an error on initialization\"\"\"\n\n    length = 0\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        raise InvalidInstruction(\n            \"Instruction with opcode '0x{:02x}' is unused! This looks like invalid bytecode.\".format(\n                buff[0]\n            )\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction10t","title":"<code>Instruction10t</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 10t format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction10t(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 10t format\n    \"\"\"\n\n    length = 2\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        self.OP, self.AA = cm.packer[\"Bb\"].unpack(buff[: self.length])\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        # Offset is given in 16bit units\n        return \"{:+02x}h\".format(self.AA)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        return [(Operand.OFFSET, self.AA)]\n\n    def get_ref_off(self) -&gt; int:\n        return self.AA\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"Bb\"].pack(self.OP, self.AA)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction10x","title":"<code>Instruction10x</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 10x format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction10x(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 10x format\n    \"\"\"\n\n    length = 2\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        self.OP, padding = cm.packer[\"BB\"].unpack(buff[: self.length])\n        if padding != 0:\n            raise InvalidInstruction(\n                'High byte of opcode with format 10x must be zero!'\n            )\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"H\"].pack(self.OP)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction11n","title":"<code>Instruction11n</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 11n format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction11n(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 11n format\n    \"\"\"\n\n    length = 2\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        self.OP, i8 = cm.packer[\"Bb\"].unpack(buff[: self.length])\n        self.A = i8 &amp; 0xF\n        # Sign extension not required\n        self.B = i8 &gt;&gt; 4\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        return \"v{}, {}\".format(self.A, self.B)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        return [(Operand.REGISTER, self.A), (Operand.LITERAL, self.B)]\n\n    def get_literals(self) -&gt; list[int]:\n        return [self.B]\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"h\"].pack(\n            (self.B &lt;&lt; 12) | (self.A &lt;&lt; 8) | self.OP\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction11x","title":"<code>Instruction11x</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 11x format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction11x(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 11x format\n    \"\"\"\n\n    length = 2\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        self.OP, self.AA = cm.packer[\"BB\"].unpack(buff[: self.length])\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        return \"v{}\".format(self.AA)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        return [(Operand.REGISTER, self.AA)]\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"H\"].pack((self.AA &lt;&lt; 8) | self.OP)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction12x","title":"<code>Instruction12x</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 12x format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction12x(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 12x format\n    \"\"\"\n\n    length = 2\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        (i16,) = cm.packer[\"h\"].unpack(buff[: self.length])\n        self.OP = i16 &amp; 0xFF\n        self.A = (i16 &gt;&gt; 8) &amp; 0xF\n        self.B = (i16 &gt;&gt; 12) &amp; 0xF\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        return \"v{}, v{}\".format(self.A, self.B)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        return [(Operand.REGISTER, self.A), (Operand.REGISTER, self.B)]\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"H\"].pack(\n            (self.B &lt;&lt; 12) | (self.A &lt;&lt; 8) | self.OP\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction20bc","title":"<code>Instruction20bc</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 20bc format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction20bc(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 20bc format\n    \"\"\"\n\n    length = 4\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        self.OP, self.AA, self.BBBB = cm.packer[\"BBH\"].unpack(\n            buff[: self.length]\n        )\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        return \"{}, {}\".format(self.AA, self.BBBB)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        return [(Operand.LITERAL, self.AA), (Operand.LITERAL, self.BBBB)]\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"2H\"].pack((self.AA &lt;&lt; 8) | self.OP, self.BBBB)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction20t","title":"<code>Instruction20t</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 20t format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction20t(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 20t format\n    \"\"\"\n\n    length = 4\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        self.OP, padding, self.AAAA = cm.packer[\"BBh\"].unpack(\n            buff[: self.length]\n        )\n        if padding != 0:\n            raise InvalidInstruction(\n                'High byte of opcode with format 20t must be zero!'\n            )\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        # Offset is in 16bit units\n        return \"{:+04x}h\".format(self.AAAA)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        return [(Operand.OFFSET, self.AAAA)]\n\n    def get_ref_off(self) -&gt; int:\n        return self.AAAA\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"Hh\"].pack(self.OP, self.AAAA)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction21c","title":"<code>Instruction21c</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 21c format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction21c(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 21c format\n    \"\"\"\n\n    length = 4\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n        self.OP, self.AA, self.BBBB = cm.packer[\"BBH\"].unpack(\n            buff[: self.length]\n        )\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        kind = get_kind(self.cm, self.get_kind(), self.BBBB)\n        if self.get_kind() == Kind.STRING:\n            kind = '\"{}\"'.format(kind)\n        return \"v{}, {}\".format(self.AA, kind)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int, int]]:\n        kind = get_kind(self.cm, self.get_kind(), self.BBBB)\n        return [\n            (Operand.REGISTER, self.AA),\n            (self.get_kind() + Operand.KIND, self.BBBB, kind),\n        ]\n\n    def get_ref_kind(self) -&gt; int:\n        return self.BBBB\n\n    def get_string(self) -&gt; str:\n        return get_kind(self.cm, self.get_kind(), self.BBBB)\n\n    def get_raw_string(self) -&gt; str:\n        return get_kind(self.cm, Kind.RAW_STRING, self.BBBB)\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"2H\"].pack((self.AA &lt;&lt; 8) | self.OP, self.BBBB)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction21h","title":"<code>Instruction21h</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 21h format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction21h(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 21h format\n    \"\"\"\n\n    length = 4\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        self.OP, self.AA, self.__BBBB = cm.packer[\"BBh\"].unpack(\n            buff[: self.length]\n        )\n\n        if self.OP == 0x15:\n            # OP 0x15: int16_t -&gt; int32_t\n            self.BBBB = self.__BBBB &lt;&lt; 16\n        elif self.OP == 0x19:\n            # OP 0x19: int16_t -&gt; int64_t\n            self.BBBB = self.__BBBB &lt;&lt; 48\n        else:\n            # Unknown opcode?\n            self.BBBB = self.__BBBB\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        return \"v{}, {}\".format(self.AA, self.BBBB)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        return [(Operand.REGISTER, self.AA), (Operand.LITERAL, self.BBBB)]\n\n    def get_literals(self) -&gt; list[int]:\n        return [self.BBBB]\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"Hh\"].pack((self.AA &lt;&lt; 8) | self.OP, self.__BBBB)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction21s","title":"<code>Instruction21s</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 21s format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction21s(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 21s format\n    \"\"\"\n\n    length = 4\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; bytes:\n        super().__init__()\n        self.cm = cm\n\n        # BBBB is a signed int (16bit)\n        self.OP, self.AA, self.BBBB = self.cm.packer[\"BBh\"].unpack(\n            buff[: self.length]\n        )\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        return \"v{}, {}\".format(self.AA, self.BBBB)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        return [(Operand.REGISTER, self.AA), (Operand.LITERAL, self.BBBB)]\n\n    def get_literals(self) -&gt; list[int]:\n        return [self.BBBB]\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"BBh\"].pack(self.OP, self.AA, self.BBBB)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction21t","title":"<code>Instruction21t</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 21t format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction21t(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 21t format\n    \"\"\"\n\n    length = 4\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        self.OP, self.AA, self.BBBB = cm.packer[\"BBh\"].unpack(\n            buff[: self.length]\n        )\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        return \"v{}, {:+04x}h\".format(self.AA, self.BBBB)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        return [(Operand.REGISTER, self.AA), (Operand.OFFSET, self.BBBB)]\n\n    def get_ref_off(self) -&gt; int:\n        return self.BBBB\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"Hh\"].pack((self.AA &lt;&lt; 8) | self.OP, self.BBBB)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction22b","title":"<code>Instruction22b</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 22b format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction22b(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 22b format\n    \"\"\"\n\n    length = 4\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        self.OP, self.AA, self.BB, self.CC = cm.packer[\"BBBb\"].unpack(\n            buff[: self.length]\n        )\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        return \"v{}, v{}, {}\".format(self.AA, self.BB, self.CC)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        return [\n            (Operand.REGISTER, self.AA),\n            (Operand.REGISTER, self.BB),\n            (Operand.LITERAL, self.CC),\n        ]\n\n    def get_literals(self) -&gt; list[int]:\n        return [self.CC]\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"Hh\"].pack(\n            (self.AA &lt;&lt; 8) | self.OP, (self.CC &lt;&lt; 8) | self.BB\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction22c","title":"<code>Instruction22c</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 22c format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction22c(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 22c format\n    \"\"\"\n\n    length = 4\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        i16, self.CCCC = cm.packer[\"2H\"].unpack(buff[: self.length])\n        self.OP = i16 &amp; 0xFF\n        self.A = (i16 &gt;&gt; 8) &amp; 0xF\n        self.B = (i16 &gt;&gt; 12) &amp; 0xF\n\n    def get_output(self, idx: int = -1):\n        kind = get_kind(self.cm, self.get_kind(), self.CCCC)\n        return \"v{}, v{}, {}\".format(self.A, self.B, kind)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        kind = get_kind(self.cm, self.get_kind(), self.CCCC)\n        return [\n            (Operand.REGISTER, self.A),\n            (Operand.REGISTER, self.B),\n            (self.get_kind() + Operand.KIND, self.CCCC, kind),\n        ]\n\n    def get_ref_kind(self) -&gt; int:\n        return self.CCCC\n\n    def get_raw(self) -&gt; int:\n        return self.cm.packer[\"2H\"].pack(\n            (self.B &lt;&lt; 12) | (self.A &lt;&lt; 8) | self.OP, self.CCCC\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction22cs","title":"<code>Instruction22cs</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 22cs format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction22cs(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 22cs format\n    \"\"\"\n\n    length = 4\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; str:\n        super().__init__()\n        self.cm = cm\n\n        i16, self.CCCC = cm.packer[\"2H\"].unpack(buff[: self.length])\n        self.OP = i16 &amp; 0xFF\n        self.A = (i16 &gt;&gt; 8) &amp; 0xF\n        self.B = (i16 &gt;&gt; 12) &amp; 0xF\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        kind = get_kind(self.cm, self.get_kind(), self.CCCC)\n        return \"v{}, v{}, {}\".format(self.A, self.B, kind)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        kind = get_kind(self.cm, self.get_kind(), self.CCCC)\n        return [\n            (Operand.REGISTER, self.A),\n            (Operand.REGISTER, self.B),\n            (self.get_kind() + Operand.KIND, self.CCCC, kind),\n        ]\n\n    def get_ref_kind(self) -&gt; int:\n        return self.CCCC\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"2H\"].pack(\n            (self.B &lt;&lt; 12) | (self.A &lt;&lt; 8) | self.OP, self.CCCC\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction22s","title":"<code>Instruction22s</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 22s format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction22s(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 22s format\n    \"\"\"\n\n    length = 4\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        i16, self.CCCC = cm.packer[\"Hh\"].unpack(buff[: self.length])\n        self.OP = i16 &amp; 0xFF\n        self.A = (i16 &gt;&gt; 8) &amp; 0xF\n        self.B = (i16 &gt;&gt; 12) &amp; 0xF\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        return \"v{}, v{}, {}\".format(self.A, self.B, self.CCCC)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        return [\n            (Operand.REGISTER, self.A),\n            (Operand.REGISTER, self.B),\n            (Operand.LITERAL, self.CCCC),\n        ]\n\n    def get_literals(self) -&gt; list[int]:\n        return [self.CCCC]\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"Hh\"].pack(\n            (self.B &lt;&lt; 12) | (self.A &lt;&lt; 8) | self.OP, self.CCCC\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction22t","title":"<code>Instruction22t</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 22t format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction22t(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 22t format\n    \"\"\"\n\n    length = 4\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        i16, self.CCCC = cm.packer[\"Hh\"].unpack(buff[: self.length])\n        self.OP = i16 &amp; 0xFF\n        self.A = (i16 &gt;&gt; 8) &amp; 0xF\n        self.B = (i16 &gt;&gt; 12) &amp; 0xF\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        return \"v{}, v{}, {:+04x}h\".format(self.A, self.B, self.CCCC)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        return [\n            (Operand.REGISTER, self.A),\n            (Operand.REGISTER, self.B),\n            (Operand.OFFSET, self.CCCC),\n        ]\n\n    def get_ref_off(self) -&gt; int:\n        return self.CCCC\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"Hh\"].pack(\n            (self.B &lt;&lt; 12) | (self.A &lt;&lt; 8) | self.OP, self.CCCC\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction22x","title":"<code>Instruction22x</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 22x format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction22x(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 22x format\n    \"\"\"\n\n    length = 4\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        self.OP, self.AA, self.BBBB = cm.packer[\"BBH\"].unpack(\n            buff[: self.length]\n        )\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        return \"v{}, v{}\".format(self.AA, self.BBBB)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        return [(Operand.REGISTER, self.AA), (Operand.REGISTER, self.BBBB)]\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"2H\"].pack((self.AA &lt;&lt; 8) | self.OP, self.BBBB)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction23x","title":"<code>Instruction23x</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 23x format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction23x(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 23x format\n    \"\"\"\n\n    length = 4\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        self.OP, self.AA, self.BB, self.CC = cm.packer[\"BBBB\"].unpack(\n            buff[: self.length]\n        )\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        return \"v{}, v{}, v{}\".format(self.AA, self.BB, self.CC)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        return [\n            (Operand.REGISTER, self.AA),\n            (Operand.REGISTER, self.BB),\n            (Operand.REGISTER, self.CC),\n        ]\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"2H\"].pack(\n            (self.AA &lt;&lt; 8) | self.OP, (self.CC &lt;&lt; 8) | self.BB\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction30t","title":"<code>Instruction30t</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 30t format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction30t(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 30t format\n    \"\"\"\n\n    length = 6\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        self.OP, padding, self.AAAAAAAA = cm.packer[\"BBi\"].unpack(\n            buff[: self.length]\n        )\n        if padding != 0:\n            raise InvalidInstruction(\n                'High byte of opcode with format 30t must be zero!'\n            )\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        return \"{:+08x}h\".format(self.AAAAAAAA)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        return [(Operand.OFFSET, self.AAAAAAAA)]\n\n    def get_ref_off(self) -&gt; int:\n        return self.AAAAAAAA\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"Hi\"].pack(self.OP, self.AAAAAAAA)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction31c","title":"<code>Instruction31c</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 31c format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction31c(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 31c format\n    \"\"\"\n\n    length = 6\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n        self.OP, self.AA, self.BBBBBBBB = cm.packer[\"BBi\"].unpack(\n            buff[: self.length]\n        )\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        kind = get_kind(self.cm, self.get_kind(), self.BBBBBBBB)\n        return \"v{}, {}\".format(self.AA, kind)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        kind = get_kind(self.cm, self.get_kind(), self.BBBBBBBB)\n        return [\n            (Operand.REGISTER, self.AA),\n            (self.get_kind() + Operand.KIND, self.BBBBBBBB, kind),\n        ]\n\n    def get_ref_kind(self) -&gt; int:\n        return self.BBBBBBBB\n\n    def get_string(self) -&gt; str:\n        \"\"\"\n        Return the string associated to the 'kind' argument\n\n        :returns: string\n        \"\"\"\n        return get_kind(self.cm, self.get_kind(), self.BBBBBBBB)\n\n    def get_raw_string(self) -&gt; str:\n        return get_kind(self.cm, Kind.RAW_STRING, self.BBBBBBBB)\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"HI\"].pack(\n            (self.AA &lt;&lt; 8) | self.OP, self.BBBBBBBB\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction31c.get_string","title":"<code>get_string()</code>","text":"<p>Return the string associated to the 'kind' argument</p> <p>Returns:</p> Type Description <code>str</code> <p>string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_string(self) -&gt; str:\n    \"\"\"\n    Return the string associated to the 'kind' argument\n\n    :returns: string\n    \"\"\"\n    return get_kind(self.cm, self.get_kind(), self.BBBBBBBB)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction31i","title":"<code>Instruction31i</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 31i format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction31i(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 31i format\n    \"\"\"\n\n    length = 6\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        self.OP, self.AA, self.BBBBBBBB = cm.packer[\"BBi\"].unpack(\n            buff[: self.length]\n        )\n\n        # 0x14 // const vAA, #+BBBBBBBB: arbitrary 32-bit constant\n        # 0x17 // const-wide/32 vAA, #+BBBBBBBB: signed int (32 bits)\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        # FIXME: on const-wide/32: it is actually a register pair vAA:vAA+1!\n        return \"v{}, {}\".format(self.AA, self.BBBBBBBB)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        return [(Operand.REGISTER, self.AA), (Operand.LITERAL, self.BBBBBBBB)]\n\n    def get_literals(self) -&gt; list[int]:\n        return [self.BBBBBBBB]\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"BBi\"].pack(self.OP, self.AA, self.BBBBBBBB)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction31t","title":"<code>Instruction31t</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 31t format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction31t(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 31t format\n    \"\"\"\n\n    length = 6\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        self.OP, self.AA, self.BBBBBBBB = cm.packer[\"BBi\"].unpack(\n            buff[: self.length]\n        )\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        return \"v{}, {:+08x}h\".format(self.AA, self.BBBBBBBB)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        return [(Operand.REGISTER, self.AA), (Operand.OFFSET, self.BBBBBBBB)]\n\n    def get_ref_off(self) -&gt; int:\n        return self.BBBBBBBB\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"Hi\"].pack(\n            (self.AA &lt;&lt; 8) | self.OP, self.BBBBBBBB\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction32x","title":"<code>Instruction32x</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 32x format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction32x(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 32x format\n    \"\"\"\n\n    length = 6\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        self.OP, padding, self.AAAA, self.BBBB = cm.packer[\"BBHH\"].unpack(\n            buff[: self.length]\n        )\n        if padding != 0:\n            raise InvalidInstruction(\n                'High byte of opcode with format 32x must be zero!'\n            )\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        return \"v{}, v{}\".format(self.AAAA, self.BBBB)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        return [(Operand.REGISTER, self.AAAA), (Operand.REGISTER, self.BBBB)]\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"3H\"].pack(self.OP, self.AAAA, self.BBBB)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction35c","title":"<code>Instruction35c</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 35c format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction35c(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 35c format\n    \"\"\"\n\n    length = 6\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        i16a, self.BBBB, i16b = cm.packer[\"3H\"].unpack(buff[: self.length])\n        self.OP = i16a &amp; 0xFF\n        self.G = (i16a &gt;&gt; 8) &amp; 0xF\n        self.A = (i16a &gt;&gt; 12) &amp; 0xF\n\n        self.C = i16b &amp; 0xF\n        self.D = (i16b &gt;&gt; 4) &amp; 0xF\n        self.E = (i16b &gt;&gt; 8) &amp; 0xF\n        self.F = (i16b &gt;&gt; 12) &amp; 0xF\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        kind = get_kind(self.cm, self.get_kind(), self.BBBB)\n\n        if self.A == 0:\n            return \"%s\" % kind\n        elif self.A == 1:\n            return \"v%d, %s\" % (self.C, kind)\n        elif self.A == 2:\n            return \"v%d, v%d, %s\" % (self.C, self.D, kind)\n        elif self.A == 3:\n            return \"v%d, v%d, v%d, %s\" % (self.C, self.D, self.E, kind)\n        elif self.A == 4:\n            return \"v%d, v%d, v%d, v%d, %s\" % (\n                self.C,\n                self.D,\n                self.E,\n                self.F,\n                kind,\n            )\n        elif self.A == 5:\n            return \"v%d, v%d, v%d, v%d, v%d, %s\" % (\n                self.C,\n                self.D,\n                self.E,\n                self.F,\n                self.G,\n                kind,\n            )\n\n        return ''\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple]:\n        l = []\n        kind = get_kind(self.cm, self.get_kind(), self.BBBB)\n\n        if self.A == 0:\n            l.append((self.get_kind() + Operand.KIND, self.BBBB, kind))\n        elif self.A == 1:\n            l.extend(\n                [\n                    (Operand.REGISTER, self.C),\n                    (self.get_kind() + Operand.KIND, self.BBBB, kind),\n                ]\n            )\n        elif self.A == 2:\n            l.extend(\n                [\n                    (Operand.REGISTER, self.C),\n                    (Operand.REGISTER, self.D),\n                    (self.get_kind() + Operand.KIND, self.BBBB, kind),\n                ]\n            )\n        elif self.A == 3:\n            l.extend(\n                [\n                    (Operand.REGISTER, self.C),\n                    (Operand.REGISTER, self.D),\n                    (Operand.REGISTER, self.E),\n                    (self.get_kind() + Operand.KIND, self.BBBB, kind),\n                ]\n            )\n        elif self.A == 4:\n            l.extend(\n                [\n                    (Operand.REGISTER, self.C),\n                    (Operand.REGISTER, self.D),\n                    (Operand.REGISTER, self.E),\n                    (Operand.REGISTER, self.F),\n                    (self.get_kind() + Operand.KIND, self.BBBB, kind),\n                ]\n            )\n        elif self.A == 5:\n            l.extend(\n                [\n                    (Operand.REGISTER, self.C),\n                    (Operand.REGISTER, self.D),\n                    (Operand.REGISTER, self.E),\n                    (Operand.REGISTER, self.F),\n                    (Operand.REGISTER, self.G),\n                    (self.get_kind() + Operand.KIND, self.BBBB, kind),\n                ]\n            )\n\n        return l\n\n    def get_ref_kind(self) -&gt; int:\n        return self.BBBB\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"3H\"].pack(\n            (self.A &lt;&lt; 12) | (self.G &lt;&lt; 8) | self.OP,\n            self.BBBB,\n            (self.F &lt;&lt; 12) | (self.E &lt;&lt; 8) | (self.D &lt;&lt; 4) | self.C,\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction35mi","title":"<code>Instruction35mi</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 35mi format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction35mi(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 35mi format\n    \"\"\"\n\n    length = 6\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        i16a, self.BBBB, i16b = cm.packer[\"3H\"].unpack(buff[: self.length])\n        self.OP = i16a &amp; 0xFF\n        self.G = (i16a &gt;&gt; 8) &amp; 0xF\n        self.A = (i16a &gt;&gt; 12) &amp; 0xF\n        self.C = i16b &amp; 0xF\n        self.D = (i16b &gt;&gt; 4) &amp; 0xF\n        self.E = (i16b &gt;&gt; 8) &amp; 0xF\n        self.F = (i16b &gt;&gt; 12) &amp; 0xF\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        kind = get_kind(self.cm, self.get_kind(), self.BBBB)\n\n        if self.A == 1:\n            return \"v%d, %s\" % (self.C, kind)\n        elif self.A == 2:\n            return \"v%d, v%d, %s\" % (self.C, self.D, kind)\n        elif self.A == 3:\n            return \"v%d, v%d, v%d, %s\" % (self.C, self.D, self.E, kind)\n        elif self.A == 4:\n            return \"v%d, v%d, v%d, v%d, %s\" % (\n                self.C,\n                self.D,\n                self.E,\n                self.F,\n                kind,\n            )\n        elif self.A == 5:\n            return \"v%d, v%d, v%d, v%d, v%d, %s\" % (\n                self.C,\n                self.D,\n                self.E,\n                self.F,\n                self.G,\n                kind,\n            )\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        l = []\n        kind = get_kind(self.cm, self.get_kind(), self.BBBB)\n\n        if self.A == 1:\n            l.extend(\n                [\n                    (Operand.REGISTER, self.C),\n                    (self.get_kind() + Operand.KIND, self.BBBB, kind),\n                ]\n            )\n        elif self.A == 2:\n            l.extend(\n                [\n                    (Operand.REGISTER, self.C),\n                    (Operand.REGISTER, self.D),\n                    (self.get_kind() + Operand.KIND, self.BBBB, kind),\n                ]\n            )\n        elif self.A == 3:\n            l.extend(\n                [\n                    (Operand.REGISTER, self.C),\n                    (Operand.REGISTER, self.D),\n                    (Operand.REGISTER, self.E),\n                    (self.get_kind() + Operand.KIND, self.BBBB, kind),\n                ]\n            )\n        elif self.A == 4:\n            l.extend(\n                [\n                    (Operand.REGISTER, self.C),\n                    (Operand.REGISTER, self.D),\n                    (Operand.REGISTER, self.E),\n                    (Operand.REGISTER, self.F),\n                    (self.get_kind() + Operand.KIND, self.BBBB, kind),\n                ]\n            )\n        elif self.A == 5:\n            l.extend(\n                [\n                    (Operand.REGISTER, self.C),\n                    (Operand.REGISTER, self.D),\n                    (Operand.REGISTER, self.E),\n                    (Operand.REGISTER, self.F),\n                    (Operand.REGISTER, self.G),\n                    (self.get_kind() + Operand.KIND, self.BBBB, kind),\n                ]\n            )\n\n        return l\n\n    def get_ref_kind(self) -&gt; int:\n        return self.BBBB\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"3H\"].pack(\n            (self.A &lt;&lt; 12) | (self.G &lt;&lt; 8) | self.OP,\n            self.BBBB,\n            (self.F &lt;&lt; 12) | (self.E &lt;&lt; 8) | (self.D &lt;&lt; 4) | self.C,\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction35ms","title":"<code>Instruction35ms</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 35ms format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction35ms(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 35ms format\n    \"\"\"\n\n    length = 6\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        i16a, self.BBBB, i16b = cm.packer[\"3H\"].unpack(buff[: self.length])\n        self.OP = i16a &amp; 0xFF\n        self.G = (i16a &gt;&gt; 8) &amp; 0xF\n        self.A = (i16a &gt;&gt; 12) &amp; 0xF\n        self.C = i16b &amp; 0xF\n        self.D = (i16b &gt;&gt; 4) &amp; 0xF\n        self.E = (i16b &gt;&gt; 8) &amp; 0xF\n        self.F = (i16b &gt;&gt; 12) &amp; 0xF\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        kind = get_kind(self.cm, self.get_kind(), self.BBBB)\n\n        if self.A == 1:\n            return \"v%d, %s\" % (self.C, kind)\n        elif self.A == 2:\n            return \"v%d, v%d, %s\" % (self.C, self.D, kind)\n        elif self.A == 3:\n            return \"v%d, v%d, v%d, %s\" % (self.C, self.D, self.E, kind)\n        elif self.A == 4:\n            return \"v%d, v%d, v%d, v%d, %s\" % (\n                self.C,\n                self.D,\n                self.E,\n                self.F,\n                kind,\n            )\n        elif self.A == 5:\n            return \"v%d, v%d, v%d, v%d, v%d, %s\" % (\n                self.C,\n                self.D,\n                self.E,\n                self.F,\n                self.G,\n                kind,\n            )\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        l = []\n        kind = get_kind(self.cm, self.get_kind(), self.BBBB)\n\n        if self.A == 1:\n            l.extend(\n                [\n                    (Operand.REGISTER, self.C),\n                    (self.get_kind() + Operand.KIND, self.BBBB, kind),\n                ]\n            )\n        elif self.A == 2:\n            l.extend(\n                [\n                    (Operand.REGISTER, self.C),\n                    (Operand.REGISTER, self.D),\n                    (self.get_kind() + Operand.KIND, self.BBBB, kind),\n                ]\n            )\n        elif self.A == 3:\n            l.extend(\n                [\n                    (Operand.REGISTER, self.C),\n                    (Operand.REGISTER, self.D),\n                    (Operand.REGISTER, self.E),\n                    (self.get_kind() + Operand.KIND, self.BBBB, kind),\n                ]\n            )\n        elif self.A == 4:\n            l.extend(\n                [\n                    (Operand.REGISTER, self.C),\n                    (Operand.REGISTER, self.D),\n                    (Operand.REGISTER, self.E),\n                    (Operand.REGISTER, self.F),\n                    (self.get_kind() + Operand.KIND, self.BBBB, kind),\n                ]\n            )\n        elif self.A == 5:\n            l.extend(\n                [\n                    (Operand.REGISTER, self.C),\n                    (Operand.REGISTER, self.D),\n                    (Operand.REGISTER, self.E),\n                    (Operand.REGISTER, self.F),\n                    (Operand.REGISTER, self.G),\n                    (self.get_kind() + Operand.KIND, self.BBBB, kind),\n                ]\n            )\n\n        return l\n\n    def get_ref_kind(self) -&gt; int:\n        return self.BBBB\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"3H\"].pack(\n            (self.A &lt;&lt; 12) | (self.G &lt;&lt; 8) | self.OP,\n            self.BBBB,\n            (self.F &lt;&lt; 12) | (self.E &lt;&lt; 8) | (self.D &lt;&lt; 4) | self.C,\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction3rc","title":"<code>Instruction3rc</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 3rc format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction3rc(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 3rc format\n    \"\"\"\n\n    length = 6\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        self.OP, self.AA, self.BBBB, self.CCCC = cm.packer[\"BBHH\"].unpack(\n            buff[: self.length]\n        )\n\n        self.NNNN = self.CCCC + self.AA - 1\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        kind = get_kind(self.cm, self.get_kind(), self.BBBB)\n\n        if self.CCCC == self.NNNN:\n            return \"v{}, {}\".format(self.CCCC, kind)\n        else:\n            return \"v{} ... v{}, {}\".format(self.CCCC, self.NNNN, kind)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        kind = get_kind(self.cm, self.get_kind(), self.BBBB)\n\n        return [\n            (Operand.REGISTER, i) for i in range(self.CCCC, self.NNNN + 1)\n        ] + [(self.get_kind() + Operand.KIND, self.BBBB, kind)]\n\n    def get_ref_kind(self) -&gt; int:\n        return self.BBBB\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"3H\"].pack(\n            (self.AA &lt;&lt; 8) | self.OP, self.BBBB, self.CCCC\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction3rmi","title":"<code>Instruction3rmi</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 3rmi format</p> <p>Note, this instruction is similar to 3rc but holds an inline</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction3rmi(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 3rmi format\n\n    Note, this instruction is similar to 3rc but holds an inline\n    \"\"\"\n\n    length = 6\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        self.OP, self.AA, self.BBBB, self.CCCC = cm.packer[\"BBHH\"].unpack(\n            buff[: self.length]\n        )\n\n        self.NNNN = self.CCCC + self.AA - 1\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        kind = get_kind(self.cm, self.get_kind(), self.BBBB)\n\n        if self.CCCC == self.NNNN:\n            return \"v{}, {}\".format(self.CCCC, kind)\n        else:\n            return \"v{} ... v{}, {}\".format(self.CCCC, self.NNNN, kind)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        kind = get_kind(self.cm, self.get_kind(), self.BBBB)\n\n        if self.CCCC == self.NNNN:\n            return [\n                (Operand.REGISTER, self.CCCC),\n                (self.get_kind() + Operand.KIND, self.BBBB, kind),\n            ]\n        else:\n            l = []\n            for i in range(self.CCCC, self.NNNN):\n                l.append((Operand.REGISTER, i))\n\n            l.append((self.get_kind() + Operand.KIND, self.BBBB, kind))\n            return l\n\n    def get_ref_kind(self) -&gt; int:\n        return self.BBBB\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"3H\"].pack(\n            (self.AA &lt;&lt; 8) | self.OP, self.BBBB, self.CCCC\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction3rms","title":"<code>Instruction3rms</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 3rms format</p> <p>Note, this instruction is similar to 3rc but holds a vtaboff</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction3rms(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 3rms format\n\n    Note, this instruction is similar to 3rc but holds a vtaboff\n    \"\"\"\n\n    length = 6\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        self.OP, self.AA, self.BBBB, self.CCCC = cm.packer[\"BBHH\"].unpack(\n            buff[: self.length]\n        )\n\n        self.NNNN = self.CCCC + self.AA - 1\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        kind = get_kind(self.cm, self.get_kind(), self.BBBB)\n\n        if self.CCCC == self.NNNN:\n            return \"v{}, {}\".format(self.CCCC, kind)\n        else:\n            return \"v{} ... v{}, {}\".format(self.CCCC, self.NNNN, kind)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        kind = get_kind(self.cm, self.get_kind(), self.BBBB)\n\n        if self.CCCC == self.NNNN:\n            return [\n                (Operand.REGISTER, self.CCCC),\n                (self.get_kind() + Operand.KIND, self.BBBB, kind),\n            ]\n        else:\n            l = []\n            for i in range(self.CCCC, self.NNNN):\n                l.append((Operand.REGISTER, i))\n\n            l.append((self.get_kind() + Operand.KIND, self.BBBB, kind))\n            return l\n\n    def get_ref_kind(self) -&gt; int:\n        return self.BBBB\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"3H\"].pack(\n            (self.AA &lt;&lt; 8) | self.OP, self.BBBB, self.CCCC\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction40sc","title":"<code>Instruction40sc</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 40sc format</p> <p>This instruction is only used in ODEX</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction40sc(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 40sc format\n\n    This instruction is only used in ODEX\n    \"\"\"\n\n    length = 8\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        self.OP, self.BBBBBBBB, self.AAAA = cm.packer[\"HIH\"].unpack(\n            buff[: self.length]\n        )\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        kind = get_kind(self.cm, self.get_kind(), self.BBBBBBBB)\n        return \"{}, {}\".format(self.AAAA, kind)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        kind = get_kind(self.cm, self.get_kind(), self.BBBBBBBB)\n        return [\n            (Operand.LITERAL, self.AAAA),\n            (self.get_kind() + Operand.KIND, self.BBBBBBBB, kind),\n        ]\n\n    def get_ref_kind(self) -&gt; int:\n        return self.BBBBBBBB\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"HIH\"].pack(self.OP, self.BBBBBBBB, self.AAAA)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction41c","title":"<code>Instruction41c</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 41c format</p> <p>This instruction is only used in ODEX</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction41c(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 41c format\n\n    This instruction is only used in ODEX\n    \"\"\"\n\n    length = 8\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        self.OP, self.BBBBBBBB, self.AAAA = cm.packer[\"HIH\"].unpack(\n            buff[: self.length]\n        )\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        kind = get_kind(self.cm, self.get_kind(), self.BBBBBBBB)\n        return \"v{}, {}\".format(self.AAAA, kind)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        kind = get_kind(self.cm, self.get_kind(), self.BBBBBBBB)\n        return [\n            (Operand.REGISTER, self.AAAA),\n            (self.get_kind() + Operand.KIND, self.BBBBBBBB, kind),\n        ]\n\n    def get_ref_kind(self) -&gt; int:\n        return self.BBBBBBBB\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"HIH\"].pack(self.OP, self.BBBBBBBB, self.AAAA)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction51l","title":"<code>Instruction51l</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 51l format</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction51l(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 51l format\n    \"\"\"\n\n    length = 10\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        # arbitrary double-width (64-bit) constant\n        self.OP, self.AA, self.BBBBBBBBBBBBBBBB = cm.packer[\"BBq\"].unpack(\n            buff[: self.length]\n        )\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        return \"v{}, {}\".format(self.AA, self.BBBBBBBBBBBBBBBB)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        return [\n            (Operand.REGISTER, self.AA),\n            (Operand.LITERAL, self.BBBBBBBBBBBBBBBB),\n        ]\n\n    def get_literals(self) -&gt; list[int]:\n        return [self.BBBBBBBBBBBBBBBB]\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"BBq\"].pack(\n            self.OP, self.AA, self.BBBBBBBBBBBBBBBB\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction52c","title":"<code>Instruction52c</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 52c format</p> <p>This instruction is only used in ODEX</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction52c(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 52c format\n\n    This instruction is only used in ODEX\n    \"\"\"\n\n    length = 10\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        # FIXME: Not in the documentation!\n        # Using 16bit for opcode, but its ODEX, so...\n        self.OP, self.CCCCCCCC, self.AAAA, self.BBBB = cm.packer[\n            \"HI2H\"\n        ].unpack(buff[: self.length])\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        kind = get_kind(self.cm, self.get_kind(), self.CCCCCCCC)\n        return \"v{}, v{}, {}\".format(self.AAAA, self.BBBB, kind)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        kind = get_kind(self.cm, self.get_kind(), self.CCCCCCCC)\n        return [\n            (Operand.LITERAL, self.AAAA),\n            (Operand.LITERAL, self.BBBB),\n            (self.get_kind() + Operand.KIND, self.CCCCCCCC, kind),\n        ]\n\n    def get_ref_kind(self) -&gt; int:\n        return self.CCCCCCCC\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"HI2H\"].pack(\n            self.OP, self.CCCCCCCC, self.AAAA, self.BBBB\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.Instruction5rc","title":"<code>Instruction5rc</code>","text":"<p>               Bases: <code>Instruction</code></p> <p>This class represents all instructions which have the 5rc format</p> <p>This instruction is only used in ODEX</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class Instruction5rc(Instruction):\n    \"\"\"\n    This class represents all instructions which have the 5rc format\n\n    This instruction is only used in ODEX\n    \"\"\"\n\n    length = 10\n\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        super().__init__()\n        self.cm = cm\n\n        self.OP, self.BBBBBBBB, self.AAAA, self.CCCC = cm.packer[\n            \"HI2H\"\n        ].unpack(buff[: self.length])\n\n        self.NNNN = self.CCCC + self.AAAA - 1\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        kind = get_kind(self.cm, self.get_kind(), self.BBBBBBBB)\n\n        if self.CCCC == self.NNNN:\n            return \"v{}, {}\".format(self.CCCC, kind)\n        else:\n            return \"v{} ... v{}, {}\".format(self.CCCC, self.NNNN, kind)\n\n    def get_operands(self, idx: int = -1) -&gt; list[tuple[Operand, int]]:\n        kind = get_kind(self.cm, self.get_kind(), self.BBBBBBBB)\n\n        if self.CCCC == self.NNNN:\n            return [\n                (Operand.REGISTER, self.CCCC),\n                (self.get_kind() + Operand.KIND, self.BBBBBBBB, kind),\n            ]\n        else:\n            l = []\n            for i in range(self.CCCC, self.NNNN):\n                l.append((Operand.REGISTER, i))\n\n            l.append((self.get_kind() + Operand.KIND, self.BBBBBBBB, kind))\n            return l\n\n    def get_ref_kind(self) -&gt; int:\n        return self.BBBBBBBB\n\n    def get_raw(self) -&gt; bytes:\n        return self.cm.packer[\"HI2H\"].pack(\n            self.OP, self.BBBBBBBB, self.AAAA, self.CCCC\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.LinearSweepAlgorithm","title":"<code>LinearSweepAlgorithm</code>","text":"<p>This class is used to disassemble a method. The algorithm used by this class is linear sweep.</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class LinearSweepAlgorithm:\n    \"\"\"\n    This class is used to disassemble a method. The algorithm used by this class is linear sweep.\n    \"\"\"\n\n    @staticmethod\n    def get_instructions(\n        cm: ClassManager, size: int, insn: bytearray, idx: int\n    ) -&gt; Iterator[Instruction]:\n        \"\"\"\n        Yields all instructions for the given bytecode sequence.\n        If unknown/corrupt/unused instructions are encountered,\n        the loop will stop and an error is written to the logger.\n\n        That means that the bytecode read might be corrupt\n        or was crafted in this way, to break parsers.\n\n        :param cm: a `ClassManager` object\n        :param size: the total size of the buffer in 16-bit units\n        :param insn: a raw buffer where are the instructions\n        :param idx: a start address in the buffer\n        :raises InvalidInstruction: if an instruction is invalid\n        :returns: iterator over `Instruction`s\n        \"\"\"\n        is_odex = cm.get_odex_format()\n\n        max_idx = size * calcsize('H')\n        if max_idx &gt; len(insn):\n            logger.warning(\n                \"Declared size of instructions is larger than the bytecode!\"\n            )\n            max_idx = len(insn)\n\n        # Get instructions\n        # TODO sometimes there are padding bytes after the last instruction, to ensure 16bit alignment.\n        while idx &lt; max_idx:\n            # Get one 16bit unit\n            # TODO: possible optimization; instead of reading the first 16 bits twice,\n            #       just push this into the Instruction's constructor\n            (op_value,) = cm.packer['H'].unpack(insn[idx : idx + 2])\n\n            try:\n                if op_value &gt; 0xFF and (op_value &amp; 0xFF) in (0x00, 0xFF):\n                    # FIXME: in theory, it could happen that this is a normal opcode? I.e. a 0xff opcode with AA being non zero\n                    if op_value in DALVIK_OPCODES_PAYLOAD:\n                        # payload instructions, i.e. for arrays or switch\n                        obj = get_instruction_payload(op_value, cm, insn[idx:])\n                    elif is_odex and (op_value in DALVIK_OPCODES_OPTIMIZED):\n                        # optimized instructions, only of ODEX file\n                        obj = get_optimized_instruction(\n                            cm, op_value, insn[idx:]\n                        )\n                    else:\n                        raise InvalidInstruction(\n                            \"Unknown Instruction '0x{:04x}'\".format(op_value)\n                        )\n                else:\n                    obj = get_instruction(cm, op_value &amp; 0xFF, insn[idx:])\n            except InvalidInstruction as e:\n                raise InvalidInstruction(\n                    \"Invalid instruction encountered! Stop parsing bytecode at idx %s. Message: %s\",\n                    idx,\n                    e,\n                )\n            # emit instruction\n            yield obj\n            idx += obj.get_length()\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.LinearSweepAlgorithm.get_instructions","title":"<code>get_instructions(cm, size, insn, idx)</code>  <code>staticmethod</code>","text":"<p>Yields all instructions for the given bytecode sequence. If unknown/corrupt/unused instructions are encountered, the loop will stop and an error is written to the logger.</p> <p>That means that the bytecode read might be corrupt or was crafted in this way, to break parsers.</p> <p>Parameters:</p> Name Type Description Default <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required <code>size</code> <code>int</code> <p>the total size of the buffer in 16-bit units</p> required <code>insn</code> <code>bytearray</code> <p>a raw buffer where are the instructions</p> required <code>idx</code> <code>int</code> <p>a start address in the buffer</p> required <p>Returns:</p> Type Description <code>Iterator[Instruction]</code> <p>iterator over <code>Instruction</code>s</p> <p>Raises:</p> Type Description <code>InvalidInstruction</code> <p>if an instruction is invalid</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>@staticmethod\ndef get_instructions(\n    cm: ClassManager, size: int, insn: bytearray, idx: int\n) -&gt; Iterator[Instruction]:\n    \"\"\"\n    Yields all instructions for the given bytecode sequence.\n    If unknown/corrupt/unused instructions are encountered,\n    the loop will stop and an error is written to the logger.\n\n    That means that the bytecode read might be corrupt\n    or was crafted in this way, to break parsers.\n\n    :param cm: a `ClassManager` object\n    :param size: the total size of the buffer in 16-bit units\n    :param insn: a raw buffer where are the instructions\n    :param idx: a start address in the buffer\n    :raises InvalidInstruction: if an instruction is invalid\n    :returns: iterator over `Instruction`s\n    \"\"\"\n    is_odex = cm.get_odex_format()\n\n    max_idx = size * calcsize('H')\n    if max_idx &gt; len(insn):\n        logger.warning(\n            \"Declared size of instructions is larger than the bytecode!\"\n        )\n        max_idx = len(insn)\n\n    # Get instructions\n    # TODO sometimes there are padding bytes after the last instruction, to ensure 16bit alignment.\n    while idx &lt; max_idx:\n        # Get one 16bit unit\n        # TODO: possible optimization; instead of reading the first 16 bits twice,\n        #       just push this into the Instruction's constructor\n        (op_value,) = cm.packer['H'].unpack(insn[idx : idx + 2])\n\n        try:\n            if op_value &gt; 0xFF and (op_value &amp; 0xFF) in (0x00, 0xFF):\n                # FIXME: in theory, it could happen that this is a normal opcode? I.e. a 0xff opcode with AA being non zero\n                if op_value in DALVIK_OPCODES_PAYLOAD:\n                    # payload instructions, i.e. for arrays or switch\n                    obj = get_instruction_payload(op_value, cm, insn[idx:])\n                elif is_odex and (op_value in DALVIK_OPCODES_OPTIMIZED):\n                    # optimized instructions, only of ODEX file\n                    obj = get_optimized_instruction(\n                        cm, op_value, insn[idx:]\n                    )\n                else:\n                    raise InvalidInstruction(\n                        \"Unknown Instruction '0x{:04x}'\".format(op_value)\n                    )\n            else:\n                obj = get_instruction(cm, op_value &amp; 0xFF, insn[idx:])\n        except InvalidInstruction as e:\n            raise InvalidInstruction(\n                \"Invalid instruction encountered! Stop parsing bytecode at idx %s. Message: %s\",\n                idx,\n                e,\n            )\n        # emit instruction\n        yield obj\n        idx += obj.get_length()\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.MapItem","title":"<code>MapItem</code>","text":"Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class MapItem:\n    def __init__(self, buff: bytes, cm: ClassManager) -&gt; None:\n        \"\"\"\n        Implementation of a map_item, which occours in a map_list\n\n        https://source.android.com/devices/tech/dalvik/dex-format#map-item\n        \"\"\"\n        self.CM = cm\n        self.buff = buff\n\n        self.off = buff.tell()\n\n        self.type = TypeMapItem(cm.packer[\"H\"].unpack(buff.read(2))[0])\n        self.unused, self.size, self.offset = cm.packer[\"H2I\"].unpack(\n            buff.read(10)\n        )\n\n        self.item = None\n\n    def get_off(self) -&gt; int:\n        \"\"\"Gets the offset of the map item itself inside the DEX file\"\"\"\n        return self.off\n\n    def get_offset(self) -&gt; int:\n        \"\"\"Gets the offset of the item of the map item\"\"\"\n        return self.offset\n\n    def get_type(self) -&gt; TypeMapItem:\n        return self.type\n\n    def get_size(self) -&gt; int:\n        \"\"\"\n        Returns the number of items found at the location indicated by\n        [get_offset][androguard.core.dex.MapItem.get_offset].\n\n        :returns: number of items\n        \"\"\"\n        return self.size\n\n    def parse(self) -&gt; None:\n        \"\"\"parse this map_item by parsing its potential [TypeMapItem][androguard.core.dex.dex_types.TypeMapItem] type and cast it appropriately.\"\"\"\n        logger.debug(\"Starting parsing map_item '{}'\".format(self.type.name))\n        started_at = time.time()\n\n        # Not all items are aligned in the same way. Most are aligned by four bytes,\n        # but there are a few which are not!\n        # Hence, we need to check the alignment for each item.\n\n        buff = self.buff\n        cm = self.CM\n\n        if TypeMapItem.STRING_ID_ITEM == self.type:\n            # Byte aligned\n            buff.seek(self.offset)\n            self.item = [StringIdItem(buff, cm) for _ in range(self.size)]\n\n        elif TypeMapItem.CODE_ITEM == self.type:\n            # 4-byte aligned\n            buff.seek(self.offset + (self.offset % 4))\n            self.item = CodeItem(self.size, buff, cm)\n\n        elif TypeMapItem.TYPE_ID_ITEM == self.type:\n            # 4-byte aligned\n            buff.seek(self.offset + (self.offset % 4))\n            self.item = TypeHIdItem(self.size, buff, cm)\n\n        elif TypeMapItem.PROTO_ID_ITEM == self.type:\n            # 4-byte aligned\n            buff.seek(self.offset + (self.offset % 4))\n            self.item = ProtoHIdItem(self.size, buff, cm)\n\n        elif TypeMapItem.FIELD_ID_ITEM == self.type:\n            # 4-byte aligned\n            buff.seek(self.offset + (self.offset % 4))\n            self.item = FieldHIdItem(self.size, buff, cm)\n\n        elif TypeMapItem.METHOD_ID_ITEM == self.type:\n            # 4-byte aligned\n            buff.seek(self.offset + (self.offset % 4))\n            self.item = MethodHIdItem(self.size, buff, cm)\n\n        elif TypeMapItem.CLASS_DEF_ITEM == self.type:\n            # 4-byte aligned\n            buff.seek(self.offset + (self.offset % 4))\n            self.item = ClassHDefItem(self.size, buff, cm)\n\n        elif TypeMapItem.HEADER_ITEM == self.type:\n            # FIXME probably not necessary to parse again here...\n            # 4-byte aligned\n            buff.seek(self.offset + (self.offset % 4))\n            self.item = HeaderItem(self.size, buff, cm)\n\n        elif TypeMapItem.ANNOTATION_ITEM == self.type:\n            # Byte aligned\n            buff.seek(self.offset)\n            self.item = [AnnotationItem(buff, cm) for _ in range(self.size)]\n\n        elif TypeMapItem.ANNOTATION_SET_ITEM == self.type:\n            # 4-byte aligned\n            buff.seek(self.offset + (self.offset % 4))\n            self.item = [AnnotationSetItem(buff, cm) for _ in range(self.size)]\n\n        elif TypeMapItem.ANNOTATIONS_DIRECTORY_ITEM == self.type:\n            # 4-byte aligned\n            buff.seek(self.offset + (self.offset % 4))\n            self.item = [\n                AnnotationsDirectoryItem(buff, cm) for _ in range(self.size)\n            ]\n\n        elif TypeMapItem.HIDDENAPI_CLASS_DATA_ITEM == self.type:\n            # Byte aligned\n            buff.seek(self.offset)\n            self.item = HiddenApiClassDataItem(buff, cm)\n\n        elif TypeMapItem.ANNOTATION_SET_REF_LIST == self.type:\n            # 4-byte aligned\n            buff.seek(self.offset + (self.offset % 4))\n            self.item = [\n                AnnotationSetRefList(buff, cm) for _ in range(self.size)\n            ]\n\n        elif TypeMapItem.TYPE_LIST == self.type:\n            # 4-byte aligned\n            buff.seek(self.offset + (self.offset % 4))\n            self.item = [TypeList(buff, cm) for _ in range(self.size)]\n\n        elif TypeMapItem.STRING_DATA_ITEM == self.type:\n            # Byte aligned\n            buff.seek(self.offset)\n            self.item = [StringDataItem(buff, cm) for _ in range(self.size)]\n\n        elif TypeMapItem.DEBUG_INFO_ITEM == self.type:\n            # Byte aligned\n            buff.seek(self.offset)\n            self.item = DebugInfoItemEmpty(buff, cm)\n\n        elif TypeMapItem.ENCODED_ARRAY_ITEM == self.type:\n            # Byte aligned\n            buff.seek(self.offset)\n            self.item = [EncodedArrayItem(buff, cm) for _ in range(self.size)]\n\n        elif TypeMapItem.CLASS_DATA_ITEM == self.type:\n            # Byte aligned\n            buff.seek(self.offset)\n            self.item = [ClassDataItem(buff, cm) for _ in range(self.size)]\n\n        elif TypeMapItem.MAP_LIST == self.type:\n            # 4-byte aligned\n            buff.seek(self.offset + (self.offset % 4))\n            pass  # It's me I think !!! No need to parse again\n\n        else:\n            logger.warning(\n                \"Map item with id '{type}' offset: 0x{off:x} ({off}) \"\n                \"size: {size} is unknown. \"\n                \"Is this a newer DEX format?\".format(\n                    type=self.type, off=buff.tell(), size=self.size\n                )\n            )\n\n        diff = time.time() - started_at\n        minutes, seconds = diff // 60, diff % 60\n        logger.debug(\n            \"End of parsing map_item '{}'. Required time {:.0f}:{:07.4f}\".format(\n                self.type.name, minutes, seconds\n            )\n        )\n\n    def show(self) -&gt; None:\n        bytecode._Print(\"\\tMAP_TYPE_ITEM\", self.type.name)\n\n        if self.item is not None:\n            if isinstance(self.item, list):\n                for i in self.item:\n                    i.show()\n            else:\n                self.item.show()\n\n    def get_obj(self) -&gt; object:\n        \"\"\"\n        Return the associated item itself.\n        Might return `None`, if [parse][androguard.core.dex.MapItem.parse] was not called yet.\n\n        This method is the same as `item`.\n\n        :returns: item object\n        \"\"\"\n        return self.item\n\n    # alias\n    get_item = get_obj\n\n    def get_raw(self) -&gt; bytes:\n        # FIXME why is it necessary to get the offset here agin? We have this\n        # stored?!\n        if isinstance(self.item, list):\n            self.offset = self.item[0].get_off()\n        else:\n            self.offset = self.item.get_off()\n\n        return self.CM.packer[\"2H2I\"].pack(\n            self.type, self.unused, self.size, self.offset\n        )\n\n    def get_length(self) -&gt; int:\n        return calcsize(\"HHII\")\n\n    def set_item(self, item: object) -&gt; None:\n        self.item = item\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.MapItem.__init__","title":"<code>__init__(buff, cm)</code>","text":"<p>Implementation of a map_item, which occours in a map_list</p> <p>https://source.android.com/devices/tech/dalvik/dex-format#map-item</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def __init__(self, buff: bytes, cm: ClassManager) -&gt; None:\n    \"\"\"\n    Implementation of a map_item, which occours in a map_list\n\n    https://source.android.com/devices/tech/dalvik/dex-format#map-item\n    \"\"\"\n    self.CM = cm\n    self.buff = buff\n\n    self.off = buff.tell()\n\n    self.type = TypeMapItem(cm.packer[\"H\"].unpack(buff.read(2))[0])\n    self.unused, self.size, self.offset = cm.packer[\"H2I\"].unpack(\n        buff.read(10)\n    )\n\n    self.item = None\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.MapItem.get_obj","title":"<code>get_obj()</code>","text":"<p>Return the associated item itself. Might return <code>None</code>, if parse was not called yet.</p> <p>This method is the same as <code>item</code>.</p> <p>Returns:</p> Type Description <code>object</code> <p>item object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_obj(self) -&gt; object:\n    \"\"\"\n    Return the associated item itself.\n    Might return `None`, if [parse][androguard.core.dex.MapItem.parse] was not called yet.\n\n    This method is the same as `item`.\n\n    :returns: item object\n    \"\"\"\n    return self.item\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.MapItem.get_off","title":"<code>get_off()</code>","text":"<p>Gets the offset of the map item itself inside the DEX file</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_off(self) -&gt; int:\n    \"\"\"Gets the offset of the map item itself inside the DEX file\"\"\"\n    return self.off\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.MapItem.get_offset","title":"<code>get_offset()</code>","text":"<p>Gets the offset of the item of the map item</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_offset(self) -&gt; int:\n    \"\"\"Gets the offset of the item of the map item\"\"\"\n    return self.offset\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.MapItem.get_size","title":"<code>get_size()</code>","text":"<p>Returns the number of items found at the location indicated by get_offset.</p> <p>Returns:</p> Type Description <code>int</code> <p>number of items</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_size(self) -&gt; int:\n    \"\"\"\n    Returns the number of items found at the location indicated by\n    [get_offset][androguard.core.dex.MapItem.get_offset].\n\n    :returns: number of items\n    \"\"\"\n    return self.size\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.MapItem.parse","title":"<code>parse()</code>","text":"<p>parse this map_item by parsing its potential TypeMapItem type and cast it appropriately.</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def parse(self) -&gt; None:\n    \"\"\"parse this map_item by parsing its potential [TypeMapItem][androguard.core.dex.dex_types.TypeMapItem] type and cast it appropriately.\"\"\"\n    logger.debug(\"Starting parsing map_item '{}'\".format(self.type.name))\n    started_at = time.time()\n\n    # Not all items are aligned in the same way. Most are aligned by four bytes,\n    # but there are a few which are not!\n    # Hence, we need to check the alignment for each item.\n\n    buff = self.buff\n    cm = self.CM\n\n    if TypeMapItem.STRING_ID_ITEM == self.type:\n        # Byte aligned\n        buff.seek(self.offset)\n        self.item = [StringIdItem(buff, cm) for _ in range(self.size)]\n\n    elif TypeMapItem.CODE_ITEM == self.type:\n        # 4-byte aligned\n        buff.seek(self.offset + (self.offset % 4))\n        self.item = CodeItem(self.size, buff, cm)\n\n    elif TypeMapItem.TYPE_ID_ITEM == self.type:\n        # 4-byte aligned\n        buff.seek(self.offset + (self.offset % 4))\n        self.item = TypeHIdItem(self.size, buff, cm)\n\n    elif TypeMapItem.PROTO_ID_ITEM == self.type:\n        # 4-byte aligned\n        buff.seek(self.offset + (self.offset % 4))\n        self.item = ProtoHIdItem(self.size, buff, cm)\n\n    elif TypeMapItem.FIELD_ID_ITEM == self.type:\n        # 4-byte aligned\n        buff.seek(self.offset + (self.offset % 4))\n        self.item = FieldHIdItem(self.size, buff, cm)\n\n    elif TypeMapItem.METHOD_ID_ITEM == self.type:\n        # 4-byte aligned\n        buff.seek(self.offset + (self.offset % 4))\n        self.item = MethodHIdItem(self.size, buff, cm)\n\n    elif TypeMapItem.CLASS_DEF_ITEM == self.type:\n        # 4-byte aligned\n        buff.seek(self.offset + (self.offset % 4))\n        self.item = ClassHDefItem(self.size, buff, cm)\n\n    elif TypeMapItem.HEADER_ITEM == self.type:\n        # FIXME probably not necessary to parse again here...\n        # 4-byte aligned\n        buff.seek(self.offset + (self.offset % 4))\n        self.item = HeaderItem(self.size, buff, cm)\n\n    elif TypeMapItem.ANNOTATION_ITEM == self.type:\n        # Byte aligned\n        buff.seek(self.offset)\n        self.item = [AnnotationItem(buff, cm) for _ in range(self.size)]\n\n    elif TypeMapItem.ANNOTATION_SET_ITEM == self.type:\n        # 4-byte aligned\n        buff.seek(self.offset + (self.offset % 4))\n        self.item = [AnnotationSetItem(buff, cm) for _ in range(self.size)]\n\n    elif TypeMapItem.ANNOTATIONS_DIRECTORY_ITEM == self.type:\n        # 4-byte aligned\n        buff.seek(self.offset + (self.offset % 4))\n        self.item = [\n            AnnotationsDirectoryItem(buff, cm) for _ in range(self.size)\n        ]\n\n    elif TypeMapItem.HIDDENAPI_CLASS_DATA_ITEM == self.type:\n        # Byte aligned\n        buff.seek(self.offset)\n        self.item = HiddenApiClassDataItem(buff, cm)\n\n    elif TypeMapItem.ANNOTATION_SET_REF_LIST == self.type:\n        # 4-byte aligned\n        buff.seek(self.offset + (self.offset % 4))\n        self.item = [\n            AnnotationSetRefList(buff, cm) for _ in range(self.size)\n        ]\n\n    elif TypeMapItem.TYPE_LIST == self.type:\n        # 4-byte aligned\n        buff.seek(self.offset + (self.offset % 4))\n        self.item = [TypeList(buff, cm) for _ in range(self.size)]\n\n    elif TypeMapItem.STRING_DATA_ITEM == self.type:\n        # Byte aligned\n        buff.seek(self.offset)\n        self.item = [StringDataItem(buff, cm) for _ in range(self.size)]\n\n    elif TypeMapItem.DEBUG_INFO_ITEM == self.type:\n        # Byte aligned\n        buff.seek(self.offset)\n        self.item = DebugInfoItemEmpty(buff, cm)\n\n    elif TypeMapItem.ENCODED_ARRAY_ITEM == self.type:\n        # Byte aligned\n        buff.seek(self.offset)\n        self.item = [EncodedArrayItem(buff, cm) for _ in range(self.size)]\n\n    elif TypeMapItem.CLASS_DATA_ITEM == self.type:\n        # Byte aligned\n        buff.seek(self.offset)\n        self.item = [ClassDataItem(buff, cm) for _ in range(self.size)]\n\n    elif TypeMapItem.MAP_LIST == self.type:\n        # 4-byte aligned\n        buff.seek(self.offset + (self.offset % 4))\n        pass  # It's me I think !!! No need to parse again\n\n    else:\n        logger.warning(\n            \"Map item with id '{type}' offset: 0x{off:x} ({off}) \"\n            \"size: {size} is unknown. \"\n            \"Is this a newer DEX format?\".format(\n                type=self.type, off=buff.tell(), size=self.size\n            )\n        )\n\n    diff = time.time() - started_at\n    minutes, seconds = diff // 60, diff % 60\n    logger.debug(\n        \"End of parsing map_item '{}'. Required time {:.0f}:{:07.4f}\".format(\n            self.type.name, minutes, seconds\n        )\n    )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.MapList","title":"<code>MapList</code>","text":"<p>This class can parse the \"map_list\" of the dex format</p> <p>https://source.android.com/devices/tech/dalvik/dex-format#map-list</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class MapList:\n    \"\"\"\n    This class can parse the \"map_list\" of the dex format\n\n    https://source.android.com/devices/tech/dalvik/dex-format#map-list\n    \"\"\"\n\n    def __init__(self, cm: ClassManager, off: int, buff: BinaryIO) -&gt; None:\n        self.CM = cm\n\n        buff.seek(off)\n\n        self.offset = off\n\n        (self.size,) = cm.packer[\"I\"].unpack(buff.read(4))\n\n        self.map_item = []\n        for _ in range(0, self.size):\n            idx = buff.tell()\n\n            mi = MapItem(buff, self.CM)\n            self.map_item.append(mi)\n\n            buff.seek(idx + mi.get_length())\n\n        load_order = TypeMapItem.determine_load_order()\n        ordered = sorted(\n            self.map_item, key=lambda mi: load_order[mi.get_type()]\n        )\n\n        for mi in ordered:\n            mi.parse()\n\n            c_item = mi.get_item()\n            if c_item is None:\n                mi.set_item(self)\n                c_item = mi.get_item()\n\n            self.CM.add_type_item(mi.get_type(), mi, c_item)\n\n    def get_off(self) -&gt; int:\n        return self.offset\n\n    def set_off(self, off: int) -&gt; None:\n        self.offset = off\n\n    def get_item_type(self, ttype: TypeMapItem) -&gt; object:\n        \"\"\"\n        Get a particular item type\n\n        :param ttype: a `TypeMapItem` enum which represents the desired type\n\n        :returns: `None` or the item object\n        \"\"\"\n        for i in self.map_item:\n            if i.get_type() == ttype:\n                return i.get_item()\n        return None\n\n    def show(self) -&gt; None:\n        \"\"\"\n        Print with a pretty display the MapList object\n        \"\"\"\n        bytecode._Print(\"MAP_LIST SIZE\", self.size)\n        for i in self.map_item:\n            if i.item != self:\n                # FIXME this does not work for CodeItems!\n                # as we do not have the method analysis here...\n                i.show()\n\n    def get_obj(self) -&gt; list[object]:\n        return [x.get_obj() for x in self.map_item]\n\n    def get_raw(self) -&gt; bytes:\n        return self.CM.packer[\"I\"].pack(self.size) + b''.join(\n            x.get_raw() for x in self.map_item\n        )\n\n    def get_class_manager(self) -&gt; ClassManager:\n        return self.CM\n\n    def get_length(self) -&gt; int:\n        return len(self.get_raw())\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.MapList.get_item_type","title":"<code>get_item_type(ttype)</code>","text":"<p>Get a particular item type</p> <p>Parameters:</p> Name Type Description Default <code>ttype</code> <code>TypeMapItem</code> <p>a <code>TypeMapItem</code> enum which represents the desired type</p> required <p>Returns:</p> Type Description <code>object</code> <p><code>None</code> or the item object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_item_type(self, ttype: TypeMapItem) -&gt; object:\n    \"\"\"\n    Get a particular item type\n\n    :param ttype: a `TypeMapItem` enum which represents the desired type\n\n    :returns: `None` or the item object\n    \"\"\"\n    for i in self.map_item:\n        if i.get_type() == ttype:\n            return i.get_item()\n    return None\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.MapList.show","title":"<code>show()</code>","text":"<p>Print with a pretty display the MapList object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"\n    Print with a pretty display the MapList object\n    \"\"\"\n    bytecode._Print(\"MAP_LIST SIZE\", self.size)\n    for i in self.map_item:\n        if i.item != self:\n            # FIXME this does not work for CodeItems!\n            # as we do not have the method analysis here...\n            i.show()\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.MethodAnnotation","title":"<code>MethodAnnotation</code>","text":"<p>This class can parse a <code>method_annotation</code> of a dex file</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a buff object of the <code>method_annotation</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class MethodAnnotation:\n    \"\"\"\n    This class can parse a `method_annotation` of a dex file\n\n    :param buff: a string which represents a buff object of the `method_annotation`\n    :param cm: a `ClassManager` object\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm: ClassManager) -&gt; None:\n        self.offset = buff.tell()\n\n        self.CM = cm\n        self.method_idx, self.annotations_off = cm.packer[\"2I\"].unpack(\n            buff.read(8)\n        )\n\n    def get_method_idx(self) -&gt; int:\n        \"\"\"\n        Return the index into the method_ids list for the identity of the method being annotated\n\n        :returns: the index\n        \"\"\"\n        return self.method_idx\n\n    def get_annotations_off(self) -&gt; int:\n        \"\"\"\n        Return the offset from the start of the file to the list of annotations for the method\n\n        :returns: the offset\n        \"\"\"\n        return self.annotations_off\n\n    def set_off(self, off: int) -&gt; None:\n        self.offset = off\n\n    def get_off(self) -&gt; int:\n        return self.offset\n\n    def show(self) -&gt; None:\n        bytecode._PrintSubBanner(\"Method Annotation\")\n        bytecode._PrintDefault(\n            \"method_idx=0x%x annotations_off=0x%x\\n\"\n            % (self.method_idx, self.annotations_off)\n        )\n\n    def get_obj(self) -&gt; bytes:\n        if self.annotations_off != 0:\n            self.annotations_off = self.CM.get_obj_by_offset(\n                self.annotations_off\n            ).get_off()\n\n        return self.CM.packer[\"2I\"].pack(self.method_idx, self.annotations_off)\n\n    def get_raw(self) -&gt; bytes:\n        return self.get_obj()\n\n    def get_length(self) -&gt; int:\n        return len(self.get_raw())\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.MethodAnnotation.get_annotations_off","title":"<code>get_annotations_off()</code>","text":"<p>Return the offset from the start of the file to the list of annotations for the method</p> <p>Returns:</p> Type Description <code>int</code> <p>the offset</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_annotations_off(self) -&gt; int:\n    \"\"\"\n    Return the offset from the start of the file to the list of annotations for the method\n\n    :returns: the offset\n    \"\"\"\n    return self.annotations_off\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.MethodAnnotation.get_method_idx","title":"<code>get_method_idx()</code>","text":"<p>Return the index into the method_ids list for the identity of the method being annotated</p> <p>Returns:</p> Type Description <code>int</code> <p>the index</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_method_idx(self) -&gt; int:\n    \"\"\"\n    Return the index into the method_ids list for the identity of the method being annotated\n\n    :returns: the index\n    \"\"\"\n    return self.method_idx\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.MethodHIdItem","title":"<code>MethodHIdItem</code>","text":"<p>This class can parse a list of <code>method_id_item</code> of a dex file</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class MethodHIdItem:\n    \"\"\"\n    This class can parse a list of `method_id_item` of a dex file\n    \"\"\"\n\n\n    def __init__(self, size:int, buff: BinaryIO, cm:ClassManager) -&gt; None:\n        \"\"\"\n        :param buff: a string which represents a Buff object of the list of `method_id_item`\n        :param cm: a `ClassManager` object\n        \"\"\"\n        self.CM = cm\n\n        self.offset = buff.tell()\n\n        self.method_id_items = [MethodIdItem(buff, cm) for i in range(0, size)]\n\n    def set_off(self, off: int):\n        self.offset = off\n\n    def get_off(self) -&gt; int:\n        return self.offset\n\n    def gets(self) -&gt; list[MethodIdItem]:\n        return self.method_id_items\n\n    def get(self, idx) -&gt; Union[MethodIdItem, MethodIdItemInvalid]:\n        try:\n            return self.method_id_items[idx]\n        except IndexError:\n            return MethodIdItemInvalid()\n\n    def reload(self) -&gt; None:\n        for i in self.method_id_items:\n            i.reload()\n\n    def show(self) -&gt; None:\n        print(\"METHOD_ID_ITEM\")\n        nb = 0\n        for i in self.method_id_items:\n            print(nb, end=' ')\n            i.show()\n            nb = nb + 1\n\n    def get_obj(self) -&gt; list[MethodIdItem]:\n        return [i for i in self.method_id_items]\n\n    def get_raw(self) -&gt; bytes:\n        return b''.join(i.get_raw() for i in self.method_id_items)\n\n    def get_length(self) -&gt; int:\n        length = 0\n        for i in self.method_id_items:\n            length += i.get_length()\n        return length\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.MethodHIdItem.__init__","title":"<code>__init__(size, buff, cm)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a Buff object of the list of <code>method_id_item</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def __init__(self, size:int, buff: BinaryIO, cm:ClassManager) -&gt; None:\n    \"\"\"\n    :param buff: a string which represents a Buff object of the list of `method_id_item`\n    :param cm: a `ClassManager` object\n    \"\"\"\n    self.CM = cm\n\n    self.offset = buff.tell()\n\n    self.method_id_items = [MethodIdItem(buff, cm) for i in range(0, size)]\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.MethodIdItem","title":"<code>MethodIdItem</code>","text":"<p>This class can parse a <code>method_id_item</code> of a dex file</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class MethodIdItem:\n    \"\"\"\n    This class can parse a `method_id_item` of a dex file\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm:ClassManager) -&gt; None:\n        \"\"\"\n        :param buff: a string which represents a Buff object of the `method_id_item`\n        :param cm: a `ClassManager` object\n        \"\"\"\n        self.CM = cm\n        self.offset = buff.tell()\n\n        self.class_idx, self.proto_idx, self.name_idx = cm.packer[\n            \"2HI\"\n        ].unpack(buff.read(8))\n\n        self.reload()\n\n    def reload(self) -&gt; None:\n        self.class_idx_value = self.CM.get_type(self.class_idx)\n        self.proto_idx_value = self.CM.get_proto(self.proto_idx)\n        self.name_idx_value = self.CM.get_string(self.name_idx)\n\n    def get_class_idx(self) -&gt; int:\n        \"\"\"\n        Return the index into the type_ids list for the definer of this method\n\n        :returns: the index\n        \"\"\"\n        return self.class_idx\n\n    def get_proto_idx(self) -&gt; int:\n        \"\"\"\n        Return the index into the `proto_ids` list for the prototype of this method\n\n        :returns: the index\n        \"\"\"\n        return self.proto_idx\n\n    def get_name_idx(self) -&gt; int:\n        \"\"\"\n        Return the index into the `string_ids` list for the name of this method\n\n        :returns: the index\n        \"\"\"\n        return self.name_idx\n\n    def get_class_name(self) -&gt; str:\n        \"\"\"\n        Return the class name of the method\n\n        :returns: the class name\n        \"\"\"\n        if self.class_idx_value is None:\n            self.class_idx_value = self.CM.get_type(self.class_idx)\n\n        return self.class_idx_value\n\n    def get_proto(self) -&gt; str:\n        \"\"\"\n        Return the prototype of the method\n\n        :returns: the prototype\n        \"\"\"\n        if self.proto_idx_value is None:\n            self.proto_idx_value = self.CM.get_proto(self.proto_idx)\n\n        return self.proto_idx_value\n\n    def get_descriptor(self) -&gt; str:\n        \"\"\"\n        Return the descriptor\n\n        :returns: the descriptor\n        \"\"\"\n        proto = self.get_proto()\n        return proto[0] + proto[1]\n\n    def get_real_descriptor(self) -&gt; str:\n        \"\"\"\n        Return the real descriptor (i.e. without extra spaces)\n\n        :returns: the real descriptor, without extra spaces\n        \"\"\"\n        proto = self.get_proto()\n        return proto[0].replace(' ', '') + proto[1]\n\n    def get_name(self) -&gt; str:\n        \"\"\"\n        Return the name of the method\n\n        :returns: the name of the of method\n        \"\"\"\n        if self.name_idx_value is None:\n            self.name_idx_value = self.CM.get_string(self.name_idx)\n        return self.name_idx_value\n\n    def get_list(self) -&gt; list[str]:\n        return [self.get_class_name(), self.get_name(), self.get_proto()]\n\n    def get_triple(self) -&gt; tuple[str, str, str]:\n        return (\n            self.get_class_name()[1:-1],\n            self.get_name(),\n            self.get_real_descriptor(),\n        )\n\n    def show(self) -&gt; None:\n        bytecode._PrintSubBanner(\"Method Id Item\")\n        bytecode._PrintDefault(\n            \"class_idx=%d proto_idx=%d name_idx=%d\\n\"\n            % (self.class_idx, self.proto_idx, self.name_idx)\n        )\n        bytecode._PrintDefault(\n            \"class_idx_value=%s proto_idx_value=%s name_idx_value=%s\\n\"\n            % (self.class_idx_value, self.proto_idx_value, self.name_idx_value)\n        )\n\n    def get_obj(self) -&gt; bytes:\n        return self.CM.packer[\"2HI\"].pack(\n            self.class_idx, self.proto_idx, self.name_idx\n        )\n\n    def get_raw(self) -&gt; bytes:\n        return self.get_obj()\n\n    def get_length(self) -&gt; int:\n        return len(self.get_obj())\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.MethodIdItem.__init__","title":"<code>__init__(buff, cm)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a Buff object of the <code>method_id_item</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def __init__(self, buff: BinaryIO, cm:ClassManager) -&gt; None:\n    \"\"\"\n    :param buff: a string which represents a Buff object of the `method_id_item`\n    :param cm: a `ClassManager` object\n    \"\"\"\n    self.CM = cm\n    self.offset = buff.tell()\n\n    self.class_idx, self.proto_idx, self.name_idx = cm.packer[\n        \"2HI\"\n    ].unpack(buff.read(8))\n\n    self.reload()\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.MethodIdItem.get_class_idx","title":"<code>get_class_idx()</code>","text":"<p>Return the index into the type_ids list for the definer of this method</p> <p>Returns:</p> Type Description <code>int</code> <p>the index</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_class_idx(self) -&gt; int:\n    \"\"\"\n    Return the index into the type_ids list for the definer of this method\n\n    :returns: the index\n    \"\"\"\n    return self.class_idx\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.MethodIdItem.get_class_name","title":"<code>get_class_name()</code>","text":"<p>Return the class name of the method</p> <p>Returns:</p> Type Description <code>str</code> <p>the class name</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_class_name(self) -&gt; str:\n    \"\"\"\n    Return the class name of the method\n\n    :returns: the class name\n    \"\"\"\n    if self.class_idx_value is None:\n        self.class_idx_value = self.CM.get_type(self.class_idx)\n\n    return self.class_idx_value\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.MethodIdItem.get_descriptor","title":"<code>get_descriptor()</code>","text":"<p>Return the descriptor</p> <p>Returns:</p> Type Description <code>str</code> <p>the descriptor</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_descriptor(self) -&gt; str:\n    \"\"\"\n    Return the descriptor\n\n    :returns: the descriptor\n    \"\"\"\n    proto = self.get_proto()\n    return proto[0] + proto[1]\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.MethodIdItem.get_name","title":"<code>get_name()</code>","text":"<p>Return the name of the method</p> <p>Returns:</p> Type Description <code>str</code> <p>the name of the of method</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_name(self) -&gt; str:\n    \"\"\"\n    Return the name of the method\n\n    :returns: the name of the of method\n    \"\"\"\n    if self.name_idx_value is None:\n        self.name_idx_value = self.CM.get_string(self.name_idx)\n    return self.name_idx_value\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.MethodIdItem.get_name_idx","title":"<code>get_name_idx()</code>","text":"<p>Return the index into the <code>string_ids</code> list for the name of this method</p> <p>Returns:</p> Type Description <code>int</code> <p>the index</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_name_idx(self) -&gt; int:\n    \"\"\"\n    Return the index into the `string_ids` list for the name of this method\n\n    :returns: the index\n    \"\"\"\n    return self.name_idx\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.MethodIdItem.get_proto","title":"<code>get_proto()</code>","text":"<p>Return the prototype of the method</p> <p>Returns:</p> Type Description <code>str</code> <p>the prototype</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_proto(self) -&gt; str:\n    \"\"\"\n    Return the prototype of the method\n\n    :returns: the prototype\n    \"\"\"\n    if self.proto_idx_value is None:\n        self.proto_idx_value = self.CM.get_proto(self.proto_idx)\n\n    return self.proto_idx_value\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.MethodIdItem.get_proto_idx","title":"<code>get_proto_idx()</code>","text":"<p>Return the index into the <code>proto_ids</code> list for the prototype of this method</p> <p>Returns:</p> Type Description <code>int</code> <p>the index</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_proto_idx(self) -&gt; int:\n    \"\"\"\n    Return the index into the `proto_ids` list for the prototype of this method\n\n    :returns: the index\n    \"\"\"\n    return self.proto_idx\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.MethodIdItem.get_real_descriptor","title":"<code>get_real_descriptor()</code>","text":"<p>Return the real descriptor (i.e. without extra spaces)</p> <p>Returns:</p> Type Description <code>str</code> <p>the real descriptor, without extra spaces</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_real_descriptor(self) -&gt; str:\n    \"\"\"\n    Return the real descriptor (i.e. without extra spaces)\n\n    :returns: the real descriptor, without extra spaces\n    \"\"\"\n    proto = self.get_proto()\n    return proto[0].replace(' ', '') + proto[1]\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ODEX","title":"<code>ODEX</code>","text":"<p>               Bases: <code>DEX</code></p> <p>This class can parse an odex file</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <p>byteswhich represents the odex file</p> required <code>decompiler</code> <code>Union[DecompilerDAD, None]</code> <p>associate a decompiler object to display the java source code  Example:  &gt;&gt;&gt; ODEX( read(\"classes.odex\") )</p> <code>None</code> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class ODEX(DEX):\n    \"\"\"\n    This class can parse an odex file\n\n    :param buff: byteswhich represents the odex file\n    :param decompiler: associate a decompiler object to display the java source code\n\n    Example:\n\n        &gt;&gt;&gt; ODEX( read(\"classes.odex\") )\n    \"\"\"\n\n    def _preload(self, buff: BinaryIO):\n        self.orig_buff = buff\n        self.magic = buff[:8]\n        if self.magic in (\n            ODEX_FILE_MAGIC_35,\n            ODEX_FILE_MAGIC_36,\n            ODEX_FILE_MAGIC_37,\n        ):\n            self.odex_header = OdexHeaderItem(self)\n\n            self.seek(self.odex_header.deps_offset)\n            self.dependencies = OdexDependencies(self)\n\n            self.padding = buff[\n                self.odex_header.deps_offset + self.odex_header.deps_length :\n            ]\n\n            self.seek(self.odex_header.dex_offset)\n            self.set_buff(self.read(self.odex_header.dex_length))\n            self.seek(0)\n\n    def save(self) -&gt; bytes:\n        \"\"\"\n        Do not use !\n        \"\"\"\n        dex_raw = super().save()\n        return (\n            self.magic\n            + self.odex_header.get_raw()\n            + dex_raw\n            + self.dependencies.get_raw()\n            + self.padding\n        )\n\n    def get_buff(self) -&gt; bytes:\n        return (\n            self.magic\n            + self.odex_header.get_raw()\n            + super().get_buff()\n            + self.dependencies.get_raw()\n            + self.padding\n        )\n\n    def get_dependencies(self) -&gt; OdexDependencies:\n        \"\"\"\n        Return the odex dependencies object\n\n        :returns: an `OdexDependencies` object\n        \"\"\"\n        return self.dependencies\n\n    def get_format_type(self) -&gt; str:\n        \"\"\"\n        Return the type\n\n        :returns: a string\n        \"\"\"\n        return \"ODEX\"\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ODEX.get_dependencies","title":"<code>get_dependencies()</code>","text":"<p>Return the odex dependencies object</p> <p>Returns:</p> Type Description <code>OdexDependencies</code> <p>an <code>OdexDependencies</code> object</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_dependencies(self) -&gt; OdexDependencies:\n    \"\"\"\n    Return the odex dependencies object\n\n    :returns: an `OdexDependencies` object\n    \"\"\"\n    return self.dependencies\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ODEX.get_format_type","title":"<code>get_format_type()</code>","text":"<p>Return the type</p> <p>Returns:</p> Type Description <code>str</code> <p>a string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_format_type(self) -&gt; str:\n    \"\"\"\n    Return the type\n\n    :returns: a string\n    \"\"\"\n    return \"ODEX\"\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ODEX.save","title":"<code>save()</code>","text":"<p>Do not use !</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def save(self) -&gt; bytes:\n    \"\"\"\n    Do not use !\n    \"\"\"\n    dex_raw = super().save()\n    return (\n        self.magic\n        + self.odex_header.get_raw()\n        + dex_raw\n        + self.dependencies.get_raw()\n        + self.padding\n    )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.OdexDependencies","title":"<code>OdexDependencies</code>","text":"<p>This class can parse the odex dependencies</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a Buff object string which represents the odex dependencies</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class OdexDependencies:\n    \"\"\"\n    This class can parse the odex dependencies\n\n    :param buff: a Buff object string which represents the odex dependencies\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO) -&gt; None:\n        self.modification_time = unpack(\"=I\", buff.read(4))[0]\n        self.crc = unpack(\"=I\", buff.read(4))[0]\n        self.dalvik_build = unpack(\"=I\", buff.read(4))[0]\n        self.dependency_count = unpack(\"=I\", buff.read(4))[0]\n        self.dependencies = []\n        self.dependency_checksums = []\n\n        for i in range(0, self.dependency_count):\n            string_length = unpack(\"=I\", buff.read(4))[0]\n            name_dependency = buff.read(string_length)\n            self.dependencies.append(name_dependency)\n            self.dependency_checksums.append(buff.read(20))\n\n    def get_dependencies(self) -&gt; list[str]:\n        \"\"\"\n        Return the list of dependencies\n\n        :returns: a list of strings\n        \"\"\"\n        return self.dependencies\n\n    def get_raw(self) -&gt; bytes:\n        dependencies = b\"\"\n\n        for idx, value in enumerate(self.dependencies):\n            dependencies += (\n                pack(\"=I\", len(value))\n                + pack(\"=%ds\" % len(value), value)\n                + pack(\"=20s\", self.dependency_checksums[idx])\n            )\n\n        return (\n            pack(\"=I\", self.modification_time)\n            + pack(\"=I\", self.crc)\n            + pack(\"=I\", self.dalvik_build)\n            + pack(\"=I\", self.dependency_count)\n            + dependencies\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.OdexDependencies.get_dependencies","title":"<code>get_dependencies()</code>","text":"<p>Return the list of dependencies</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>a list of strings</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_dependencies(self) -&gt; list[str]:\n    \"\"\"\n    Return the list of dependencies\n\n    :returns: a list of strings\n    \"\"\"\n    return self.dependencies\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.OdexHeaderItem","title":"<code>OdexHeaderItem</code>","text":"<p>This class can parse the odex header</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a Buff object string which represents the odex dependencies</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class OdexHeaderItem:\n    \"\"\"\n    This class can parse the odex header\n\n    :param buff: a Buff object string which represents the odex dependencies\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO) -&gt; None:\n        buff.seek(8)\n\n        self.dex_offset = unpack(\"=I\", buff.read(4))[0]\n        self.dex_length = unpack(\"=I\", buff.read(4))[0]\n        self.deps_offset = unpack(\"=I\", buff.read(4))[0]\n        self.deps_length = unpack(\"=I\", buff.read(4))[0]\n        self.aux_offset = unpack(\"=I\", buff.read(4))[0]\n        self.aux_length = unpack(\"=I\", buff.read(4))[0]\n        self.flags = unpack(\"=I\", buff.read(4))[0]\n        self.padding = unpack(\"=I\", buff.read(4))[0]\n\n    def show(self) -&gt; None:\n        print(\n            \"dex_offset:{:x} dex_length:{:x} deps_offset:{:x} deps_length:{:x} aux_offset:{:x} aux_length:{:x} flags:{:x}\".format(\n                self.dex_offset,\n                self.dex_length,\n                self.deps_offset,\n                self.deps_length,\n                self.aux_offset,\n                self.aux_length,\n                self.flags,\n            )\n        )\n\n    def get_raw(self) -&gt; bytes:\n        return (\n            pack(\"=I\", self.dex_offset)\n            + pack(\"=I\", self.dex_length)\n            + pack(\"=I\", self.deps_offset)\n            + pack(\"=I\", self.deps_length)\n            + pack(\"=I\", self.aux_offset)\n            + pack(\"=I\", self.aux_length)\n            + pack(\"=I\", self.flags)\n            + pack(\"=I\", self.padding)\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.PackedSwitch","title":"<code>PackedSwitch</code>","text":"<p>This class can parse a <code>PackedSwitch</code> instruction</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>bytes</code> <p>a Buff object which represents a buffer where the instruction is stored</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class PackedSwitch:\n    \"\"\"\n    This class can parse a `PackedSwitch` instruction\n\n    :param buff: a Buff object which represents a buffer where the instruction is stored\n    \"\"\"\n\n    # FIXME: why is this not a subclass of Instruction?\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        self.OP = 0x0\n        self.notes = []\n        self.CM = cm\n\n        self.format_general_size = calcsize(\"2HI\")\n\n        self.ident, self.size, self.first_key = cm.packer[\"2Hi\"].unpack(\n            buff[0:8]\n        )\n\n        self.targets = []\n\n        idx = self.format_general_size\n\n        max_size = self.size\n        if (max_size * 4) &gt; len(buff):\n            max_size = len(buff) - idx - 8\n\n        for i in range(0, max_size):\n            self.targets.append(cm.packer[\"l\"].unpack(buff[idx : idx + 4])[0])\n            idx += 4\n\n    def add_note(self, msg: str) -&gt; None:\n        \"\"\"\n        Add a note to this instruction\n\n        :param msg: the message\n        \"\"\"\n        self.notes.append(msg)\n\n    def get_notes(self) -&gt; list[str]:\n        \"\"\"\n        Get all notes from this instruction\n\n        :returns: a list of note strings\n        \"\"\"\n        return self.notes\n\n    def get_op_value(self) -&gt; int:\n        \"\"\"\n        Get the value of the opcode\n\n        :returns: opcode value\n        \"\"\"\n        return self.ident\n\n    def get_keys(self) -&gt; list[int]:\n        \"\"\"\n        Return the keys of the instruction\n\n        :returns: a list of long (integer)\n        \"\"\"\n        return [(self.first_key + i) for i in range(0, len(self.targets))]\n\n    def get_values(self) -&gt; list[int]:\n        return self.get_keys()\n\n    def get_targets(self) -&gt; list[int]:\n        \"\"\"\n        Return the targets (address) of the instruction\n\n        :returns: a list of long (integer)\n        \"\"\"\n        return self.targets\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        \"\"\"\n        Return an additional output of the instruction\n\n        :returns: additional output string\n        \"\"\"\n        return \" \".join(\n            \"%x\" % (self.first_key + i) for i in range(0, len(self.targets))\n        )\n\n    def get_operands(self, idx: int = -1) -&gt; list:\n        \"\"\"\n        Return an additional output of the instruction\n\n        :returns: list\n        \"\"\"\n        return []\n\n    def get_formatted_operands(self) -&gt; None:\n        return None\n\n    def get_name(self) -&gt; str:\n        \"\"\"\n        Return the name of the instruction\n\n        :returns: name string\n        \"\"\"\n        return \"packed-switch-payload\"\n\n    def show_buff(self, pos: int) -&gt; str:\n        \"\"\"\n        Return the display of the instruction\n\n        :returns: display string\n        \"\"\"\n        buff = self.get_name() + \" \"\n        buff += \"%x:\" % self.first_key\n\n        for i in self.targets:\n            buff += \" %x\" % i\n\n        return buff\n\n    def show(self, pos: int) -&gt; None:\n        \"\"\"\n        Print the instruction\n        \"\"\"\n        print(self.show_buff(pos), end=' ')\n\n    def get_length(self) -&gt; int:\n        return self.format_general_size + (self.size * calcsize('&lt;L'))\n\n    def get_raw(self) -&gt; bytes:\n        return self.CM.packer[\"2Hi\"].pack(\n            self.ident, self.size, self.first_key\n        ) + b''.join(self.CM.packer[\"l\"].pack(i) for i in self.targets)\n\n    def get_hex(self) -&gt; bytes:\n        \"\"\"\n        Returns a HEX String, separated by spaces every byte\n        \"\"\"\n        s = binascii.hexlify(self.get_raw()).decode('ascii')\n        return \" \".join(s[i : i + 2] for i in range(0, len(s), 2))\n\n    def disasm(self) -&gt; str:\n        # FIXME:\n        return self.show_buff(None)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.PackedSwitch.add_note","title":"<code>add_note(msg)</code>","text":"<p>Add a note to this instruction</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>the message</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def add_note(self, msg: str) -&gt; None:\n    \"\"\"\n    Add a note to this instruction\n\n    :param msg: the message\n    \"\"\"\n    self.notes.append(msg)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.PackedSwitch.get_hex","title":"<code>get_hex()</code>","text":"<p>Returns a HEX String, separated by spaces every byte</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_hex(self) -&gt; bytes:\n    \"\"\"\n    Returns a HEX String, separated by spaces every byte\n    \"\"\"\n    s = binascii.hexlify(self.get_raw()).decode('ascii')\n    return \" \".join(s[i : i + 2] for i in range(0, len(s), 2))\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.PackedSwitch.get_keys","title":"<code>get_keys()</code>","text":"<p>Return the keys of the instruction</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>a list of long (integer)</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_keys(self) -&gt; list[int]:\n    \"\"\"\n    Return the keys of the instruction\n\n    :returns: a list of long (integer)\n    \"\"\"\n    return [(self.first_key + i) for i in range(0, len(self.targets))]\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.PackedSwitch.get_name","title":"<code>get_name()</code>","text":"<p>Return the name of the instruction</p> <p>Returns:</p> Type Description <code>str</code> <p>name string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_name(self) -&gt; str:\n    \"\"\"\n    Return the name of the instruction\n\n    :returns: name string\n    \"\"\"\n    return \"packed-switch-payload\"\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.PackedSwitch.get_notes","title":"<code>get_notes()</code>","text":"<p>Get all notes from this instruction</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>a list of note strings</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_notes(self) -&gt; list[str]:\n    \"\"\"\n    Get all notes from this instruction\n\n    :returns: a list of note strings\n    \"\"\"\n    return self.notes\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.PackedSwitch.get_op_value","title":"<code>get_op_value()</code>","text":"<p>Get the value of the opcode</p> <p>Returns:</p> Type Description <code>int</code> <p>opcode value</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_op_value(self) -&gt; int:\n    \"\"\"\n    Get the value of the opcode\n\n    :returns: opcode value\n    \"\"\"\n    return self.ident\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.PackedSwitch.get_operands","title":"<code>get_operands(idx=-1)</code>","text":"<p>Return an additional output of the instruction</p> <p>Returns:</p> Type Description <code>list</code> <p>list</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_operands(self, idx: int = -1) -&gt; list:\n    \"\"\"\n    Return an additional output of the instruction\n\n    :returns: list\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.PackedSwitch.get_output","title":"<code>get_output(idx=-1)</code>","text":"<p>Return an additional output of the instruction</p> <p>Returns:</p> Type Description <code>str</code> <p>additional output string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_output(self, idx: int = -1) -&gt; str:\n    \"\"\"\n    Return an additional output of the instruction\n\n    :returns: additional output string\n    \"\"\"\n    return \" \".join(\n        \"%x\" % (self.first_key + i) for i in range(0, len(self.targets))\n    )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.PackedSwitch.get_targets","title":"<code>get_targets()</code>","text":"<p>Return the targets (address) of the instruction</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>a list of long (integer)</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_targets(self) -&gt; list[int]:\n    \"\"\"\n    Return the targets (address) of the instruction\n\n    :returns: a list of long (integer)\n    \"\"\"\n    return self.targets\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.PackedSwitch.show","title":"<code>show(pos)</code>","text":"<p>Print the instruction</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def show(self, pos: int) -&gt; None:\n    \"\"\"\n    Print the instruction\n    \"\"\"\n    print(self.show_buff(pos), end=' ')\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.PackedSwitch.show_buff","title":"<code>show_buff(pos)</code>","text":"<p>Return the display of the instruction</p> <p>Returns:</p> Type Description <code>str</code> <p>display string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def show_buff(self, pos: int) -&gt; str:\n    \"\"\"\n    Return the display of the instruction\n\n    :returns: display string\n    \"\"\"\n    buff = self.get_name() + \" \"\n    buff += \"%x:\" % self.first_key\n\n    for i in self.targets:\n        buff += \" %x\" % i\n\n    return buff\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ParameterAnnotation","title":"<code>ParameterAnnotation</code>","text":"<p>This class can parse a <code>parameter_annotation</code> of a dex file</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a buff object of the <code>parameter_annotation</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class ParameterAnnotation:\n    \"\"\"\n    This class can parse a `parameter_annotation` of a dex file\n\n    :param buff: a string which represents a buff object of the `parameter_annotation`\n    :param cm: a `ClassManager` object\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm: ClassManager) -&gt; None:\n        self.offset = buff.tell()\n\n        self.CM = cm\n        self.method_idx, self.annotations_off = cm.packer[\"2I\"].unpack(\n            buff.read(8)\n        )\n\n    def get_method_idx(self) -&gt; int:\n        \"\"\"\n        Return the index into the `method_ids` list for the identity of the method whose parameters are being annotated\n\n        :returns: the index\n        \"\"\"\n        return self.method_idx\n\n    def get_annotations_off(self) -&gt; int:\n        \"\"\"\n        Return the offset from the start of the file to the list of annotations for the method parameters\n\n        :returns: the offset\n        \"\"\"\n        return self.annotations_off\n\n    def set_off(self, off: int) -&gt; None:\n        self.offset = off\n\n    def get_off(self) -&gt; int:\n        return self.offset\n\n    def show(self) -&gt; None:\n        bytecode._PrintSubBanner(\"Parameter Annotation\")\n        bytecode._PrintDefault(\n            \"method_idx=0x%x annotations_off=0x%x\\n\"\n            % (self.method_idx, self.annotations_off)\n        )\n\n    def get_obj(self) -&gt; bytes:\n        if self.annotations_off != 0:\n            self.annotations_off = self.CM.get_obj_by_offset(\n                self.annotations_off\n            ).get_off()\n\n        return self.CM.packer[\"2I\"].pack(self.method_idx, self.annotations_off)\n\n    def get_raw(self) -&gt; bytes:\n        return self.get_obj()\n\n    def get_length(self) -&gt; int:\n        return len(self.get_raw())\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ParameterAnnotation.get_annotations_off","title":"<code>get_annotations_off()</code>","text":"<p>Return the offset from the start of the file to the list of annotations for the method parameters</p> <p>Returns:</p> Type Description <code>int</code> <p>the offset</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_annotations_off(self) -&gt; int:\n    \"\"\"\n    Return the offset from the start of the file to the list of annotations for the method parameters\n\n    :returns: the offset\n    \"\"\"\n    return self.annotations_off\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ParameterAnnotation.get_method_idx","title":"<code>get_method_idx()</code>","text":"<p>Return the index into the <code>method_ids</code> list for the identity of the method whose parameters are being annotated</p> <p>Returns:</p> Type Description <code>int</code> <p>the index</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_method_idx(self) -&gt; int:\n    \"\"\"\n    Return the index into the `method_ids` list for the identity of the method whose parameters are being annotated\n\n    :returns: the index\n    \"\"\"\n    return self.method_idx\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ProtoHIdItem","title":"<code>ProtoHIdItem</code>","text":"<p>This class can parse a list of <code>proto_id_item</code> of a dex file</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class ProtoHIdItem:\n    \"\"\"\n    This class can parse a list of `proto_id_item` of a dex file\n    \"\"\"\n\n    def __init__(self, size:int, buff: BinaryIO, cm:ClassManager) -&gt; None:\n        \"\"\"\n        :param buff: a string which represents a Buff object of the list of `proto_id_item`\n        :param cm: a `ClassManager` object\n        \"\"\"\n        self.CM = cm\n\n        self.offset = buff.tell()\n\n        self.proto = [ProtoIdItem(buff, cm) for i in range(0, size)]\n\n    def set_off(self, off: int) -&gt; None:\n        self.offset = off\n\n    def get_off(self) -&gt; int:\n        return self.offset\n\n    def get(self, idx: int) -&gt; ProtoIdItem:\n        try:\n            return self.proto[idx]\n        except IndexError:\n            return ProtoIdItemInvalid()\n\n    def show(self) -&gt; None:\n        bytecode._PrintSubBanner(\"Proto List Item\")\n        for i in self.proto:\n            i.show()\n\n    def get_obj(self) -&gt; list[ProtoIdItem]:\n        return [i for i in self.proto]\n\n    def get_raw(self) -&gt; bytes:\n        return b''.join(i.get_raw() for i in self.proto)\n\n    def get_length(self) -&gt; int:\n        length = 0\n        for i in self.proto:\n            length += i.get_length()\n        return length\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ProtoHIdItem.__init__","title":"<code>__init__(size, buff, cm)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a Buff object of the list of <code>proto_id_item</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def __init__(self, size:int, buff: BinaryIO, cm:ClassManager) -&gt; None:\n    \"\"\"\n    :param buff: a string which represents a Buff object of the list of `proto_id_item`\n    :param cm: a `ClassManager` object\n    \"\"\"\n    self.CM = cm\n\n    self.offset = buff.tell()\n\n    self.proto = [ProtoIdItem(buff, cm) for i in range(0, size)]\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ProtoIdItem","title":"<code>ProtoIdItem</code>","text":"<p>This class can parse a <code>proto_id_item</code> of a dex file</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class ProtoIdItem:\n    \"\"\"\n    This class can parse a `proto_id_item` of a dex file\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm: ClassManager):\n        \"\"\"\n        :param buff: a string which represents a Buff object of the `proto_id_item`\n        :param cm: a `ClassManager` object\n        \"\"\"\n        self.CM = cm\n        self.offset = buff.tell()\n\n        self.shorty_idx, self.return_type_idx, self.parameters_off = cm.packer[\n            \"3I\"\n        ].unpack(buff.read(12))\n\n        self.shorty_idx_value = self.CM.get_string(self.shorty_idx)\n        self.return_type_idx_value = self.CM.get_type(self.return_type_idx)\n        self.parameters_off_value = None\n\n    def get_shorty_idx(self) -&gt; int:\n        \"\"\"\n        Return the index into the `string_ids` list for the short-form descriptor string of this prototype\n\n        :returns: the index\n        \"\"\"\n        return self.shorty_idx\n\n    def get_return_type_idx(self) -&gt; int:\n        \"\"\"\n        Return the index into the `type_ids` list for the return type of this prototype\n\n        :returns: the index\n        \"\"\"\n        return self.return_type_idx\n\n    def get_parameters_off(self) -&gt; int:\n        \"\"\"\n        Return the offset from the start of the file to the list of parameter types for this prototype, or 0 if this prototype has no parameters\n\n        :returns: the offset\n        \"\"\"\n        return self.parameters_off\n\n    def get_shorty_idx_value(self) -&gt; str:\n        \"\"\"\n        Return the string associated to the `shorty_idx`\n\n        :returns: string\n        \"\"\"\n        if self.shorty_idx_value is None:\n            self.shorty_idx_value = self.CM.get_string(self.shorty_idx)\n        return self.shorty_idx_value\n\n    def get_return_type_idx_value(self) -&gt; str:\n        \"\"\"\n        Return the string associated to the `return_type_idx`\n\n        :returns: string\n        \"\"\"\n        if self.return_type_idx_value is None:\n            self.return_type_idx_value = self.CM.get_type(self.return_type_idx)\n        return self.return_type_idx_value\n\n    def get_parameters_off_value(self) -&gt; str:\n        \"\"\"\n        Return the string associated to the `parameters_off`\n\n        :returns: string\n        \"\"\"\n        if self.parameters_off_value is None:\n            params = self.CM.get_type_list(self.parameters_off)\n            self.parameters_off_value = '(' + ' '.join(params) + ')'\n        return self.parameters_off_value\n\n    def show(self) -&gt; None:\n        bytecode._PrintSubBanner(\"Proto Item\")\n        bytecode._PrintDefault(\n            \"shorty_idx=%d return_type_idx=%d parameters_off=%d\\n\"\n            % (self.shorty_idx, self.return_type_idx, self.parameters_off)\n        )\n        bytecode._PrintDefault(\n            \"shorty_idx_value=%s return_type_idx_value=%s parameters_off_value=%s\\n\"\n            % (\n                self.shorty_idx_value,\n                self.return_type_idx_value,\n                self.parameters_off_value,\n            )\n        )\n\n    def get_obj(self) -&gt; bytes:\n        if self.parameters_off != 0:\n            self.parameters_off = self.CM.get_obj_by_offset(\n                self.parameters_off\n            ).get_off()\n\n        return self.CM.packer[\"3I\"].pack(\n            self.shorty_idx, self.return_type_idx, self.parameters_off\n        )\n\n    def get_raw(self) -&gt; bytes:\n        return self.get_obj()\n\n    def get_length(self) -&gt; int:\n        return len(self.get_obj())\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ProtoIdItem.__init__","title":"<code>__init__(buff, cm)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a Buff object of the <code>proto_id_item</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def __init__(self, buff: BinaryIO, cm: ClassManager):\n    \"\"\"\n    :param buff: a string which represents a Buff object of the `proto_id_item`\n    :param cm: a `ClassManager` object\n    \"\"\"\n    self.CM = cm\n    self.offset = buff.tell()\n\n    self.shorty_idx, self.return_type_idx, self.parameters_off = cm.packer[\n        \"3I\"\n    ].unpack(buff.read(12))\n\n    self.shorty_idx_value = self.CM.get_string(self.shorty_idx)\n    self.return_type_idx_value = self.CM.get_type(self.return_type_idx)\n    self.parameters_off_value = None\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ProtoIdItem.get_parameters_off","title":"<code>get_parameters_off()</code>","text":"<p>Return the offset from the start of the file to the list of parameter types for this prototype, or 0 if this prototype has no parameters</p> <p>Returns:</p> Type Description <code>int</code> <p>the offset</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_parameters_off(self) -&gt; int:\n    \"\"\"\n    Return the offset from the start of the file to the list of parameter types for this prototype, or 0 if this prototype has no parameters\n\n    :returns: the offset\n    \"\"\"\n    return self.parameters_off\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ProtoIdItem.get_parameters_off_value","title":"<code>get_parameters_off_value()</code>","text":"<p>Return the string associated to the <code>parameters_off</code></p> <p>Returns:</p> Type Description <code>str</code> <p>string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_parameters_off_value(self) -&gt; str:\n    \"\"\"\n    Return the string associated to the `parameters_off`\n\n    :returns: string\n    \"\"\"\n    if self.parameters_off_value is None:\n        params = self.CM.get_type_list(self.parameters_off)\n        self.parameters_off_value = '(' + ' '.join(params) + ')'\n    return self.parameters_off_value\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ProtoIdItem.get_return_type_idx","title":"<code>get_return_type_idx()</code>","text":"<p>Return the index into the <code>type_ids</code> list for the return type of this prototype</p> <p>Returns:</p> Type Description <code>int</code> <p>the index</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_return_type_idx(self) -&gt; int:\n    \"\"\"\n    Return the index into the `type_ids` list for the return type of this prototype\n\n    :returns: the index\n    \"\"\"\n    return self.return_type_idx\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ProtoIdItem.get_return_type_idx_value","title":"<code>get_return_type_idx_value()</code>","text":"<p>Return the string associated to the <code>return_type_idx</code></p> <p>Returns:</p> Type Description <code>str</code> <p>string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_return_type_idx_value(self) -&gt; str:\n    \"\"\"\n    Return the string associated to the `return_type_idx`\n\n    :returns: string\n    \"\"\"\n    if self.return_type_idx_value is None:\n        self.return_type_idx_value = self.CM.get_type(self.return_type_idx)\n    return self.return_type_idx_value\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ProtoIdItem.get_shorty_idx","title":"<code>get_shorty_idx()</code>","text":"<p>Return the index into the <code>string_ids</code> list for the short-form descriptor string of this prototype</p> <p>Returns:</p> Type Description <code>int</code> <p>the index</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_shorty_idx(self) -&gt; int:\n    \"\"\"\n    Return the index into the `string_ids` list for the short-form descriptor string of this prototype\n\n    :returns: the index\n    \"\"\"\n    return self.shorty_idx\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.ProtoIdItem.get_shorty_idx_value","title":"<code>get_shorty_idx_value()</code>","text":"<p>Return the string associated to the <code>shorty_idx</code></p> <p>Returns:</p> Type Description <code>str</code> <p>string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_shorty_idx_value(self) -&gt; str:\n    \"\"\"\n    Return the string associated to the `shorty_idx`\n\n    :returns: string\n    \"\"\"\n    if self.shorty_idx_value is None:\n        self.shorty_idx_value = self.CM.get_string(self.shorty_idx)\n    return self.shorty_idx_value\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.SparseSwitch","title":"<code>SparseSwitch</code>","text":"<p>This class can parse a SparseSwitch instruction</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>bytes</code> <p>a Buff object which represents a buffer where the instruction is stored</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class SparseSwitch:\n    \"\"\"\n    This class can parse a SparseSwitch instruction\n\n    :param buff: a Buff object which represents a buffer where the instruction is stored\n    \"\"\"\n\n    # FIXME: why is this not a subclass of Instruction?\n    def __init__(self, cm: ClassManager, buff: bytes) -&gt; None:\n        self.OP = 0x0\n        self.notes = []\n        self.CM = cm\n\n        self.format_general_size = calcsize(\"2H\")\n        self.ident, self.size = cm.packer[\"2H\"].unpack(buff[0:4])\n\n        self.keys = []\n        self.targets = []\n\n        idx = self.format_general_size\n        for i in range(0, self.size):\n            self.keys.append(cm.packer[\"l\"].unpack(buff[idx : idx + 4])[0])\n            idx += 4\n\n        for i in range(0, self.size):\n            self.targets.append(cm.packer[\"l\"].unpack(buff[idx : idx + 4])[0])\n            idx += 4\n\n    def add_note(self, msg: str) -&gt; None:\n        \"\"\"\n        Add a note to this instruction\n\n        :param msg: the message\n        \"\"\"\n        self.notes.append(msg)\n\n    def get_notes(self) -&gt; list[str]:\n        \"\"\"\n        Get all notes from this instruction\n\n        :returns: a list of note strings\n        \"\"\"\n        return self.notes\n\n    def get_op_value(self) -&gt; int:\n        \"\"\"\n        Get the value of the opcode\n\n        :returns: the value\n        \"\"\"\n        return self.ident\n\n    def get_keys(self) -&gt; list[int]:\n        \"\"\"\n        Return the keys of the instruction\n\n        :returns: a list of long (integer)\n        \"\"\"\n        return self.keys\n\n    def get_values(self) -&gt; list[int]:\n        return self.get_keys()\n\n    def get_targets(self) -&gt; list[int]:\n        \"\"\"\n        Return the targets (address) of the instruction\n\n        :returns: a list of long (integer)\n        \"\"\"\n        return self.targets\n\n    def get_output(self, idx: int = -1) -&gt; str:\n        \"\"\"\n        Return an additional output of the instruction\n\n        :returns: additional output string\n        \"\"\"\n        return \" \".join(\"%x\" % i for i in self.keys)\n\n    def get_operands(self, idx: int = -1) -&gt; str:\n        \"\"\"\n        Return an additional output of the instruction\n\n        :returns: additional output string\n        \"\"\"\n        return []\n\n    def get_formatted_operands(self) -&gt; None:\n        return None\n\n    def get_name(self) -&gt; str:\n        \"\"\"\n        Return the name of the instruction\n\n        :returns: name string\n        \"\"\"\n        return \"sparse-switch-payload\"\n\n    def show_buff(self, pos: int) -&gt; str:\n        \"\"\"\n        Return the display of the instruction\n\n        :returns: display string\n        \"\"\"\n        buff = self.get_name() + \" \"\n        for i in range(0, len(self.keys)):\n            buff += \"{:x}:{:x} \".format(self.keys[i], self.targets[i])\n\n        return buff\n\n    def show(self, pos) -&gt; None:\n        \"\"\"\n        Print the instruction\n        \"\"\"\n        print(self.show_buff(pos), end=' ')\n\n    def get_length(self) -&gt; int:\n        return self.format_general_size + (self.size * calcsize('&lt;L')) * 2\n\n    def get_raw(self) -&gt; bytes:\n        return (\n            self.CM.packer[\"2H\"].pack(self.ident, self.size)\n            + b''.join(self.CM.packer[\"l\"].pack(i) for i in self.keys)\n            + b''.join(self.CM.packer[\"l\"].pack(i) for i in self.targets)\n        )\n\n    def get_hex(self) -&gt; str:\n        \"\"\"\n        Returns a HEX String, separated by spaces every byte\n\n        :returns: hex string\n        \"\"\"\n        s = binascii.hexlify(self.get_raw()).decode('ascii')\n        return \" \".join(s[i : i + 2] for i in range(0, len(s), 2))\n\n    def disasm(self) -&gt; str:\n        # FIXME:\n        return self.show_buff(None)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.SparseSwitch.add_note","title":"<code>add_note(msg)</code>","text":"<p>Add a note to this instruction</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>the message</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def add_note(self, msg: str) -&gt; None:\n    \"\"\"\n    Add a note to this instruction\n\n    :param msg: the message\n    \"\"\"\n    self.notes.append(msg)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.SparseSwitch.get_hex","title":"<code>get_hex()</code>","text":"<p>Returns a HEX String, separated by spaces every byte</p> <p>Returns:</p> Type Description <code>str</code> <p>hex string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_hex(self) -&gt; str:\n    \"\"\"\n    Returns a HEX String, separated by spaces every byte\n\n    :returns: hex string\n    \"\"\"\n    s = binascii.hexlify(self.get_raw()).decode('ascii')\n    return \" \".join(s[i : i + 2] for i in range(0, len(s), 2))\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.SparseSwitch.get_keys","title":"<code>get_keys()</code>","text":"<p>Return the keys of the instruction</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>a list of long (integer)</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_keys(self) -&gt; list[int]:\n    \"\"\"\n    Return the keys of the instruction\n\n    :returns: a list of long (integer)\n    \"\"\"\n    return self.keys\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.SparseSwitch.get_name","title":"<code>get_name()</code>","text":"<p>Return the name of the instruction</p> <p>Returns:</p> Type Description <code>str</code> <p>name string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_name(self) -&gt; str:\n    \"\"\"\n    Return the name of the instruction\n\n    :returns: name string\n    \"\"\"\n    return \"sparse-switch-payload\"\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.SparseSwitch.get_notes","title":"<code>get_notes()</code>","text":"<p>Get all notes from this instruction</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>a list of note strings</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_notes(self) -&gt; list[str]:\n    \"\"\"\n    Get all notes from this instruction\n\n    :returns: a list of note strings\n    \"\"\"\n    return self.notes\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.SparseSwitch.get_op_value","title":"<code>get_op_value()</code>","text":"<p>Get the value of the opcode</p> <p>Returns:</p> Type Description <code>int</code> <p>the value</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_op_value(self) -&gt; int:\n    \"\"\"\n    Get the value of the opcode\n\n    :returns: the value\n    \"\"\"\n    return self.ident\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.SparseSwitch.get_operands","title":"<code>get_operands(idx=-1)</code>","text":"<p>Return an additional output of the instruction</p> <p>Returns:</p> Type Description <code>str</code> <p>additional output string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_operands(self, idx: int = -1) -&gt; str:\n    \"\"\"\n    Return an additional output of the instruction\n\n    :returns: additional output string\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.SparseSwitch.get_output","title":"<code>get_output(idx=-1)</code>","text":"<p>Return an additional output of the instruction</p> <p>Returns:</p> Type Description <code>str</code> <p>additional output string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_output(self, idx: int = -1) -&gt; str:\n    \"\"\"\n    Return an additional output of the instruction\n\n    :returns: additional output string\n    \"\"\"\n    return \" \".join(\"%x\" % i for i in self.keys)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.SparseSwitch.get_targets","title":"<code>get_targets()</code>","text":"<p>Return the targets (address) of the instruction</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>a list of long (integer)</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_targets(self) -&gt; list[int]:\n    \"\"\"\n    Return the targets (address) of the instruction\n\n    :returns: a list of long (integer)\n    \"\"\"\n    return self.targets\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.SparseSwitch.show","title":"<code>show(pos)</code>","text":"<p>Print the instruction</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def show(self, pos) -&gt; None:\n    \"\"\"\n    Print the instruction\n    \"\"\"\n    print(self.show_buff(pos), end=' ')\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.SparseSwitch.show_buff","title":"<code>show_buff(pos)</code>","text":"<p>Return the display of the instruction</p> <p>Returns:</p> Type Description <code>str</code> <p>display string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def show_buff(self, pos: int) -&gt; str:\n    \"\"\"\n    Return the display of the instruction\n\n    :returns: display string\n    \"\"\"\n    buff = self.get_name() + \" \"\n    for i in range(0, len(self.keys)):\n        buff += \"{:x}:{:x} \".format(self.keys[i], self.targets[i])\n\n    return buff\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.StringDataItem","title":"<code>StringDataItem</code>","text":"<p>This class can parse a <code>string_data_item</code> of a dex file</p> <p>Strings in Dalvik files might not be representable in python! This is due to the fact, that you can store any UTF-16 character inside a Dalvik file, but this string might not be decodeable in python as it can contain invalid surrogate-pairs.</p> <p>To circumvent this issue, this class has different methods how to access the string. There are also some fallbacks implemented to make a \"invalid\" string printable in python. Dalvik uses MUTF-8 as encoding for the strings. This encoding has the advantage to allow for null terminated strings in UTF-8 encoding, as the null character maps to something else. Therefore you can use get_data to retrieve the actual data of the string and can handle encoding yourself. If you want a representation of the string, which should be printable in python you ca use get which escapes invalid characters.</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class StringDataItem:\n    \"\"\"\n    This class can parse a `string_data_item` of a dex file\n\n    Strings in Dalvik files might not be representable in python!\n    This is due to the fact, that you can store any UTF-16 character inside\n    a Dalvik file, but this string might not be decodeable in python as it can\n    contain invalid surrogate-pairs.\n\n    To circumvent this issue, this class has different methods how to access the\n    string. There are also some fallbacks implemented to make a \"invalid\" string\n    printable in python.\n    Dalvik uses MUTF-8 as encoding for the strings. This encoding has the\n    advantage to allow for null terminated strings in UTF-8 encoding, as the\n    null character maps to something else.\n    Therefore you can use [get_data][androguard.core.dex.StringDataItem.get_data] to retrieve the actual data of the\n    string and can handle encoding yourself.\n    If you want a representation of the string, which should be printable in\n    python you ca use [get][androguard.core.dex.StringDataItem.get] which escapes invalid characters.\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm: ClassManager) -&gt; None:\n        \"\"\"\n        :param buff: a string which represents a Buff object of the `string_data_item`\n        :param cm: a `ClassManager` object\n        \"\"\"\n        self.CM = cm\n\n        self.offset = buff.tell()\n\n        # Content of string_data_item\n        self.utf16_size = readuleb128(cm, buff)\n        self.data = read_null_terminated_string(buff)\n\n    def get_utf16_size(self) -&gt; int:\n        \"\"\"\n        Return the size of this string, in UTF-16 code units\n\n        :returns: the size of the string\n        \"\"\"\n        return self.utf16_size\n\n    def get_data(self) -&gt; str:\n        \"\"\"\n        Return a series of MUTF-8 code units (a.k.a. octets, a.k.a. bytes) followed by a byte of value 0\n\n        :returns: string\n        \"\"\"\n        return self.data + b\"\\x00\"\n\n    def set_off(self, off: int) -&gt; None:\n        self.offset = off\n\n    def get_off(self) -&gt; int:\n        return self.offset\n\n    def get(self) -&gt; str:\n        \"\"\"\n        Returns a str object\n\n        :returns: string\n        \"\"\"\n        try:\n            return mutf8.decode(self.data)\n        except UnicodeDecodeError:\n            logger.error(\"Impossible to decode {}\".format(self.data))\n            return \"ANDROGUARD[INVALID_STRING] {}\".format(self.data)\n\n    def show(self) -&gt; None:\n        bytecode._PrintSubBanner(\"String Data Item\")\n        bytecode._PrintDefault(\n            \"utf16_size=%d data=%s\\n\" % (self.utf16_size, repr(self.get()))\n        )\n\n    def get_obj(self) -&gt; list:\n        return []\n\n    def get_raw(self) -&gt; bytes:\n        \"\"\"\n        Returns the raw string including the ULEB128 coded length\n        and null byte string terminator\n\n        :returns: bytes\n        \"\"\"\n        return writeuleb128(self.CM, self.utf16_size) + self.data + b\"\\x00\"\n\n    def get_length(self) -&gt; int:\n        \"\"\"\n        Get the length of the raw string including the ULEB128 coded\n        length and the null byte terminator\n\n        :return: int\n        \"\"\"\n        return len(writeuleb128(self.CM, self.utf16_size)) + len(self.data) + 1\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.StringDataItem.__init__","title":"<code>__init__(buff, cm)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a Buff object of the <code>string_data_item</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def __init__(self, buff: BinaryIO, cm: ClassManager) -&gt; None:\n    \"\"\"\n    :param buff: a string which represents a Buff object of the `string_data_item`\n    :param cm: a `ClassManager` object\n    \"\"\"\n    self.CM = cm\n\n    self.offset = buff.tell()\n\n    # Content of string_data_item\n    self.utf16_size = readuleb128(cm, buff)\n    self.data = read_null_terminated_string(buff)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.StringDataItem.get","title":"<code>get()</code>","text":"<p>Returns a str object</p> <p>Returns:</p> Type Description <code>str</code> <p>string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get(self) -&gt; str:\n    \"\"\"\n    Returns a str object\n\n    :returns: string\n    \"\"\"\n    try:\n        return mutf8.decode(self.data)\n    except UnicodeDecodeError:\n        logger.error(\"Impossible to decode {}\".format(self.data))\n        return \"ANDROGUARD[INVALID_STRING] {}\".format(self.data)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.StringDataItem.get_data","title":"<code>get_data()</code>","text":"<p>Return a series of MUTF-8 code units (a.k.a. octets, a.k.a. bytes) followed by a byte of value 0</p> <p>Returns:</p> Type Description <code>str</code> <p>string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_data(self) -&gt; str:\n    \"\"\"\n    Return a series of MUTF-8 code units (a.k.a. octets, a.k.a. bytes) followed by a byte of value 0\n\n    :returns: string\n    \"\"\"\n    return self.data + b\"\\x00\"\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.StringDataItem.get_length","title":"<code>get_length()</code>","text":"<p>Get the length of the raw string including the ULEB128 coded length and the null byte terminator</p> <p>Returns:</p> Type Description <code>int</code> <p>int</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_length(self) -&gt; int:\n    \"\"\"\n    Get the length of the raw string including the ULEB128 coded\n    length and the null byte terminator\n\n    :return: int\n    \"\"\"\n    return len(writeuleb128(self.CM, self.utf16_size)) + len(self.data) + 1\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.StringDataItem.get_raw","title":"<code>get_raw()</code>","text":"<p>Returns the raw string including the ULEB128 coded length and null byte string terminator</p> <p>Returns:</p> Type Description <code>bytes</code> <p>bytes</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_raw(self) -&gt; bytes:\n    \"\"\"\n    Returns the raw string including the ULEB128 coded length\n    and null byte string terminator\n\n    :returns: bytes\n    \"\"\"\n    return writeuleb128(self.CM, self.utf16_size) + self.data + b\"\\x00\"\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.StringDataItem.get_utf16_size","title":"<code>get_utf16_size()</code>","text":"<p>Return the size of this string, in UTF-16 code units</p> <p>Returns:</p> Type Description <code>int</code> <p>the size of the string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_utf16_size(self) -&gt; int:\n    \"\"\"\n    Return the size of this string, in UTF-16 code units\n\n    :returns: the size of the string\n    \"\"\"\n    return self.utf16_size\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.StringIdItem","title":"<code>StringIdItem</code>","text":"<p>This class can parse a <code>string_id_item</code> of a dex file</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class StringIdItem:\n    \"\"\"\n    This class can parse a `string_id_item` of a dex file\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm: ClassManager):\n        \"\"\"\n        :param buff: a string which represents a Buff object of the str`ing_id_item\n        :param cm: a `ClassManager` object\n        \"\"\"\n        self.CM = cm\n        self.offset = buff.tell()\n\n        (self.string_data_off,) = cm.packer[\"I\"].unpack(buff.read(4))\n\n    def get_string_data_off(self) -&gt; int:\n        \"\"\"\n        Return the offset from the start of the file to the string data for this item\n\n        :returns: the offset\n        \"\"\"\n        return self.string_data_off\n\n    def set_off(self, off: int) -&gt; None:\n        self.offset = off\n\n    def get_off(self) -&gt; int:\n        return self.offset\n\n    def show(self) -&gt; None:\n        bytecode._PrintSubBanner(\"String Id Item\")\n        bytecode._PrintDefault(\"string_data_off=%x\\n\" % self.string_data_off)\n\n    def get_obj(self) -&gt; bytes:\n        if self.string_data_off != 0:\n            self.string_data_off = self.CM.get_string_by_offset(\n                self.string_data_off\n            ).get_off()\n\n        return self.CM.packer[\"I\"].pack(self.string_data_off)\n\n    def get_raw(self) -&gt; bytes:\n        return self.get_obj()\n\n    def get_length(self) -&gt; int:\n        return len(self.get_obj())\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.StringIdItem.__init__","title":"<code>__init__(buff, cm)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a Buff object of the str`ing_id_item</p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def __init__(self, buff: BinaryIO, cm: ClassManager):\n    \"\"\"\n    :param buff: a string which represents a Buff object of the str`ing_id_item\n    :param cm: a `ClassManager` object\n    \"\"\"\n    self.CM = cm\n    self.offset = buff.tell()\n\n    (self.string_data_off,) = cm.packer[\"I\"].unpack(buff.read(4))\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.StringIdItem.get_string_data_off","title":"<code>get_string_data_off()</code>","text":"<p>Return the offset from the start of the file to the string data for this item</p> <p>Returns:</p> Type Description <code>int</code> <p>the offset</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_string_data_off(self) -&gt; int:\n    \"\"\"\n    Return the offset from the start of the file to the string data for this item\n\n    :returns: the offset\n    \"\"\"\n    return self.string_data_off\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.TryItem","title":"<code>TryItem</code>","text":"<p>This class represents the <code>try_item</code> format</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a raw buffer where are the <code>try_item</code> format</p> required <code>cm</code> <code>ClassManager</code> <p>the <code>ClassManager</code></p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class TryItem:\n    \"\"\"\n    This class represents the `try_item` format\n\n    :param buff: a raw buffer where are the `try_item` format\n    :param cm: the `ClassManager`\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm: ClassManager) -&gt; None:\n        self.offset = buff.tell()\n\n        self.CM = cm\n\n        self.start_addr, self.insn_count, self.handler_off = cm.packer[\n            \"I2H\"\n        ].unpack(buff.read(8))\n\n    def set_off(self, off: int) -&gt; None:\n        self.offset = off\n\n    def get_off(self) -&gt; int:\n        return self.offset\n\n    def get_start_addr(self) -&gt; int:\n        \"\"\"\n        Get the start address of the block of code covered by this entry. The address is a count of 16-bit code units to the start of the first covered instruction.\n\n        :returns: address int\n        \"\"\"\n        return self.start_addr\n\n    def get_insn_count(self) -&gt; int:\n        \"\"\"\n        Get the number of 16-bit code units covered by this entry\n\n        :returns: int\n        \"\"\"\n        return self.insn_count\n\n    def get_handler_off(self) -&gt; int:\n        \"\"\"\n        Get the offset in bytes from the start of the associated `EncodedCatchHandlerList` to the `EncodedCatchHandler` for this entry.\n\n        :returns: int\n        \"\"\"\n        return self.handler_off\n\n    def get_raw(self) -&gt; bytes:\n        return self.CM.packer[\"I2H\"].pack(\n            self.start_addr, self.insn_count, self.handler_off\n        )\n\n    def get_length(self) -&gt; int:\n        return len(self.get_raw())\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.TryItem.get_handler_off","title":"<code>get_handler_off()</code>","text":"<p>Get the offset in bytes from the start of the associated <code>EncodedCatchHandlerList</code> to the <code>EncodedCatchHandler</code> for this entry.</p> <p>Returns:</p> Type Description <code>int</code> <p>int</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_handler_off(self) -&gt; int:\n    \"\"\"\n    Get the offset in bytes from the start of the associated `EncodedCatchHandlerList` to the `EncodedCatchHandler` for this entry.\n\n    :returns: int\n    \"\"\"\n    return self.handler_off\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.TryItem.get_insn_count","title":"<code>get_insn_count()</code>","text":"<p>Get the number of 16-bit code units covered by this entry</p> <p>Returns:</p> Type Description <code>int</code> <p>int</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_insn_count(self) -&gt; int:\n    \"\"\"\n    Get the number of 16-bit code units covered by this entry\n\n    :returns: int\n    \"\"\"\n    return self.insn_count\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.TryItem.get_start_addr","title":"<code>get_start_addr()</code>","text":"<p>Get the start address of the block of code covered by this entry. The address is a count of 16-bit code units to the start of the first covered instruction.</p> <p>Returns:</p> Type Description <code>int</code> <p>address int</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_start_addr(self) -&gt; int:\n    \"\"\"\n    Get the start address of the block of code covered by this entry. The address is a count of 16-bit code units to the start of the first covered instruction.\n\n    :returns: address int\n    \"\"\"\n    return self.start_addr\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.TypeHIdItem","title":"<code>TypeHIdItem</code>","text":"<p>This class can parse a list of <code>type_id_item</code> of a dex file</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class TypeHIdItem:\n    \"\"\"\n    This class can parse a list of `type_id_item` of a dex file\n    \"\"\"\n\n    def __init__(self, size: int, buff: BinaryIO, cm: ClassManager) -&gt; None:\n        \"\"\"\n        :param buff: a string which represents a Buff object of the list of `type_id_item`\n        :param cm: a `ClassManager` object\n        \"\"\"\n        self.CM = cm\n\n        self.offset = buff.tell()\n\n        self.type = [TypeIdItem(buff, cm) for i in range(0, size)]\n\n    def get_type(self) -&gt; list[TypeIdItem]:\n        \"\"\"\n        Return the list of `type_id_item`\n\n        :returns: a list of `TypeIdItem` objects\n        \"\"\"\n        return self.type\n\n    def get(self, idx: int) -&gt; int:\n        try:\n            return self.type[idx].get_descriptor_idx()\n        except IndexError:\n            return -1\n\n    def set_off(self, off: int) -&gt; None:\n        self.offset = off\n\n    def get_off(self) -&gt; int:\n        return self.offset\n\n    def show(self) -&gt; None:\n        bytecode._PrintSubBanner(\"Type List Item\")\n        for i in self.type:\n            i.show()\n\n    def get_obj(self) -&gt; list[TypeIdItem]:\n        return [i for i in self.type]\n\n    def get_raw(self) -&gt; bytes:\n        return b''.join(i.get_raw() for i in self.type)\n\n    def get_length(self) -&gt; int:\n        length = 0\n        for i in self.type:\n            length += i.get_length()\n        return length\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.TypeHIdItem.__init__","title":"<code>__init__(size, buff, cm)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a Buff object of the list of <code>type_id_item</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def __init__(self, size: int, buff: BinaryIO, cm: ClassManager) -&gt; None:\n    \"\"\"\n    :param buff: a string which represents a Buff object of the list of `type_id_item`\n    :param cm: a `ClassManager` object\n    \"\"\"\n    self.CM = cm\n\n    self.offset = buff.tell()\n\n    self.type = [TypeIdItem(buff, cm) for i in range(0, size)]\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.TypeHIdItem.get_type","title":"<code>get_type()</code>","text":"<p>Return the list of <code>type_id_item</code></p> <p>Returns:</p> Type Description <code>list[TypeIdItem]</code> <p>a list of <code>TypeIdItem</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_type(self) -&gt; list[TypeIdItem]:\n    \"\"\"\n    Return the list of `type_id_item`\n\n    :returns: a list of `TypeIdItem` objects\n    \"\"\"\n    return self.type\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.TypeIdItem","title":"<code>TypeIdItem</code>","text":"<p>This class can parse a <code>type_id_item</code> of a dex file</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class TypeIdItem:\n    \"\"\"\n    This class can parse a `type_id_item` of a dex file\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm: ClassManager):\n        \"\"\"\n        :param buff: a string which represents a Buff object of the `type_id_item`\n        :param cm: a `ClassManager` object\n        \"\"\"\n        self.CM = cm\n        self.offset = buff.tell()\n\n        (self.descriptor_idx,) = cm.packer[\"I\"].unpack(buff.read(4))\n        self.descriptor_idx_value = self.CM.get_string(self.descriptor_idx)\n\n    def get_descriptor_idx(self) -&gt; int:\n        \"\"\"\n        Return the index into the string_ids list for the descriptor string of this type\n\n        :returns: int\n        \"\"\"\n        return self.descriptor_idx\n\n    def get_descriptor_idx_value(self) -&gt; str:\n        \"\"\"\n        Return the string associated to the descriptor\n\n        :returns: string\n        \"\"\"\n        return self.descriptor_idx_value\n\n    def show(self) -&gt; None:\n        bytecode._PrintSubBanner(\"Type Id Item\")\n        bytecode._PrintDefault(\n            \"descriptor_idx=%d descriptor_idx_value=%s\\n\"\n            % (self.descriptor_idx, self.descriptor_idx_value)\n        )\n\n    def get_obj(self) -&gt; bytes:\n        return self.CM.packer[\"I\"].pack(self.descriptor_idx)\n\n    def get_raw(self) -&gt; bytes:\n        return self.get_obj()\n\n    def get_length(self) -&gt; int:\n        return len(self.get_obj())\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.TypeIdItem.__init__","title":"<code>__init__(buff, cm)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a Buff object of the <code>type_id_item</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def __init__(self, buff: BinaryIO, cm: ClassManager):\n    \"\"\"\n    :param buff: a string which represents a Buff object of the `type_id_item`\n    :param cm: a `ClassManager` object\n    \"\"\"\n    self.CM = cm\n    self.offset = buff.tell()\n\n    (self.descriptor_idx,) = cm.packer[\"I\"].unpack(buff.read(4))\n    self.descriptor_idx_value = self.CM.get_string(self.descriptor_idx)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.TypeIdItem.get_descriptor_idx","title":"<code>get_descriptor_idx()</code>","text":"<p>Return the index into the string_ids list for the descriptor string of this type</p> <p>Returns:</p> Type Description <code>int</code> <p>int</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_descriptor_idx(self) -&gt; int:\n    \"\"\"\n    Return the index into the string_ids list for the descriptor string of this type\n\n    :returns: int\n    \"\"\"\n    return self.descriptor_idx\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.TypeIdItem.get_descriptor_idx_value","title":"<code>get_descriptor_idx_value()</code>","text":"<p>Return the string associated to the descriptor</p> <p>Returns:</p> Type Description <code>str</code> <p>string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_descriptor_idx_value(self) -&gt; str:\n    \"\"\"\n    Return the string associated to the descriptor\n\n    :returns: string\n    \"\"\"\n    return self.descriptor_idx_value\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.TypeItem","title":"<code>TypeItem</code>","text":"<p>This class can parse a <code>type_item</code> of a dex file</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a buff object of the <code>type_item</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class TypeItem:\n    \"\"\"\n    This class can parse a `type_item` of a dex file\n\n    :param buff: a string which represents a buff object of the `type_item`\n    :param cm: a `ClassManager` object\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm: ClassManager) -&gt; None:\n        self.CM = cm\n        (self.type_idx,) = cm.packer[\"H\"].unpack(buff.read(2))\n\n    def get_type_idx(self):\n        \"\"\"\n        Return the index into the `type_ids` list\n\n        :returns: the index\n        \"\"\"\n        return self.type_idx\n\n    def get_string(self):\n        \"\"\"\n        Return the type string\n\n        :returns: the type string\n        \"\"\"\n        return self.CM.get_type(self.type_idx)\n\n    def show(self):\n        bytecode._PrintSubBanner(\"Type Item\")\n        bytecode._PrintDefault(\"type_idx=%d\\n\" % self.type_idx)\n\n    def get_obj(self):\n        return self.CM.packer[\"H\"].pack(self.type_idx)\n\n    def get_raw(self):\n        return self.get_obj()\n\n    def get_length(self):\n        return len(self.get_obj())\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.TypeItem.get_string","title":"<code>get_string()</code>","text":"<p>Return the type string</p> <p>Returns:</p> Type Description <p>the type string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_string(self):\n    \"\"\"\n    Return the type string\n\n    :returns: the type string\n    \"\"\"\n    return self.CM.get_type(self.type_idx)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.TypeItem.get_type_idx","title":"<code>get_type_idx()</code>","text":"<p>Return the index into the <code>type_ids</code> list</p> <p>Returns:</p> Type Description <p>the index</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_type_idx(self):\n    \"\"\"\n    Return the index into the `type_ids` list\n\n    :returns: the index\n    \"\"\"\n    return self.type_idx\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.TypeList","title":"<code>TypeList</code>","text":"<p>This class can parse a <code>type_list</code> of a dex file</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a string which represents a Buff object of the <code>type_list</code></p> required <code>cm</code> <code>ClassManager</code> <p>a <code>ClassManager</code> object</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>class TypeList:\n    \"\"\"\n    This class can parse a `type_list` of a dex file\n\n    :param buff: a string which represents a Buff object of the `type_list`\n    :param cm: a `ClassManager` object\n    \"\"\"\n\n    def __init__(self, buff: BinaryIO, cm: ClassManager) -&gt; None:\n        self.CM = cm\n        self.offset = buff.tell()\n        (self.size,) = cm.packer[\"I\"].unpack(buff.read(4))\n\n        self.list = [TypeItem(buff, cm) for _ in range(self.size)]\n\n        self.pad = b\"\"\n        if self.size % 2 != 0:\n            self.pad = buff.read(2)\n\n        self.len_pad = len(self.pad)\n\n    def get_pad(self):\n        \"\"\"\n        Return the alignment string\n\n        :returns: the alignment string\n        \"\"\"\n        return self.pad\n\n    def get_type_list_off(self):\n        \"\"\"\n        Return the offset of the item\n\n        :returns: the offset\n        \"\"\"\n        return self.offset\n\n    def get_string(self):\n        \"\"\"\n        Return the concatenation of all strings\n\n        :returns: concatenated strings\n        \"\"\"\n        return ' '.join(i.get_string() for i in self.list)\n\n    def get_size(self):\n        \"\"\"\n        Return the size of the list, in entries\n\n        :returns: the size of the list\n        \"\"\"\n        return self.size\n\n    def get_list(self):\n        \"\"\"\n        Return the list of [TypeItem][androguard.core.dex.TypeItem]\n\n        :returns: a list of `TypeItem` objects\n        \"\"\"\n        return self.list\n\n    def set_off(self, off: int):\n        self.offset = off\n\n    def get_off(self):\n        return self.offset + self.len_pad\n\n    def show(self):\n        bytecode._PrintSubBanner(\"Type List\")\n        bytecode._PrintDefault(\"size=%d\\n\" % self.size)\n\n        for i in self.list:\n            i.show()\n\n    def get_obj(self):\n        return self.pad + self.CM.packer[\"I\"].pack(self.size)\n\n    def get_raw(self):\n        return self.get_obj() + b''.join(i.get_raw() for i in self.list)\n\n    def get_length(self):\n        length = len(self.get_obj())\n\n        for i in self.list:\n            length += i.get_length()\n\n        return length\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.TypeList.get_list","title":"<code>get_list()</code>","text":"<p>Return the list of TypeItem</p> <p>Returns:</p> Type Description <p>a list of <code>TypeItem</code> objects</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_list(self):\n    \"\"\"\n    Return the list of [TypeItem][androguard.core.dex.TypeItem]\n\n    :returns: a list of `TypeItem` objects\n    \"\"\"\n    return self.list\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.TypeList.get_pad","title":"<code>get_pad()</code>","text":"<p>Return the alignment string</p> <p>Returns:</p> Type Description <p>the alignment string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_pad(self):\n    \"\"\"\n    Return the alignment string\n\n    :returns: the alignment string\n    \"\"\"\n    return self.pad\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.TypeList.get_size","title":"<code>get_size()</code>","text":"<p>Return the size of the list, in entries</p> <p>Returns:</p> Type Description <p>the size of the list</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_size(self):\n    \"\"\"\n    Return the size of the list, in entries\n\n    :returns: the size of the list\n    \"\"\"\n    return self.size\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.TypeList.get_string","title":"<code>get_string()</code>","text":"<p>Return the concatenation of all strings</p> <p>Returns:</p> Type Description <p>concatenated strings</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_string(self):\n    \"\"\"\n    Return the concatenation of all strings\n\n    :returns: concatenated strings\n    \"\"\"\n    return ' '.join(i.get_string() for i in self.list)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.TypeList.get_type_list_off","title":"<code>get_type_list_off()</code>","text":"<p>Return the offset of the item</p> <p>Returns:</p> Type Description <p>the offset</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_type_list_off(self):\n    \"\"\"\n    Return the offset of the item\n\n    :returns: the offset\n    \"\"\"\n    return self.offset\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.clean_name_instruction","title":"<code>clean_name_instruction(instruction)</code>","text":"<p>USED IN ELSIM</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def clean_name_instruction(instruction: Instruction) -&gt; str:\n    \"\"\"USED IN ELSIM\"\"\"\n    op_value = instruction.get_op_value()\n\n    # goto range\n    if 0x28 &lt;= op_value &lt;= 0x2A:\n        return \"goto\"\n\n    return instruction.get_name()\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.determineException","title":"<code>determineException(vm, m)</code>","text":"<p>Returns try-catch handler inside the method.</p> <p>Parameters:</p> Name Type Description Default <code>vm</code> <code>DEX</code> <p>a <code>DEX</code> object</p> required <code>m</code> <code>EncodedMethod</code> <p><code>EncodedMethod</code> object</p> required <p>Returns:</p> Type Description <code>list[list]</code> <p>a list</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def determineException(vm: DEX, m: EncodedMethod) -&gt; list[list]:\n    \"\"\"\n    Returns try-catch handler inside the method.\n\n    :param vm: a `DEX` object\n    :param m: `EncodedMethod` object\n    :return: a list\n    \"\"\"\n    # no exceptions !\n    if m.get_code().get_tries_size() &lt;= 0:\n        return []\n\n    h_off = {}\n\n    handler_catch_list = m.get_code().get_handlers()\n\n    for try_item in m.get_code().get_tries():\n        offset_handler = (\n            try_item.get_handler_off() + handler_catch_list.get_off()\n        )\n        if offset_handler in h_off:\n            h_off[offset_handler].append([try_item])\n        else:\n            h_off[offset_handler] = []\n            h_off[offset_handler].append([try_item])\n\n    # print m.get_name(), \"\\t HANDLER_CATCH_LIST SIZE\", handler_catch_list.size, handler_catch_list.get_offset()\n    for handler_catch in handler_catch_list.get_list():\n        if handler_catch.get_off() not in h_off:\n            continue\n\n        for i in h_off[handler_catch.get_off()]:\n            i.append(handler_catch)\n\n    exceptions = []\n    # print m.get_name(), h_off\n    for i in h_off:\n        for value in h_off[i]:\n            try_value = value[0]\n\n            # start,end\n            z = [\n                try_value.get_start_addr() * 2,\n                (try_value.get_start_addr() * 2)\n                + (try_value.get_insn_count() * 2)\n                - 1,\n            ]\n\n            handler_catch = value[1]\n\n            # exceptions\n            for handler in handler_catch.get_handlers():\n                z.append(\n                    [\n                        vm.get_cm_type(handler.get_type_idx()),\n                        handler.get_addr() * 2,\n                    ]\n                )\n\n            if handler_catch.get_size() &lt;= 0:\n                z.append(\n                    [\n                        \"Ljava/lang/Throwable;\",\n                        handler_catch.get_catch_all_addr() * 2,\n                    ]\n                )\n\n            exceptions.append(z)\n\n    # print m.get_name(), exceptions\n    return exceptions\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.determineNext","title":"<code>determineNext(i, cur_idx, m)</code>","text":"<p>Determine the next offsets inside the bytecode of an EncodedMethod. The offsets are calculated in number of bytes from the start of the method. Note, that offsets inside the bytecode are denoted in 16bit units but this method returns actual bytes!</p> <p>Offsets inside the opcode are counted from the beginning of the opcode.</p> <p>The returned type is a list, as branching opcodes will have multiple paths. <code>if</code> and <code>switch</code> opcodes will return more than one item in the list, while <code>throw</code>, <code>return</code> and <code>goto</code> opcodes will always return a list with length one.</p> <p>An offset of -1 indicates that the method is exited, for example by <code>throw</code> or <code>return</code>.</p> <p>If the entered opcode is not branching or jumping, an empty list is returned.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>Instruction</code> <p>the current Instruction</p> required <code>cur_idx</code> <code>int</code> <p>Index of the instruction</p> required <code>m</code> <code>EncodedMethod</code> <p>the current method</p> required <p>Returns:</p> Type Description <code>list</code> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def determineNext(i: Instruction, cur_idx: int, m: EncodedMethod) -&gt; list:\n    \"\"\"\n    Determine the next offsets inside the bytecode of an [EncodedMethod][androguard.core.dex.EncodedMethod].\n    The offsets are calculated in number of bytes from the start of the method.\n    Note, that offsets inside the bytecode are denoted in 16bit units but this method returns actual bytes!\n\n    Offsets inside the opcode are counted from the beginning of the opcode.\n\n    The returned type is a list, as branching opcodes will have multiple paths.\n    `if` and `switch` opcodes will return more than one item in the list, while\n    `throw`, `return` and `goto` opcodes will always return a list with length one.\n\n    An offset of -1 indicates that the method is exited, for example by `throw` or `return`.\n\n    If the entered opcode is not branching or jumping, an empty list is returned.\n\n    :param i: the current Instruction\n    :param cur_idx: Index of the instruction\n    :param m: the current method\n    :return:\n    \"\"\"\n    op_value = i.get_op_value()\n\n    if (op_value == 0x27) or (0x0E &lt;= op_value &lt;= 0x11):\n        # throw + return*\n        return [-1]\n    elif 0x28 &lt;= op_value &lt;= 0x2A:\n        # all kind of 'goto'\n        off = i.get_ref_off() * 2\n        return [off + cur_idx]\n    elif 0x32 &lt;= op_value &lt;= 0x3D:\n        # all kind of 'if'\n        off = i.get_ref_off() * 2\n        return [cur_idx + i.get_length(), off + cur_idx]\n    elif op_value in (0x2B, 0x2C):\n        # packed/sparse switch\n        # Code flow will continue after the switch command\n        x = [cur_idx + i.get_length()]\n\n        # The payload must be read at the offset position\n        code = m.get_code().get_bc()\n        off = i.get_ref_off() * 2\n\n        # See DEX bytecode documentation:\n        # \"the instructions must be located on even-numbered bytecode offsets (that is, 4-byte aligned).\n        # In order to meet this requirement, dex generation tools must\n        # emit an extra nop instruction as a spacer if such an instruction would otherwise be unaligned.\"\n        remaining = (off + cur_idx) % 4\n        padding = 0 if remaining == 0 else (4 - remaining)\n        if padding != 0:\n            logger.warning(\n                \"Switch payload not aligned, assume stuff and add {} bytes...\".format(\n                    padding\n                )\n            )\n        data = code.get_ins_off(off + cur_idx + padding)\n\n        # TODO: some malware points to invalid code\n        # Does Android ignores the nop and searches for the switch payload?\n        # So we make sure that this is a switch payload\n        if data and (\n            isinstance(data, PackedSwitch) or isinstance(data, SparseSwitch)\n        ):\n            for target in data.get_targets():\n                x.append(target * 2 + cur_idx)\n        else:\n            logger.warning(\n                \"Could not determine payload of switch command at offset {} inside {}! \"\n                \"Possibly broken bytecode?\".format(cur_idx, m)\n            )\n\n        return x\n    return []\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.get_access_flags_string","title":"<code>get_access_flags_string(value)</code>","text":"<p>Transform an access flag field to the corresponding string</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>the value of the access flags</p> required <p>Returns:</p> Type Description <code>str</code> <p>the transformed string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_access_flags_string(value: int) -&gt; str:\n    \"\"\"\n    Transform an access flag field to the corresponding string\n\n    :param value: the value of the access flags\n\n    :returns: the transformed string\n    \"\"\"\n    flags = []\n    for k, v in ACCESS_FLAGS.items():\n        if (k &amp; value) == k:\n            flags.append(v)\n\n    return \" \".join(flags)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.get_bytecodes_method","title":"<code>get_bytecodes_method(dex_object, analysis_object, method)</code>","text":"<p>return a string representation of method and its code. Wraps get_bytecodes_methodx</p> <p>Parameters:</p> Name Type Description Default <code>dex_object</code> <p>unused</p> required <code>analysis_object</code> <code>Analysis</code> <p>the <code>Analysis</code> object containing the class</p> required <code>method</code> <code>EncodedMethod</code> <p>the <code>EncodedMethod</code> to get</p> required Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_bytecodes_method(\n    dex_object, analysis_object: Analysis, method: EncodedMethod\n) -&gt; str:\n    \"\"\"return a string representation of method and its code. Wraps [get_bytecodes_methodx][androguard.core.dex.get_bytecodes_methodx]\n\n    :param dex_object: unused\n    :param analysis_object: the `Analysis` object containing the class\n    :param method: the `EncodedMethod` to get\n    \"\"\"\n    mx = analysis_object.get_method(method)\n    return get_bytecodes_methodx(method, mx)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.get_bytecodes_methodx","title":"<code>get_bytecodes_methodx(method, mx)</code>","text":"<p>return a string representation of a method and its code</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>EncodedMethod</code> <p>the associated<code>EncodedMethod</code> to get</p> required <code>mx</code> <code>MethodAnalysis</code> <p>the associated <code>MethodAnalysis</code> to get</p> required <p>Returns:</p> Type Description <code>str</code> <p>the string representation</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_bytecodes_methodx(method: EncodedMethod, mx: MethodAnalysis) -&gt; str:\n    \"\"\"return a string representation of a method and its code\n\n    :param method: the associated`EncodedMethod` to get\n    :param mx: the associated `MethodAnalysis` to get\n    :returns: the string representation\n    \"\"\"\n    basic_blocks = mx.basic_blocks.gets()\n    i_buffer = \"\"\n\n    idx = 0\n    nb = 0\n\n    i_buffer += \"# {}-&gt;{}{} [access_flags={}]\\n#\\n\".format(\n        method.get_class_name(),\n        method.get_name(),\n        method.get_descriptor(),\n        method.get_access_flags_string(),\n    )\n    if method.code is not None:\n        i_buffer += get_params_info(\n            method.code.get_registers_size(), method.get_descriptor()\n        )\n\n        for i in basic_blocks:\n            bb_buffer = \"\"\n            ins_buffer = \"\"\n\n            bb_buffer += \"%s : \" % i.name\n\n            # TODO using the generator object as a list again is not ideal...\n            instructions = list(i.get_instructions())\n            for ins in instructions:\n                ins_buffer += \"\\t%-8d(%08x) \" % (nb, idx)\n                ins_buffer += \"{:&lt;20} {}\".format(\n                    ins.get_name(), ins.get_output(idx)\n                )\n\n                op_value = ins.get_op_value()\n                if ins == instructions[-1] and i.childs != []:\n                    # packed/sparse-switch\n                    if (op_value == 0x2B or op_value == 0x2C) and len(\n                        i.childs\n                    ) &gt; 1:\n                        values = i.get_special_ins(idx).get_values()\n                        bb_buffer += \"[ D:%s \" % i.childs[0][2].name\n                        bb_buffer += (\n                            ' '.join(\n                                \"%d:%s\" % (values[j], i.childs[j + 1][2].name)\n                                for j in range(0, len(i.childs) - 1)\n                            )\n                            + \" ]\"\n                        )\n                    else:\n                        # if len(i.childs) == 2:\n                        #    i_buffer += \"%s[ %s%s \" % (branch_false_color, i.childs[0][2].name, branch_true_color))\n                        #    print_fct(' '.join(\"%s\" % c[2].name for c in i.childs[1:]) + \" ]%s\" % normal_color)\n                        # else:\n                        bb_buffer += (\n                            \"[ \"\n                            + ' '.join(\"%s\" % c[2].name for c in i.childs)\n                            + \" ]\"\n                        )\n\n                idx += ins.get_length()\n                nb += 1\n\n                ins_buffer += \"\\n\"\n\n            if i.get_exception_analysis() is not None:\n                ins_buffer += \"\\t%s\\n\" % (i.exception_analysis.show_buff())\n\n            i_buffer += bb_buffer + \"\\n\" + ins_buffer + \"\\n\"\n\n    return i_buffer\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.get_instruction","title":"<code>get_instruction(cm, op_value, buff)</code>","text":"<p>Return the Instruction for the given opcode</p> <p>Parameters:</p> Name Type Description Default <code>cm</code> <code>ClassManager</code> <p><code>ClassManager</code> to propagate to <code>Instruction</code></p> required <code>op_value</code> <code>int</code> <p>integer value of the instruction</p> required <code>buff</code> <code>bytearray</code> <p>Bytecode starting with the <code>instruction</code></p> required <p>Returns:</p> Type Description <code>Instruction</code> <p>the parsed <code>Instruction</code></p> <p>Raises:</p> Type Description <code>InvalidInstruction</code> <p>if instruction is invalid</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_instruction(\n    cm: ClassManager, op_value: int, buff: bytearray\n) -&gt; Instruction:\n    \"\"\"\n    Return the [Instruction][androguard.core.dex.Instruction] for the given opcode\n\n    :param cm: `ClassManager` to propagate to `Instruction`\n    :param op_value: integer value of the instruction\n    :param buff: Bytecode starting with the `instruction`\n    :raises InvalidInstruction: if instruction is invalid\n    :returns: the parsed `Instruction`\n    \"\"\"\n    try:\n        return DALVIK_OPCODES_FORMAT[op_value][0](cm, buff)\n    except struct.error:\n        # FIXME: there are other possible errors too...\n        raise InvalidInstruction(\n            \"Invalid Instruction for '0x{:02x}': {}\".format(\n                op_value, repr(buff)\n            )\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.get_kind","title":"<code>get_kind(cm, kind, value)</code>","text":"<p>Return the value of the 'kind' argument</p> <p>Parameters:</p> Name Type Description Default <code>cm</code> <code>ClassManager</code> <p>a ClassManager object</p> required <code>kind</code> <code>int</code> <p>the type of the 'kind' argument</p> required <code>value</code> <code>int</code> <p>the value of the 'kind' argument</p> required <p>Returns:</p> Type Description <code>str</code> <p>string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_kind(cm: ClassManager, kind: int, value: int) -&gt; str:\n    \"\"\"\n    Return the value of the 'kind' argument\n\n    :param cm: a ClassManager object\n    :param kind: the type of the 'kind' argument\n    :param value: the value of the 'kind' argument\n\n    :returns: string\n    \"\"\"\n    if kind == Kind.METH:\n        method = cm.get_method_ref(value)\n        class_name = method.get_class_name()\n        name = method.get_name()\n        descriptor = method.get_descriptor()\n\n        return \"{}-&gt;{}{}\".format(class_name, name, descriptor)\n\n    elif kind == Kind.STRING:\n        return cm.get_string(value)\n\n    # TODO: unused?\n    elif kind == Kind.RAW_STRING:\n        return cm.get_string(value)\n\n    elif kind == Kind.FIELD:\n        class_name, proto, field_name = cm.get_field(value)\n        return \"{}-&gt;{} {}\".format(class_name, field_name, proto)\n\n    elif kind == Kind.TYPE:\n        return cm.get_type(value)\n\n    elif kind == Kind.VTABLE_OFFSET:\n        return \"vtable[0x%x]\" % value\n\n    elif kind == Kind.FIELD_OFFSET:\n        return \"field[0x%x]\" % value\n\n    elif kind == Kind.INLINE_METHOD:\n        buff = \"inline[0x%x]\" % value\n\n        # FIXME: depends of the android version ...\n        if len(INLINE_METHODS) &gt; value:\n            elem = INLINE_METHODS[value]\n            buff += \" {}-&gt;{}{}\".format(elem[0], elem[1], elem[2])\n\n        return buff\n\n    return None\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.get_optimized_instruction","title":"<code>get_optimized_instruction(cm, op_value, buff)</code>","text":"<p>Return the Instruction for the given optimized opcode</p> <p>Parameters:</p> Name Type Description Default <code>cm</code> <code>ClassManager</code> <p><code>ClassManager</code> to propagate to <code>Instruction</code></p> required <code>op_value</code> <code>int</code> <p>integer value of the instruction</p> required <code>buff</code> <code>bytearray</code> <p>Bytecode starting with the <code>instruction</code></p> required <p>Returns:</p> Type Description <code>Instruction</code> <p>the parsed <code>Instruction</code></p> <p>Raises:</p> Type Description <code>InvalidInstruction</code> <p>if instruction is invalid</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_optimized_instruction(\n    cm: ClassManager, op_value: int, buff: bytearray\n) -&gt; Instruction:\n    \"\"\"Return the [Instruction][androguard.core.dex.Instruction] for the given optimized opcode\n\n    :param cm: `ClassManager` to propagate to `Instruction`\n    :param op_value: integer value of the instruction\n    :param buff: Bytecode starting with the `instruction`\n    :raises InvalidInstruction: if instruction is invalid\n    :returns: the parsed `Instruction`\n    \"\"\"\n    try:\n        return DALVIK_OPCODES_OPTIMIZED[op_value][0](cm, buff)\n    except struct.error:\n        # FIXME: there are other possible errors too...\n        raise InvalidInstruction(\n            \"Invalid Instruction for '0x{:04x}': {}\".format(\n                op_value, repr(buff)\n            )\n        )\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.get_params_info","title":"<code>get_params_info(nb, proto)</code>","text":"<p>return a string of parameter info given a function prototype (proto)</p> <p>Parameters:</p> Name Type Description Default <code>nb</code> <code>int</code> <p>the number of parameters</p> required <code>proto</code> <code>str</code> <p>the function prototype with parameters</p> required <p>Returns:</p> Type Description <code>str</code> <p>a string representation of the parameter info</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_params_info(nb: int, proto: str) -&gt; str:\n    \"\"\"return a string of parameter info given a function prototype (proto)\n\n    :param nb: the number of parameters\n    :param proto: the function prototype with parameters\n    :returns: a string representation of the parameter info\n    \"\"\"\n    i_buffer = \"# Parameters:\\n\"\n\n    ret = proto.split(')')\n    params = ret[0][1:].split()\n    if params:\n        i_buffer += \"# - local registers: v%d...v%d\\n\" % (\n            0,\n            nb - len(params) - 1,\n        )\n        j = 0\n        for i in range(nb - len(params), nb):\n            i_buffer += \"# - v%d:%s\\n\" % (i, get_type(params[j]))\n            j += 1\n    else:\n        i_buffer += \"# local registers: v%d...v%d\\n\" % (0, nb - 1)\n\n    i_buffer += \"#\\n# - return:%s\\n\\n\" % get_type(ret[1])\n\n    return i_buffer\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.get_type","title":"<code>get_type(atype, size=None)</code>","text":"<p>Retrieve the type of a descriptor (e.g : I)</p> <p>Returns:</p> Type Description <code>str</code> <p>the descriptor string</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def get_type(atype: str, size: Union[int, None] = None) -&gt; str:\n    \"\"\"\n    Retrieve the type of a descriptor (e.g : I)\n    :returns: the descriptor string\n    \"\"\"\n    if atype.startswith('java.lang'):\n        atype = atype.replace('java.lang.', '')\n    res = TYPE_DESCRIPTOR.get(atype.lstrip('java.lang'))\n    if res is None:\n        if atype[0] == 'L':\n            res = atype[1:-1].replace('/', '.')\n        elif atype[0] == '[':\n            if size is None:\n                res = '%s[]' % get_type(atype[1:])\n            else:\n                res = '{}[{}]'.format(get_type(atype[1:]), size)\n        else:\n            res = atype\n    return res\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.read_null_terminated_string","title":"<code>read_null_terminated_string(f)</code>","text":"<p>Read a null terminated string from a file-like object.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>IO</code> <p>file-like object</p> required <p>Returns:</p> Type Description <code>bytearray</code> <p>the bytes of the string read</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def read_null_terminated_string(f: IO) -&gt; bytearray:\n    \"\"\"\n    Read a null terminated string from a file-like object.\n    :param f: file-like object\n\n    :returns: the bytes of the string read\n    \"\"\"\n    x = []\n    while True:\n        z = f.read(128)\n        if 0 in z:\n            s = z.split(b'\\x00', 1)\n            x.append(s[0])\n            idx = f.tell()\n            f.seek(idx - len(s[1]))\n            break\n        else:\n            x.append(z)\n    return b''.join(x)\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.readsleb128","title":"<code>readsleb128(cm, buff)</code>","text":"<p>Read a signed LEB128 at the current position of the buffer.</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a file like object</p> required <p>Returns:</p> Type Description <code>int</code> <p>decoded sLEB128</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def readsleb128(cm: ClassManager, buff: BinaryIO) -&gt; int:\n    \"\"\"\n    Read a signed LEB128 at the current position of the buffer.\n\n    :param buff: a file like object\n    :return: decoded sLEB128\n    \"\"\"\n    result = 0\n    shift = 0\n\n    for x in range(0, 5):\n        cur = get_byte(cm, buff)\n        result |= (cur &amp; 0x7F) &lt;&lt; shift\n        shift += 7\n\n        if not cur &amp; 0x80:\n            bit_left = max(32 - shift, 0)\n            result = result &lt;&lt; bit_left\n            if result &gt; 0x7FFFFFFF:\n                result = (0x7FFFFFFF &amp; result) - 0x80000000\n            result = result &gt;&gt; bit_left\n            break\n\n    return result\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.readuleb128","title":"<code>readuleb128(cm, buff)</code>","text":"<p>Read an unsigned LEB128 at the current position of the buffer</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a file like object</p> required <p>Returns:</p> Type Description <code>int</code> <p>decoded unsigned LEB128</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def readuleb128(cm: ClassManager, buff: BinaryIO) -&gt; int:\n    \"\"\"\n    Read an unsigned LEB128 at the current position of the buffer\n\n    :param buff: a file like object\n    :returns: decoded unsigned LEB128\n    \"\"\"\n    result = get_byte(cm, buff)\n    if result &gt; 0x7F:\n        cur = get_byte(cm, buff)\n        result = (result &amp; 0x7F) | ((cur &amp; 0x7F) &lt;&lt; 7)\n        if cur &gt; 0x7F:\n            cur = get_byte(cm, buff)\n            result |= (cur &amp; 0x7F) &lt;&lt; 14\n            if cur &gt; 0x7F:\n                cur = get_byte(cm, buff)\n                result |= (cur &amp; 0x7F) &lt;&lt; 21\n                if cur &gt; 0x7F:\n                    cur = get_byte(cm, buff)\n                    if cur &gt; 0x0F:\n                        logger.warning(\"possible error while decoding number\")\n                    result |= cur &lt;&lt; 28\n\n    return result\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.readuleb128p1","title":"<code>readuleb128p1(cm, buff)</code>","text":"<p>Read an unsigned LEB128p1 at the current position of the buffer. This format is the same as uLEB128 but has the ability to store the value -1.</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>a file like object</p> required <p>Returns:</p> Type Description <code>int</code> <p>decoded uLEB128p1</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def readuleb128p1(cm: ClassManager, buff: BinaryIO) -&gt; int:\n    \"\"\"\n    Read an unsigned LEB128p1 at the current position of the buffer.\n    This format is the same as uLEB128 but has the ability to store the value -1.\n\n    :param buff: a file like object\n    :return: decoded uLEB128p1\n    \"\"\"\n    return readuleb128(cm, buff) - 1\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.static_operand_instruction","title":"<code>static_operand_instruction(instruction)</code>","text":"<p>USED IN ELSIM</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def static_operand_instruction(instruction: Instruction) -&gt; str:\n    \"\"\"USED IN ELSIM\"\"\"\n    buff = \"\"\n\n    if isinstance(instruction, Instruction):\n        # get instructions without registers\n        for val in instruction.get_literals():\n            buff += \"%s\" % val\n\n    op_value = instruction.get_op_value()\n    if op_value == 0x1A or op_value == 0x1B:\n        buff += instruction.get_string()\n\n    return buff\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.writesleb128","title":"<code>writesleb128(cm, value)</code>","text":"<p>Convert an integer value to the corresponding signed LEB128</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>integer value</p> required <p>Returns:</p> Type Description <code>bytearray</code> <p>bytes</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def writesleb128(cm: ClassManager, value: int) -&gt; bytearray:\n    \"\"\"\n    Convert an integer value to the corresponding signed LEB128\n\n    :param value: integer value\n    :return: bytes\n    \"\"\"\n    remaining = value &gt;&gt; 7\n    hasMore = True\n    buff = bytearray()\n\n    if (value &amp; (-sys.maxsize - 1)) == 0:\n        end = 0\n    else:\n        end = -1\n\n    while hasMore:\n        hasMore = (remaining != end) or ((remaining &amp; 1) != ((value &gt;&gt; 6) &amp; 1))\n        tmp = 0\n        if hasMore:\n            tmp = 0x80\n\n        buff += cm.packer[\"B\"].pack((value &amp; 0x7F) | tmp)\n        value = remaining\n        remaining &gt;&gt;= 7\n\n    return buff\n</code></pre>"},{"location":"reference/androguard/core/dex/index.html#androguard.core.dex.writeuleb128","title":"<code>writeuleb128(cm, value)</code>","text":"<p>Convert an integer value to the corresponding unsigned LEB128.</p> <p>Raises a value error, if the given value is negative.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>non-negative integer</p> required <p>Returns:</p> Type Description <code>bytearray</code> <p>bytes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if given value is negative</p> Source code in <code>androguard/core/dex/__init__.py</code> <pre><code>def writeuleb128(cm: ClassManager, value: int) -&gt; bytearray:\n    \"\"\"\n    Convert an integer value to the corresponding unsigned LEB128.\n\n    Raises a value error, if the given value is negative.\n\n    :raises ValueError: if given value is negative\n    :param value: non-negative integer\n    :returns: bytes\n    \"\"\"\n    if value &lt; 0:\n        raise ValueError(\"value must be non-negative!\")\n\n    remaining = value &gt;&gt; 7\n\n    buff = bytearray()\n    while remaining &gt; 0:\n        buff += cm.packer[\"B\"].pack(((value &amp; 0x7F) | 0x80))\n\n        value = remaining\n        remaining &gt;&gt;= 7\n\n    buff += cm.packer[\"B\"].pack(value &amp; 0x7F)\n    return buff\n</code></pre>"},{"location":"reference/androguard/core/dex/dex_types.html","title":"dex_types","text":""},{"location":"reference/androguard/core/dex/dex_types.html#androguard.core.dex.dex_types.Kind","title":"<code>Kind</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>This Enum is used to determine the kind of argument inside an Dalvik instruction.</p> <p>It is used to reference the actual item instead of the refernece index from the <code>ClassManager</code> when disassembling the bytecode.</p> Source code in <code>androguard/core/dex/dex_types.py</code> <pre><code>class Kind(IntEnum):\n    \"\"\"\n    This Enum is used to determine the kind of argument\n    inside an Dalvik instruction.\n\n    It is used to reference the actual item instead of the refernece index\n    from the `ClassManager` when disassembling the bytecode.\n    \"\"\"\n\n    # Indicates a method reference\n    METH = 0\n    # Indicates that opcode argument is a string index\n    STRING = 1\n    # Indicates a field reference\n    FIELD = 2\n    # Indicates a type reference\n    TYPE = 3\n    # indicates a prototype reference\n    PROTO = 9\n    # indicates method reference and proto reference (invoke-polymorphic)\n    METH_PROTO = 10\n    # indicates call site item\n    CALL_SITE = 11\n\n    # TODO: not very well documented\n    VARIES = 4\n    # inline lined stuff\n    INLINE_METHOD = 5\n    # static linked stuff\n    VTABLE_OFFSET = 6\n    FIELD_OFFSET = 7\n    RAW_STRING = 8\n</code></pre>"},{"location":"reference/androguard/core/dex/dex_types.html#androguard.core.dex.dex_types.Operand","title":"<code>Operand</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enumeration used for the operand type of opcodes</p> Source code in <code>androguard/core/dex/dex_types.py</code> <pre><code>class Operand(IntEnum):\n    \"\"\"\n    Enumeration used for the operand type of opcodes\n    \"\"\"\n\n    REGISTER = 0\n    LITERAL = 1\n    RAW = 2\n    OFFSET = 3\n    # FIXME: KIND is used in combination with others, ie the Kind enum, therefore it is 0x100...\n    # thus we could use an IntFlag here as well\n    KIND = 0x100\n</code></pre>"},{"location":"reference/androguard/core/dex/dex_types.html#androguard.core.dex.dex_types.TypeMapItem","title":"<code>TypeMapItem</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enumeration used for map_items</p> Source code in <code>androguard/core/dex/dex_types.py</code> <pre><code>class TypeMapItem(IntEnum):\n    \"\"\"Enumeration used for map_items\"\"\"\n    HEADER_ITEM = 0x0\n    STRING_ID_ITEM = 0x1\n    TYPE_ID_ITEM = 0x2\n    PROTO_ID_ITEM = 0x3\n    FIELD_ID_ITEM = 0x4\n    METHOD_ID_ITEM = 0x5\n    CLASS_DEF_ITEM = 0x6\n    CALL_SITE_ITEM = 0x7  # New in DEX038\n    METHOD_HANDLE_ITEM = 0x8  # New in DEX038\n    MAP_LIST = 0x1000\n    TYPE_LIST = 0x1001\n    ANNOTATION_SET_REF_LIST = 0x1002\n    ANNOTATION_SET_ITEM = 0x1003\n    CLASS_DATA_ITEM = 0x2000\n    CODE_ITEM = 0x2001\n    STRING_DATA_ITEM = 0x2002\n    DEBUG_INFO_ITEM = 0x2003\n    ANNOTATION_ITEM = 0x2004\n    ENCODED_ARRAY_ITEM = 0x2005\n    ANNOTATIONS_DIRECTORY_ITEM = 0x2006\n    HIDDENAPI_CLASS_DATA_ITEM = 0xF000\n\n    @staticmethod\n    def _get_dependencies():\n        return OrderedDict(\n            [\n                (TypeMapItem.HEADER_ITEM, set()),\n                (TypeMapItem.STRING_ID_ITEM, {TypeMapItem.STRING_DATA_ITEM}),\n                (TypeMapItem.TYPE_ID_ITEM, {TypeMapItem.STRING_ID_ITEM}),\n                (\n                    TypeMapItem.PROTO_ID_ITEM,\n                    {\n                        TypeMapItem.STRING_ID_ITEM,\n                        TypeMapItem.TYPE_ID_ITEM,\n                        TypeMapItem.TYPE_LIST,\n                    },\n                ),\n                (\n                    TypeMapItem.FIELD_ID_ITEM,\n                    {TypeMapItem.STRING_ID_ITEM, TypeMapItem.TYPE_ID_ITEM},\n                ),\n                (\n                    TypeMapItem.METHOD_ID_ITEM,\n                    {\n                        TypeMapItem.STRING_ID_ITEM,\n                        TypeMapItem.TYPE_ID_ITEM,\n                        TypeMapItem.PROTO_ID_ITEM,\n                    },\n                ),\n                (\n                    TypeMapItem.CLASS_DEF_ITEM,\n                    {\n                        TypeMapItem.TYPE_ID_ITEM,\n                        TypeMapItem.TYPE_LIST,\n                        TypeMapItem.STRING_ID_ITEM,\n                        TypeMapItem.DEBUG_INFO_ITEM,\n                        TypeMapItem.ANNOTATIONS_DIRECTORY_ITEM,\n                        TypeMapItem.CLASS_DATA_ITEM,\n                        TypeMapItem.ENCODED_ARRAY_ITEM,\n                    },\n                ),\n                (\n                    TypeMapItem.CALL_SITE_ITEM,\n                    {\n                        TypeMapItem.METHOD_HANDLE_ITEM,\n                        TypeMapItem.STRING_ID_ITEM,\n                        TypeMapItem.METHOD_ID_ITEM,\n                    },\n                ),\n                # TODO: check if this is correct\n                (\n                    TypeMapItem.METHOD_HANDLE_ITEM,\n                    {TypeMapItem.FIELD_ID_ITEM, TypeMapItem.METHOD_ID_ITEM},\n                ),\n                # TODO: check if this is correct\n                (TypeMapItem.MAP_LIST, set()),\n                (TypeMapItem.TYPE_LIST, {TypeMapItem.TYPE_ID_ITEM}),\n                (\n                    TypeMapItem.ANNOTATION_SET_REF_LIST,\n                    {TypeMapItem.ANNOTATION_SET_ITEM},\n                ),\n                (\n                    TypeMapItem.ANNOTATION_SET_ITEM,\n                    {TypeMapItem.ANNOTATION_ITEM},\n                ),\n                (\n                    TypeMapItem.CLASS_DATA_ITEM,\n                    {TypeMapItem.FIELD_ID_ITEM, TypeMapItem.METHOD_ID_ITEM},\n                ),\n                (\n                    TypeMapItem.CODE_ITEM,\n                    {TypeMapItem.DEBUG_INFO_ITEM, TypeMapItem.TYPE_ID_ITEM},\n                ),\n                (TypeMapItem.STRING_DATA_ITEM, set()),\n                (\n                    TypeMapItem.DEBUG_INFO_ITEM,\n                    {TypeMapItem.STRING_ID_ITEM, TypeMapItem.TYPE_ID_ITEM},\n                ),\n                (\n                    TypeMapItem.ANNOTATION_ITEM,\n                    {\n                        TypeMapItem.PROTO_ID_ITEM,\n                        TypeMapItem.STRING_ID_ITEM,\n                        TypeMapItem.TYPE_ID_ITEM,\n                        TypeMapItem.FIELD_ID_ITEM,\n                        TypeMapItem.METHOD_ID_ITEM,\n                    },\n                ),\n                (\n                    TypeMapItem.ENCODED_ARRAY_ITEM,\n                    {\n                        TypeMapItem.PROTO_ID_ITEM,\n                        TypeMapItem.STRING_ID_ITEM,\n                        TypeMapItem.TYPE_ID_ITEM,\n                        TypeMapItem.FIELD_ID_ITEM,\n                        TypeMapItem.METHOD_ID_ITEM,\n                    },\n                ),\n                (\n                    TypeMapItem.ANNOTATIONS_DIRECTORY_ITEM,\n                    {\n                        TypeMapItem.FIELD_ID_ITEM,\n                        TypeMapItem.METHOD_ID_ITEM,\n                        TypeMapItem.ANNOTATION_SET_ITEM,\n                    },\n                ),\n                (TypeMapItem.HIDDENAPI_CLASS_DATA_ITEM, set()),\n            ]\n        )\n\n    @staticmethod\n    def determine_load_order():\n        dependencies = TypeMapItem._get_dependencies()\n        ordered = dict()\n        while dependencies:\n            found_next = False\n            for type_name, unloaded in dependencies.items():\n                if not unloaded:\n                    ordered[type_name] = len(ordered)\n                    found_next = True\n                    break\n            if found_next is False:\n                raise Exception('recursive loading dependency')\n            dependencies.pop(type_name)\n            for unloaded in dependencies.values():\n                unloaded.discard(type_name)\n        return ordered\n</code></pre>"},{"location":"reference/androguard/core/mutf8/index.html","title":"mutf8","text":""},{"location":"reference/androguard/core/resources/index.html","title":"resources","text":""},{"location":"reference/androguard/core/resources/public.html","title":"public","text":""},{"location":"reference/androguard/decompiler/index.html","title":"decompiler","text":""},{"location":"reference/androguard/decompiler/basic_blocks.html","title":"basic_blocks","text":""},{"location":"reference/androguard/decompiler/control_flow.html","title":"control_flow","text":""},{"location":"reference/androguard/decompiler/control_flow.html#androguard.decompiler.control_flow.derived_sequence","title":"<code>derived_sequence(graph)</code>","text":"<p>Compute the derived sequence of the graph G The intervals of G are collapsed into nodes, intervals of these nodes are built, and the process is repeated iteratively until we obtain a single node (if the graph is not irreducible)</p> Source code in <code>androguard/decompiler/control_flow.py</code> <pre><code>def derived_sequence(graph):\n    \"\"\"\n    Compute the derived sequence of the graph G\n    The intervals of G are collapsed into nodes, intervals of these nodes are\n    built, and the process is repeated iteratively until we obtain a single\n    node (if the graph is not irreducible)\n    \"\"\"\n    deriv_seq = [graph]\n    deriv_interv = []\n    single_node = False\n\n    while not single_node:\n\n        interv_graph, interv_heads = intervals(graph)\n        deriv_interv.append(interv_heads)\n\n        single_node = len(interv_graph) == 1\n        if not single_node:\n            deriv_seq.append(interv_graph)\n\n        graph = interv_graph\n        graph.compute_rpo()\n\n    return deriv_seq, deriv_interv\n</code></pre>"},{"location":"reference/androguard/decompiler/control_flow.html#androguard.decompiler.control_flow.intervals","title":"<code>intervals(graph)</code>","text":"<p>Compute the intervals of the graph Returns interval_graph: a graph of the intervals of G interv_heads: a dict of (header node, interval)</p> Source code in <code>androguard/decompiler/control_flow.py</code> <pre><code>def intervals(graph):\n    \"\"\"\n    Compute the intervals of the graph\n    Returns\n    interval_graph: a graph of the intervals of G\n    interv_heads: a dict of (header node, interval)\n    \"\"\"\n    interval_graph = Graph()  # graph of intervals\n    heads = [graph.entry]  # list of header nodes\n    interv_heads = {}  # interv_heads[i] = interval of header i\n    processed = {i: False for i in graph}\n    edges = defaultdict(list)\n\n    while heads:\n        head = heads.pop(0)\n\n        if not processed[head]:\n            processed[head] = True\n            interv_heads[head] = Interval(head)\n\n            # Check if there is a node which has all its predecessor in the\n            # current interval. If there is, add that node to the interval and\n            # repeat until all the possible nodes have been added.\n            change = True\n            while change:\n                change = False\n                for node in graph.rpo[1:]:\n                    if all(\n                        p in interv_heads[head] for p in graph.all_preds(node)\n                    ):\n                        change |= interv_heads[head].add_node(node)\n\n            # At this stage, a node which is not in the interval, but has one\n            # of its predecessor in it, is the header of another interval. So\n            # we add all such nodes to the header list.\n            for node in graph:\n                if node not in interv_heads[head] and node not in heads:\n                    if any(\n                        p in interv_heads[head] for p in graph.all_preds(node)\n                    ):\n                        edges[interv_heads[head]].append(node)\n                        assert node not in heads\n                        heads.append(node)\n\n            interval_graph.add_node(interv_heads[head])\n            interv_heads[head].compute_end(graph)\n\n    # Edges is a mapping of 'Interval -&gt; [header nodes of interval successors]'\n    for interval, heads in edges.items():\n        for head in heads:\n            interval_graph.add_edge(interval, interv_heads[head])\n\n    interval_graph.entry = graph.entry.interval\n    if graph.exit:\n        interval_graph.exit = graph.exit.interval\n\n    return interval_graph, interv_heads\n</code></pre>"},{"location":"reference/androguard/decompiler/dast.html","title":"dast","text":"<p>This file is a simplified version of writer.py that outputs an AST instead of source code.</p>"},{"location":"reference/androguard/decompiler/dataflow.html","title":"dataflow","text":""},{"location":"reference/androguard/decompiler/dataflow.html#androguard.decompiler.dataflow.build_def_use","title":"<code>build_def_use(graph, lparams)</code>","text":"<p>Builds the Def-Use and Use-Def (DU/UD) chains of the variables of the method.</p> Source code in <code>androguard/decompiler/dataflow.py</code> <pre><code>def build_def_use(graph, lparams):\n    \"\"\"\n    Builds the Def-Use and Use-Def (DU/UD) chains of the variables of the\n    method.\n    \"\"\"\n    analysis = reach_def_analysis(graph, lparams)\n\n    UD = defaultdict(list)\n    for node in graph.rpo:\n        for i, ins in node.get_loc_with_ins():\n            for var in ins.get_used_vars():\n                # var not in analysis.def_to_loc: test that the register\n                # exists. It is possible that it is not the case, when a\n                # variable is of a type which is stored on multiple registers\n                # e.g: a 'double' stored in v3 is also present in v4, so a call\n                # to foo(v3), will in fact call foo(v3, v4).\n                if var not in analysis.def_to_loc:\n                    continue\n                ldefs = analysis.defs[node]\n                prior_def = -1\n                for v in ldefs.get(var, set()):\n                    if prior_def &lt; v &lt; i:\n                        prior_def = v\n                if prior_def &gt;= 0:\n                    UD[var, i].append(prior_def)\n                else:\n                    intersect = analysis.def_to_loc[var].intersection(\n                        analysis.R[node]\n                    )\n                    UD[var, i].extend(intersect)\n    DU = defaultdict(list)\n    for var_loc, defs_loc in UD.items():\n        var, loc = var_loc\n        for def_loc in defs_loc:\n            DU[var, def_loc].append(loc)\n\n    return UD, DU\n</code></pre>"},{"location":"reference/androguard/decompiler/dataflow.html#androguard.decompiler.dataflow.clear_path","title":"<code>clear_path(graph, reg, loc1, loc2)</code>","text":"<p>Check that the path from loc1 to loc2 is clear. We have to check that there is no side effect between the two location points. We also have to check that the variable <code>reg</code> is not redefined along one of the possible pathes from loc1 to loc2.</p> Source code in <code>androguard/decompiler/dataflow.py</code> <pre><code>def clear_path(graph, reg, loc1, loc2):\n    \"\"\"\n    Check that the path from loc1 to loc2 is clear.\n    We have to check that there is no side effect between the two location\n    points. We also have to check that the variable `reg` is not redefined\n    along one of the possible pathes from loc1 to loc2.\n    \"\"\"\n    logger.debug('clear_path: reg(%s), loc1(%s), loc2(%s)', reg, loc1, loc2)\n    node1 = graph.get_node_from_loc(loc1)\n    node2 = graph.get_node_from_loc(loc2)\n    # If both instructions are in the same node, we only have to check that the\n    # path is clear inside the node\n    if node1 is node2:\n        return clear_path_node(graph, reg, loc1 + 1, loc2)\n\n    # If instructions are in different nodes, we also have to check the nodes\n    # in the path between the two locations.\n    if not clear_path_node(graph, reg, loc1 + 1, node1.ins_range[1]):\n        return False\n    path = build_path(graph, node1, node2)\n    for node in path:\n        locs = node.ins_range\n        end_loc = loc2 if (locs[0] &lt;= loc2 &lt;= locs[1]) else locs[1]\n        if not clear_path_node(graph, reg, locs[0], end_loc):\n            return False\n    return True\n</code></pre>"},{"location":"reference/androguard/decompiler/dataflow.html#androguard.decompiler.dataflow.dead_code_elimination","title":"<code>dead_code_elimination(graph, du, ud)</code>","text":"<p>Run a dead code elimination pass. Instructions are checked to be dead. If it is the case, we remove them and we update the DU &amp; UD chains of its variables to check for further dead instructions.</p> Source code in <code>androguard/decompiler/dataflow.py</code> <pre><code>def dead_code_elimination(graph, du, ud):\n    \"\"\"\n    Run a dead code elimination pass.\n    Instructions are checked to be dead. If it is the case, we remove them and\n    we update the DU &amp; UD chains of its variables to check for further dead\n    instructions.\n    \"\"\"\n    for node in graph.rpo:\n        for i, ins in node.get_loc_with_ins():\n            reg = ins.get_lhs()\n            if reg is not None:\n                # If the definition is not used, we check that the instruction\n                # has no side effect. If there is one and this is a call, we\n                # remove only the unused defined variable. else, this is\n                # something like an array access, so we do nothing.\n                # Otherwise (no side effect) we can remove the instruction from\n                # the node.\n                if (reg, i) not in du:\n                    if ins.is_call():\n                        ins.remove_defined_var()\n                    elif ins.has_side_effect():\n                        continue\n                    else:\n                        # We can delete the instruction. First update the DU\n                        # chain of the variables used by the instruction to\n                        # `let them know` that they are not used anymore by the\n                        # deleted instruction.\n                        # Then remove the instruction.\n                        update_chain(graph, i, du, ud)\n                        graph.remove_ins(i)\n</code></pre>"},{"location":"reference/androguard/decompiler/dataflow.html#androguard.decompiler.dataflow.register_propagation","title":"<code>register_propagation(graph, du, ud)</code>","text":"<p>Propagate the temporary registers between instructions and remove them if necessary. We process the nodes of the graph in reverse post order. For each instruction in the node, we look at the variables that it uses. For each of these variables we look where it is defined and if we can replace it with its definition. We have to be careful to the side effects some instructions may have. To do the propagation, we use the computed DU and UD chains.</p> Source code in <code>androguard/decompiler/dataflow.py</code> <pre><code>def register_propagation(graph, du, ud):\n    \"\"\"\n    Propagate the temporary registers between instructions and remove them if\n    necessary.\n    We process the nodes of the graph in reverse post order. For each\n    instruction in the node, we look at the variables that it uses. For each of\n    these variables we look where it is defined and if we can replace it with\n    its definition.\n    We have to be careful to the side effects some instructions may have.\n    To do the propagation, we use the computed DU and UD chains.\n    \"\"\"\n    change = True\n    while change:\n        change = False\n        for node in graph.rpo:\n            for i, ins in node.get_loc_with_ins():\n                logger.debug('Treating instruction %d: %s', i, ins)\n                logger.debug('  Used vars: %s', ins.get_used_vars())\n                for var in ins.get_used_vars():\n                    # Get the list of locations this variable is defined at.\n                    locs = ud[var, i]\n                    logger.debug('    var %s defined in lines %s', var, locs)\n                    # If the variable is uniquely defined for this instruction\n                    # it may be eligible for propagation.\n                    if len(locs) != 1:\n                        continue\n\n                    loc = locs[0]\n                    # Methods parameters are defined with a location &lt; 0.\n                    if loc &lt; 0:\n                        continue\n                    orig_ins = graph.get_ins_from_loc(loc)\n                    logger.debug('     -&gt; %s', orig_ins)\n                    logger.debug(\n                        '     -&gt; DU(%s, %s) = %s', var, loc, du[var, loc]\n                    )\n\n                    # We defined some instructions as not propagable.\n                    # Actually this is the case only for array creation\n                    # (new foo[x])\n                    if not orig_ins.is_propagable():\n                        logger.debug('    %s not propagable...', orig_ins)\n                        continue\n\n                    if not orig_ins.get_rhs().is_const():\n                        # We only try to propagate constants and definition\n                        # points which are used at only one location.\n                        if len(du[var, loc]) &gt; 1:\n                            logger.debug(\n                                '       =&gt; variable has multiple uses'\n                                ' and is not const =&gt; skip'\n                            )\n                            continue\n\n                        # We check that the propagation is safe for all the\n                        # variables that are used in the instruction.\n                        # The propagation is not safe if there is a side effect\n                        # along the path from the definition of the variable\n                        # to its use in the instruction, or if the variable may\n                        # be redifined along this path.\n                        safe = True\n                        orig_ins_used_vars = orig_ins.get_used_vars()\n                        logger.debug(\n                            '    variables used by the original '\n                            'instruction: %s',\n                            orig_ins_used_vars,\n                        )\n                        for var2 in orig_ins_used_vars:\n                            # loc is the location of the defined variable\n                            # i is the location of the current instruction\n                            if not clear_path(graph, var2, loc, i):\n                                safe = False\n                                break\n                        if not safe:\n                            logger.debug('Propagation NOT SAFE')\n                            continue\n\n                    # We also check that the instruction itself is\n                    # propagable. If the instruction has a side effect it\n                    # cannot be propagated if there is another side effect\n                    # along the path\n                    if orig_ins.has_side_effect():\n                        if not clear_path(graph, None, loc, i):\n                            logger.debug(\n                                '        %s has side effect and the '\n                                'path is not clear !',\n                                orig_ins,\n                            )\n                            continue\n\n                    logger.debug('     =&gt; Modification of the instruction!')\n                    logger.debug('      - BEFORE: %s', ins)\n                    ins.replace(var, orig_ins.get_rhs())\n                    logger.debug('      -&gt; AFTER: %s', ins)\n                    logger.debug('\\t UD(%s, %s) : %s', var, i, ud[var, i])\n                    ud[var, i].remove(loc)\n                    logger.debug('\\t    -&gt; %s', ud[var, i])\n                    if len(ud[var, i]) == 0:\n                        ud.pop((var, i))\n                    for var2 in orig_ins.get_used_vars():\n                        # We update the UD chain of the variables we\n                        # propagate. We also have to take the\n                        # definition points of all the variables used\n                        # by the instruction and update the DU chain\n                        # with this information.\n                        old_ud = ud.get((var2, loc))\n                        logger.debug('\\t  ud(%s, %s) = %s', var2, loc, old_ud)\n                        # If the instruction use the same variable\n                        # multiple times, the second+ time the ud chain\n                        # will be None because already treated.\n                        if old_ud is None:\n                            continue\n                        ud[var2, i].extend(old_ud)\n                        logger.debug(\n                            '\\t  - ud(%s, %s) = %s', var2, i, ud[var2, i]\n                        )\n                        ud.pop((var2, loc))\n\n                        for def_loc in old_ud:\n                            du[var2, def_loc].remove(loc)\n                            du[var2, def_loc].append(i)\n\n                    new_du = du[var, loc]\n                    logger.debug('\\t new_du(%s, %s): %s', var, loc, new_du)\n                    new_du.remove(i)\n                    logger.debug('\\t    -&gt; %s', new_du)\n                    if not new_du:\n                        logger.debug('\\t  REMOVING INS %d', loc)\n                        du.pop((var, loc))\n                        graph.remove_ins(loc)\n                        change = True\n</code></pre>"},{"location":"reference/androguard/decompiler/dataflow.html#androguard.decompiler.dataflow.update_chain","title":"<code>update_chain(graph, loc, du, ud)</code>","text":"<p>Updates the DU chain of the instruction located at loc such that there is no more reference to it so that we can remove it. When an instruction is found to be dead (i.e it has no side effect, and the register defined is not used) we have to update the DU chain of all the variables that may me used by the dead instruction.</p> Source code in <code>androguard/decompiler/dataflow.py</code> <pre><code>def update_chain(graph, loc, du, ud):\n    \"\"\"\n    Updates the DU chain of the instruction located at loc such that there is\n    no more reference to it so that we can remove it.\n    When an instruction is found to be dead (i.e it has no side effect, and the\n    register defined is not used) we have to update the DU chain of all the\n    variables that may me used by the dead instruction.\n    \"\"\"\n    ins = graph.get_ins_from_loc(loc)\n    for var in ins.get_used_vars():\n        # We get the definition points of the current variable\n        for def_loc in set(ud[var, loc]):\n            # We remove the use of the variable at loc from the DU chain of\n            # the variable definition located at def_loc\n            du[var, def_loc].remove(loc)\n            ud[var, loc].remove(def_loc)\n            if not ud.get((var, loc)):\n                ud.pop((var, loc))\n            # If the DU chain of the defined variable is now empty, this means\n            # that we may have created a new dead instruction, so we check that\n            # the instruction has no side effect and we update the DU chain of\n            # the new dead instruction, and we delete it.\n            # We also make sure that def_loc is not &lt; 0. This is the case when\n            # the current variable is a method parameter.\n            if def_loc &gt;= 0 and not du[var, def_loc]:\n                du.pop((var, def_loc))\n                def_ins = graph.get_ins_from_loc(def_loc)\n                if def_ins.is_call():\n                    def_ins.remove_defined_var()\n                elif def_ins.has_side_effect():\n                    continue\n                else:\n                    update_chain(graph, def_loc, du, ud)\n                    graph.remove_ins(def_loc)\n</code></pre>"},{"location":"reference/androguard/decompiler/decompile.html","title":"decompile","text":""},{"location":"reference/androguard/decompiler/decompile.html#androguard.decompiler.decompile.DvClass","title":"<code>DvClass</code>","text":"<p>This is a wrapper for :class:<code>~androguard.core.bytecodes.dvm.ClassDefItem</code> inside the decompiler.</p> <p>At first, :py:attr:<code>methods</code> contains a list of :class:<code>~androguard.core.dex.EncodedMethod</code>, which are successively replaced by :class:<code>DvMethod</code> in the process of decompilation.</p> <p>Parameters:</p> Name Type Description Default <code>dvclass</code> <code>androguard.core.dex.ClassDefItem</code> <p>the class item</p> required <code>vma</code> <code>androguard.core.analysis.analysis.Analysis</code> <p>an Analysis object</p> required Source code in <code>androguard/decompiler/decompile.py</code> <pre><code>class DvClass:\n    \"\"\"\n    This is a wrapper for :class:`~androguard.core.bytecodes.dvm.ClassDefItem` inside the decompiler.\n\n    At first, :py:attr:`methods` contains a list of :class:`~androguard.core.dex.EncodedMethod`,\n    which are successively replaced by :class:`DvMethod` in the process of decompilation.\n\n    :param androguard.core.dex.ClassDefItem dvclass: the class item\n    :param androguard.core.analysis.analysis.Analysis vma: an Analysis object\n    \"\"\"\n\n    def __init__(\n        self, dvclass: dex.ClassDefItem, vma: analysis.Analysis\n    ) -&gt; None:\n        name = dvclass.get_name()\n        if name.find('/') &gt; 0:\n            pckg, name = name.rsplit('/', 1)\n        else:\n            pckg, name = '', name\n        self.package = pckg[1:].replace('/', '.')\n        self.name = name[:-1]\n\n        self.vma = vma\n        self.methods = dvclass.get_methods()\n        self.fields = dvclass.get_fields()\n        self.code = []\n        self.inner = False\n\n        access = dvclass.get_access_flags()\n        # If interface we remove the class and abstract keywords\n        if 0x200 &amp; access:\n            prototype = '%s %s'\n            if access &amp; 0x400:\n                access -= 0x400\n        else:\n            prototype = '%s class %s'\n\n        self.access = util.get_access_class(access)\n        self.prototype = prototype % (' '.join(self.access), self.name)\n\n        self.interfaces = dvclass.get_interfaces()\n        self.superclass = dvclass.get_superclassname()\n        self.thisclass = dvclass.get_name()\n\n        logger.debug('Class : %s', self.name)\n        logger.debug('Methods added :')\n        for meth in self.methods:\n            logger.debug(\n                '%s (%s, %s)', meth.get_method_idx(), self.name, meth.name\n            )\n        logger.debug('')\n\n    def get_methods(self) -&gt; list[dex.EncodedMethod]:\n        return self.methods\n\n    def process_method(self, num: int, doAST: bool = False) -&gt; None:\n        method = self.methods[num]\n        if not isinstance(method, DvMethod):\n            self.methods[num] = DvMethod(self.vma.get_method(method))\n            self.methods[num].process(doAST=doAST)\n        else:\n            method.process(doAST=doAST)\n\n    def process(self, doAST: bool = False) -&gt; None:\n        for i in range(len(self.methods)):\n            try:\n                self.process_method(i, doAST=doAST)\n            except Exception as e:\n                # FIXME: too broad exception?\n                logger.warning(\n                    'Error decompiling method %s: %s', self.methods[i], e\n                )\n\n    def get_ast(self) -&gt; dict:\n        fields = [get_field_ast(f) for f in self.fields]\n        methods = []\n        for m in self.methods:\n            if isinstance(m, DvMethod) and m.ast:\n                methods.append(m.get_ast())\n        isInterface = 'interface' in self.access\n        return {\n            'rawname': self.thisclass[1:-1],\n            'name': JSONWriter.parse_descriptor(self.thisclass),\n            'super': JSONWriter.parse_descriptor(self.superclass),\n            'flags': self.access,\n            'isInterface': isInterface,\n            'interfaces': list(\n                map(JSONWriter.parse_descriptor, self.interfaces)\n            ),\n            'fields': fields,\n            'methods': methods,\n        }\n\n    def get_source(self) -&gt; str:\n        source = []\n        if not self.inner and self.package:\n            source.append('package %s;\\n' % self.package)\n\n        superclass, prototype = self.superclass, self.prototype\n        if superclass is not None and superclass != 'Ljava/lang/Object;':\n            superclass = superclass[1:-1].replace('/', '.')\n            prototype += ' extends %s' % superclass\n\n        if len(self.interfaces) &gt; 0:\n            prototype += ' implements %s' % ', '.join(\n                [str(n[1:-1].replace('/', '.')) for n in self.interfaces]\n            )\n\n        source.append('%s {\\n' % prototype)\n        for field in self.fields:\n            name = field.get_name()\n            access = util.get_access_field(field.get_access_flags())\n            f_type = util.get_type(field.get_descriptor())\n            source.append('    ')\n            if access:\n                source.append(' '.join(access))\n                source.append(' ')\n            init_value = field.get_init_value()\n            if init_value:\n                value = init_value.value\n                if f_type == 'String':\n                    if value:\n                        value = '\"%s\"' % str(value).encode(\n                            \"unicode-escape\"\n                        ).decode(\"ascii\")\n                    else:\n                        # FIXME we can not check if this value here is null or \"\"\n                        # In both cases we end up here...\n                        value = '\"\"'\n                elif field.proto == 'B':\n                    # byte value: convert from unsiged int to signed and print as hex\n                    # as bytes are signed in Java\n                    value = hex(struct.unpack(\"b\", struct.pack(\"B\", value))[0])\n                source.append('{} {} = {};\\n'.format(f_type, name, value))\n            else:\n                source.append('{} {};\\n'.format(f_type, name))\n\n        for method in self.methods:\n            if isinstance(method, DvMethod):\n                source.append(method.get_source())\n\n        source.append('}\\n')\n        return ''.join(source)\n\n    def get_source_ext(self) -&gt; list[tuple[str, list]]:\n        source = []\n        if not self.inner and self.package:\n            source.append(\n                (\n                    'PACKAGE',\n                    [\n                        ('PACKAGE_START', 'package '),\n                        ('NAME_PACKAGE', '%s' % self.package),\n                        ('PACKAGE_END', ';\\n'),\n                    ],\n                )\n            )\n        list_proto = [\n            ('PROTOTYPE_ACCESS', '%s class ' % ' '.join(self.access)),\n            ('NAME_PROTOTYPE', '%s' % self.name, self.package),\n        ]\n        superclass = self.superclass\n        if superclass is not None and superclass != 'Ljava/lang/Object;':\n            superclass = superclass[1:-1].replace('/', '.')\n            list_proto.append(('EXTEND', ' extends '))\n            list_proto.append(('NAME_SUPERCLASS', '%s' % superclass))\n\n        if len(self.interfaces) &gt; 0:\n            list_proto.append(('IMPLEMENTS', ' implements '))\n            for i, interface in enumerate(self.interfaces):\n                if i != 0:\n                    list_proto.append(('COMMA', ', '))\n                list_proto.append(\n                    ('NAME_INTERFACE', interface[1:-1].replace('/', '.'))\n                )\n        list_proto.append(('PROTOTYPE_END', ' {\\n'))\n        source.append((\"PROTOTYPE\", list_proto))\n\n        for field in self.fields:\n            field_access_flags = field.get_access_flags()\n            access = [\n                util.ACCESS_FLAGS_FIELDS[flag]\n                for flag in util.ACCESS_FLAGS_FIELDS\n                if flag &amp; field_access_flags\n            ]\n            f_type = util.get_type(field.get_descriptor())\n            name = field.get_name()\n            if access:\n                access_str = '    %s ' % ' '.join(access)\n            else:\n                access_str = '    '\n\n            value = None\n            init_value = field.get_init_value()\n            if init_value:\n                value = init_value.value\n                if f_type == 'String':\n                    if value:\n                        value = ' = \"%s\"' % value.encode(\n                            \"unicode-escape\"\n                        ).decode(\"ascii\")\n                    else:\n                        # FIXME we can not check if this value here is null or \"\"\n                        # In both cases we end up here...\n                        value = ' = \"\"'\n                elif field.proto == 'B':\n                    # a byte\n                    value = ' = %s' % hex(\n                        struct.unpack(\"b\", struct.pack(\"B\", value))[0]\n                    )\n                else:\n                    value = ' = %s' % str(value)\n            if value:\n                source.append(\n                    (\n                        'FIELD',\n                        [\n                            ('FIELD_ACCESS', access_str),\n                            ('FIELD_TYPE', '%s' % f_type),\n                            ('SPACE', ' '),\n                            ('NAME_FIELD', '%s' % name, f_type, field),\n                            ('FIELD_VALUE', value),\n                            ('FIELD_END', ';\\n'),\n                        ],\n                    )\n                )\n            else:\n                source.append(\n                    (\n                        'FIELD',\n                        [\n                            ('FIELD_ACCESS', access_str),\n                            ('FIELD_TYPE', '%s' % f_type),\n                            ('SPACE', ' '),\n                            ('NAME_FIELD', '%s' % name, f_type, field),\n                            ('FIELD_END', ';\\n'),\n                        ],\n                    )\n                )\n\n        for method in self.methods:\n            if isinstance(method, DvMethod):\n                source.append((\"METHOD\", method.get_source_ext()))\n        source.append((\"CLASS_END\", [('CLASS_END', '}\\n')]))\n        return source\n\n    def show_source(self) -&gt; None:\n        print(self.get_source())\n\n    def __repr__(self):\n        return '&lt;Class(%s)&gt;' % self.name\n</code></pre>"},{"location":"reference/androguard/decompiler/decompile.html#androguard.decompiler.decompile.DvMachine","title":"<code>DvMachine</code>","text":"<p>Wrapper class for a Dalvik Object, like a DEX or ODEX file.</p> <p>The wrapper allows to take a Dalvik file and get a list of Classes out of it. The :class:<code>~androguard.decompiler.decompile.DvMachine</code> can take either an APK file directly, where all DEX files from the multidex are used, or a single DEX or ODEX file as an argument.</p> <p>At first, :py:attr:<code>classes</code> contains only :class:<code>~androguard.core.dex.ClassDefItem</code> as values. Then these objects are replaced by :class:<code>DvClass</code> items successively.</p> Source code in <code>androguard/decompiler/decompile.py</code> <pre><code>class DvMachine:\n    \"\"\"\n    Wrapper class for a Dalvik Object, like a DEX or ODEX file.\n\n    The wrapper allows to take a Dalvik file and get a list of Classes out of it.\n    The :class:`~androguard.decompiler.decompile.DvMachine` can take either an APK file directly,\n    where all DEX files from the multidex are used, or a single DEX or ODEX file as an argument.\n\n    At first, :py:attr:`classes` contains only :class:`~androguard.core.dex.ClassDefItem` as values.\n    Then these objects are replaced by :class:`DvClass` items successively.\n    \"\"\"\n\n    def __init__(self, name: str) -&gt; None:\n        \"\"\"\n\n        :param name: filename to load\n        \"\"\"\n        self.vma = analysis.Analysis()\n\n        # Proper detection which supports multidex inside APK\n        ftype = androconf.is_android(name)\n        if ftype == 'APK':\n            for d in apk.APK(name).get_all_dex():\n                self.vma.add(dex.DEX(d))\n        elif ftype == 'DEX':\n            self.vma.add(dex.DEX(readFile(name)))\n        elif ftype == 'DEY':\n            self.vma.add(dex.ODEX(readFile(name)))\n        else:\n            raise ValueError(\"Format not recognised for filename '%s'\" % name)\n\n        self.classes = {\n            dvclass.orig_class.get_name(): dvclass.orig_class\n            for dvclass in self.vma.get_classes()\n        }\n        # TODO why not?\n        # util.merge_inner(self.classes)\n\n    def get_classes(self) -&gt; list[str]:\n        \"\"\"\n        Return a list of classnames contained in this machine.\n        The format of each name is Lxxx;\n\n        :return: list of class names\n        \"\"\"\n        return list(self.classes.keys())\n\n    def get_class(self, class_name: str) -&gt; DvClass:\n        \"\"\"\n        Return the :class:`DvClass` with the given name\n\n        The name is partially matched against the known class names and the first result is returned.\n        For example, the input `foobar` will match on Lfoobar/bla/foo;\n\n        :param str class_name:\n        :return: the class matching on the name\n        :rtype: :class:`DvClass`\n        \"\"\"\n        for name, klass in self.classes.items():\n            # TODO why use the name partially?\n            if class_name in name:\n                if isinstance(klass, DvClass):\n                    return klass\n                dvclass = self.classes[name] = DvClass(klass, self.vma)\n                return dvclass\n\n    def process(self) -&gt; None:\n        \"\"\"\n        Process all classes inside the machine.\n\n        This calls :meth:`~androgaurd.decompiler.decompile.DvClass.process` on each :class:`DvClass`.\n        \"\"\"\n        for name, klass in self.classes.items():\n            logger.debug('Processing class: %s', name)\n            if isinstance(klass, DvClass):\n                klass.process()\n            else:\n                dvclass = self.classes[name] = DvClass(klass, self.vma)\n                dvclass.process()\n\n    def show_source(self) -&gt; None:\n        \"\"\"\n        Calls `show_source` on all classes inside the machine.\n        This prints the source to stdout.\n\n        This calls :meth:`~androgaurd.decompiler.decompile.DvClass.show_source` on each :class:`DvClass`.\n        \"\"\"\n        for klass in self.classes.values():\n            klass.show_source()\n\n    def process_and_show(self) -&gt; None:\n        \"\"\"\n        Run :meth:`process` and :meth:`show_source` after each other.\n        \"\"\"\n        for name, klass in sorted(self.classes.items()):\n            logger.debug('Processing class: %s', name)\n            if not isinstance(klass, DvClass):\n                klass = DvClass(klass, self.vma)\n            klass.process()\n            klass.show_source()\n\n    def get_ast(self) -&gt; dict:\n        \"\"\"\n        Processes each class with AST enabled and returns a dictionary with all single ASTs\n        Classnames as keys.\n\n        :return: an dictionary for all classes\n        :rtype: dict\n        \"\"\"\n        ret = dict()\n        for name, cls in sorted(self.classes.items()):\n            logger.debug('Processing class: %s', name)\n            if not isinstance(cls, DvClass):\n                cls = DvClass(cls, self.vma)\n            cls.process(doAST=True)\n            ret[name] = cls.get_ast()\n        return ret\n</code></pre>"},{"location":"reference/androguard/decompiler/decompile.html#androguard.decompiler.decompile.DvMachine.__init__","title":"<code>__init__(name)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>filename to load</p> required Source code in <code>androguard/decompiler/decompile.py</code> <pre><code>def __init__(self, name: str) -&gt; None:\n    \"\"\"\n\n    :param name: filename to load\n    \"\"\"\n    self.vma = analysis.Analysis()\n\n    # Proper detection which supports multidex inside APK\n    ftype = androconf.is_android(name)\n    if ftype == 'APK':\n        for d in apk.APK(name).get_all_dex():\n            self.vma.add(dex.DEX(d))\n    elif ftype == 'DEX':\n        self.vma.add(dex.DEX(readFile(name)))\n    elif ftype == 'DEY':\n        self.vma.add(dex.ODEX(readFile(name)))\n    else:\n        raise ValueError(\"Format not recognised for filename '%s'\" % name)\n\n    self.classes = {\n        dvclass.orig_class.get_name(): dvclass.orig_class\n        for dvclass in self.vma.get_classes()\n    }\n</code></pre>"},{"location":"reference/androguard/decompiler/decompile.html#androguard.decompiler.decompile.DvMachine.get_ast","title":"<code>get_ast()</code>","text":"<p>Processes each class with AST enabled and returns a dictionary with all single ASTs Classnames as keys.</p> <p>Returns:</p> Type Description <code>dict</code> <p>an dictionary for all classes</p> Source code in <code>androguard/decompiler/decompile.py</code> <pre><code>def get_ast(self) -&gt; dict:\n    \"\"\"\n    Processes each class with AST enabled and returns a dictionary with all single ASTs\n    Classnames as keys.\n\n    :return: an dictionary for all classes\n    :rtype: dict\n    \"\"\"\n    ret = dict()\n    for name, cls in sorted(self.classes.items()):\n        logger.debug('Processing class: %s', name)\n        if not isinstance(cls, DvClass):\n            cls = DvClass(cls, self.vma)\n        cls.process(doAST=True)\n        ret[name] = cls.get_ast()\n    return ret\n</code></pre>"},{"location":"reference/androguard/decompiler/decompile.html#androguard.decompiler.decompile.DvMachine.get_class","title":"<code>get_class(class_name)</code>","text":"<p>Return the :class:<code>DvClass</code> with the given name</p> <p>The name is partially matched against the known class names and the first result is returned. For example, the input <code>foobar</code> will match on Lfoobar/bla/foo;</p> <p>Parameters:</p> Name Type Description Default <code>class_name</code> <code>str</code> required <p>Returns:</p> Type Description <code>:class:`DvClass`</code> <p>the class matching on the name</p> Source code in <code>androguard/decompiler/decompile.py</code> <pre><code>def get_class(self, class_name: str) -&gt; DvClass:\n    \"\"\"\n    Return the :class:`DvClass` with the given name\n\n    The name is partially matched against the known class names and the first result is returned.\n    For example, the input `foobar` will match on Lfoobar/bla/foo;\n\n    :param str class_name:\n    :return: the class matching on the name\n    :rtype: :class:`DvClass`\n    \"\"\"\n    for name, klass in self.classes.items():\n        # TODO why use the name partially?\n        if class_name in name:\n            if isinstance(klass, DvClass):\n                return klass\n            dvclass = self.classes[name] = DvClass(klass, self.vma)\n            return dvclass\n</code></pre>"},{"location":"reference/androguard/decompiler/decompile.html#androguard.decompiler.decompile.DvMachine.get_classes","title":"<code>get_classes()</code>","text":"<p>Return a list of classnames contained in this machine. The format of each name is Lxxx;</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list of class names</p> Source code in <code>androguard/decompiler/decompile.py</code> <pre><code>def get_classes(self) -&gt; list[str]:\n    \"\"\"\n    Return a list of classnames contained in this machine.\n    The format of each name is Lxxx;\n\n    :return: list of class names\n    \"\"\"\n    return list(self.classes.keys())\n</code></pre>"},{"location":"reference/androguard/decompiler/decompile.html#androguard.decompiler.decompile.DvMachine.process","title":"<code>process()</code>","text":"<p>Process all classes inside the machine.</p> <p>This calls :meth:<code>~androgaurd.decompiler.decompile.DvClass.process</code> on each :class:<code>DvClass</code>.</p> Source code in <code>androguard/decompiler/decompile.py</code> <pre><code>def process(self) -&gt; None:\n    \"\"\"\n    Process all classes inside the machine.\n\n    This calls :meth:`~androgaurd.decompiler.decompile.DvClass.process` on each :class:`DvClass`.\n    \"\"\"\n    for name, klass in self.classes.items():\n        logger.debug('Processing class: %s', name)\n        if isinstance(klass, DvClass):\n            klass.process()\n        else:\n            dvclass = self.classes[name] = DvClass(klass, self.vma)\n            dvclass.process()\n</code></pre>"},{"location":"reference/androguard/decompiler/decompile.html#androguard.decompiler.decompile.DvMachine.process_and_show","title":"<code>process_and_show()</code>","text":"<p>Run :meth:<code>process</code> and :meth:<code>show_source</code> after each other.</p> Source code in <code>androguard/decompiler/decompile.py</code> <pre><code>def process_and_show(self) -&gt; None:\n    \"\"\"\n    Run :meth:`process` and :meth:`show_source` after each other.\n    \"\"\"\n    for name, klass in sorted(self.classes.items()):\n        logger.debug('Processing class: %s', name)\n        if not isinstance(klass, DvClass):\n            klass = DvClass(klass, self.vma)\n        klass.process()\n        klass.show_source()\n</code></pre>"},{"location":"reference/androguard/decompiler/decompile.html#androguard.decompiler.decompile.DvMachine.show_source","title":"<code>show_source()</code>","text":"<p>Calls <code>show_source</code> on all classes inside the machine. This prints the source to stdout.</p> <p>This calls :meth:<code>~androgaurd.decompiler.decompile.DvClass.show_source</code> on each :class:<code>DvClass</code>.</p> Source code in <code>androguard/decompiler/decompile.py</code> <pre><code>def show_source(self) -&gt; None:\n    \"\"\"\n    Calls `show_source` on all classes inside the machine.\n    This prints the source to stdout.\n\n    This calls :meth:`~androgaurd.decompiler.decompile.DvClass.show_source` on each :class:`DvClass`.\n    \"\"\"\n    for klass in self.classes.values():\n        klass.show_source()\n</code></pre>"},{"location":"reference/androguard/decompiler/decompile.html#androguard.decompiler.decompile.DvMethod","title":"<code>DvMethod</code>","text":"<p>This is a wrapper around :class:<code>~androguard.core.analysis.analysis.MethodAnalysis</code> and :class:<code>~androguard.core.dex.EncodedMethod</code> inside the decompiler.</p> <p>Parameters:</p> Name Type Description Default <code>methanalysis</code> <code>androguard.core.analysis.analysis.MethodAnalysis</code> required Source code in <code>androguard/decompiler/decompile.py</code> <pre><code>class DvMethod:\n    \"\"\"\n    This is a wrapper around :class:`~androguard.core.analysis.analysis.MethodAnalysis` and\n    :class:`~androguard.core.dex.EncodedMethod` inside the decompiler.\n\n    :param androguard.core.analysis.analysis.MethodAnalysis methanalysis:\n    \"\"\"\n\n    def __init__(self, methanalysis: MethodAnalysis) -&gt; None:\n        method = methanalysis.get_method()\n        self.method = method\n        self.start_block = next(methanalysis.get_basic_blocks().get(), None)\n        self.cls_name = method.get_class_name()\n        self.name = method.get_name()\n        self.lparams = []\n        self.var_to_name = defaultdict()\n        self.writer = None\n        self.graph = None\n        self.ast = None\n\n        self.access = util.get_access_method(method.get_access_flags())\n\n        desc = method.get_descriptor()\n        self.type = desc.split(')')[-1]\n        self.params_type = util.get_params_type(desc)\n        self.triple = method.get_triple()\n\n        self.exceptions = methanalysis.exceptions.exceptions\n\n        code = method.get_code()\n        if code is None:\n            logger.debug('No code : %s %s', self.name, self.cls_name)\n        else:\n            start = code.registers_size - code.ins_size\n            if 'static' not in self.access:\n                self.var_to_name[start] = ThisParam(start, self.cls_name)\n                self.lparams.append(start)\n                start += 1\n            num_param = 0\n            for ptype in self.params_type:\n                param = start + num_param\n                self.lparams.append(param)\n                self.var_to_name[param] = Param(param, ptype)\n                num_param += util.get_type_size(ptype)\n\n        if not __debug__:\n            from androguard.core import bytecode\n\n            # TODO: use tempfile to create a correct tempfile (cross platform compatible)\n            bytecode.method2png(\n                '/tmp/dad/graphs/{}#{}.png'.format(\n                    self.cls_name.split('/')[-1][:-1], self.name\n                ),\n                methanalysis,\n            )\n\n    def process(self, doAST: bool = False) -&gt; None:\n        \"\"\"\n        Processes the method and decompile the code.\n\n        There are two modes of operation:\n\n        1) Normal Decompilation to Java Code\n        2) Decompilation into an abstract syntax tree (AST)\n\n        The Decompilation is done twice. First, a rough decompilation is created,\n        which is then optimized. Second, the optimized version is used to create the final version.\n\n        :param doAST: generate AST instead of Java Code\n        \"\"\"\n        logger.debug('METHOD : %s', self.name)\n\n        # Native methods... no blocks.\n        if self.start_block is None:\n            logger.debug('Native Method.')\n            if doAST:\n                self.ast = JSONWriter(None, self).get_ast()\n            else:\n                self.writer = Writer(None, self)\n                self.writer.write_method()\n            return\n\n        # Construct the CFG\n        graph = construct(self.start_block, self.var_to_name, self.exceptions)\n        self.graph = graph\n\n        if not __debug__:\n            # TODO: use tempfile to create a correct tempfile (cross platform compatible)\n            util.create_png(self.cls_name, self.name, graph, '/tmp/dad/blocks')\n\n        use_defs, def_uses = build_def_use(graph, self.lparams)\n        split_variables(graph, self.var_to_name, def_uses, use_defs)\n        dead_code_elimination(graph, def_uses, use_defs)\n        register_propagation(graph, def_uses, use_defs)\n\n        # FIXME var_to_name need to contain the created tmp variables.\n        # This seems to be a workaround, we add them into the list manually\n        for var, i in def_uses:\n            if not isinstance(var, int):\n                self.var_to_name[var] = var.upper()\n\n        place_declarations(graph, self.var_to_name, def_uses, use_defs)\n        del def_uses, use_defs\n        # After the DCE pass, some nodes may be empty, so we can simplify the\n        # graph to delete these nodes.\n        # We start by restructuring the graph by spliting the conditional nodes\n        # into a pre-header and a header part.\n        split_if_nodes(graph)\n        # We then simplify the graph by merging multiple statement nodes into\n        # a single statement node when possible. This also delete empty nodes.\n\n        simplify(graph)\n        graph.compute_rpo()\n\n        if not __debug__:\n            # TODO: use tempfile to create a correct tempfile (cross platform compatible)\n            util.create_png(\n                self.cls_name, self.name, graph, '/tmp/dad/pre-structured'\n            )\n\n        identify_structures(graph, graph.immediate_dominators())\n\n        if not __debug__:\n            # TODO: use tempfile to create a correct tempfile (cross platform compatible)\n            util.create_png(\n                self.cls_name, self.name, graph, '/tmp/dad/structured'\n            )\n\n        if doAST:\n            self.ast = JSONWriter(graph, self).get_ast()\n        else:\n            self.writer = Writer(graph, self)\n            self.writer.write_method()\n\n    def get_ast(self) -&gt; dict:\n        \"\"\"\n        Returns the AST, if previously was generated by calling :meth:`process` with argument :code:`doAST=True`.\n\n        The AST is a :class:`dict` with the following keys:\n\n        * triple\n        * flags\n        * ret\n        * params\n        * comments\n        * body\n\n        The actual AST for the method is in the :code:`body`.\n\n        :return: dict\n        \"\"\"\n        return self.ast\n\n    def show_source(self) -&gt; None:\n        print(self.get_source())\n\n    def get_source(self) -&gt; str:\n        if self.writer:\n            return str(self.writer)\n        return ''\n\n    def get_source_ext(self) -&gt; list[tuple]:\n        if self.writer:\n            return self.writer.str_ext()\n        return []\n\n    def __repr__(self):\n        # return 'Method %s' % self.name\n        return '&lt;class DvMethod(object): %s&gt;' % self.name\n</code></pre>"},{"location":"reference/androguard/decompiler/decompile.html#androguard.decompiler.decompile.DvMethod.get_ast","title":"<code>get_ast()</code>","text":"<p>Returns the AST, if previously was generated by calling :meth:<code>process</code> with argument :code:<code>doAST=True</code>.</p> <p>The AST is a :class:<code>dict</code> with the following keys:</p> <ul> <li>triple</li> <li>flags</li> <li>ret</li> <li>params</li> <li>comments</li> <li>body</li> </ul> <p>The actual AST for the method is in the :code:<code>body</code>.</p> <p>Returns:</p> Type Description <code>dict</code> <p>dict</p> Source code in <code>androguard/decompiler/decompile.py</code> <pre><code>def get_ast(self) -&gt; dict:\n    \"\"\"\n    Returns the AST, if previously was generated by calling :meth:`process` with argument :code:`doAST=True`.\n\n    The AST is a :class:`dict` with the following keys:\n\n    * triple\n    * flags\n    * ret\n    * params\n    * comments\n    * body\n\n    The actual AST for the method is in the :code:`body`.\n\n    :return: dict\n    \"\"\"\n    return self.ast\n</code></pre>"},{"location":"reference/androguard/decompiler/decompile.html#androguard.decompiler.decompile.DvMethod.process","title":"<code>process(doAST=False)</code>","text":"<p>Processes the method and decompile the code.</p> <p>There are two modes of operation:</p> <p>1) Normal Decompilation to Java Code 2) Decompilation into an abstract syntax tree (AST)</p> <p>The Decompilation is done twice. First, a rough decompilation is created, which is then optimized. Second, the optimized version is used to create the final version.</p> <p>Parameters:</p> Name Type Description Default <code>doAST</code> <code>bool</code> <p>generate AST instead of Java Code</p> <code>False</code> Source code in <code>androguard/decompiler/decompile.py</code> <pre><code>def process(self, doAST: bool = False) -&gt; None:\n    \"\"\"\n    Processes the method and decompile the code.\n\n    There are two modes of operation:\n\n    1) Normal Decompilation to Java Code\n    2) Decompilation into an abstract syntax tree (AST)\n\n    The Decompilation is done twice. First, a rough decompilation is created,\n    which is then optimized. Second, the optimized version is used to create the final version.\n\n    :param doAST: generate AST instead of Java Code\n    \"\"\"\n    logger.debug('METHOD : %s', self.name)\n\n    # Native methods... no blocks.\n    if self.start_block is None:\n        logger.debug('Native Method.')\n        if doAST:\n            self.ast = JSONWriter(None, self).get_ast()\n        else:\n            self.writer = Writer(None, self)\n            self.writer.write_method()\n        return\n\n    # Construct the CFG\n    graph = construct(self.start_block, self.var_to_name, self.exceptions)\n    self.graph = graph\n\n    if not __debug__:\n        # TODO: use tempfile to create a correct tempfile (cross platform compatible)\n        util.create_png(self.cls_name, self.name, graph, '/tmp/dad/blocks')\n\n    use_defs, def_uses = build_def_use(graph, self.lparams)\n    split_variables(graph, self.var_to_name, def_uses, use_defs)\n    dead_code_elimination(graph, def_uses, use_defs)\n    register_propagation(graph, def_uses, use_defs)\n\n    # FIXME var_to_name need to contain the created tmp variables.\n    # This seems to be a workaround, we add them into the list manually\n    for var, i in def_uses:\n        if not isinstance(var, int):\n            self.var_to_name[var] = var.upper()\n\n    place_declarations(graph, self.var_to_name, def_uses, use_defs)\n    del def_uses, use_defs\n    # After the DCE pass, some nodes may be empty, so we can simplify the\n    # graph to delete these nodes.\n    # We start by restructuring the graph by spliting the conditional nodes\n    # into a pre-header and a header part.\n    split_if_nodes(graph)\n    # We then simplify the graph by merging multiple statement nodes into\n    # a single statement node when possible. This also delete empty nodes.\n\n    simplify(graph)\n    graph.compute_rpo()\n\n    if not __debug__:\n        # TODO: use tempfile to create a correct tempfile (cross platform compatible)\n        util.create_png(\n            self.cls_name, self.name, graph, '/tmp/dad/pre-structured'\n        )\n\n    identify_structures(graph, graph.immediate_dominators())\n\n    if not __debug__:\n        # TODO: use tempfile to create a correct tempfile (cross platform compatible)\n        util.create_png(\n            self.cls_name, self.name, graph, '/tmp/dad/structured'\n        )\n\n    if doAST:\n        self.ast = JSONWriter(graph, self).get_ast()\n    else:\n        self.writer = Writer(graph, self)\n        self.writer.write_method()\n</code></pre>"},{"location":"reference/androguard/decompiler/decompiler.html","title":"decompiler","text":""},{"location":"reference/androguard/decompiler/decompiler.html#androguard.decompiler.decompiler.DecompilerDAD","title":"<code>DecompilerDAD</code>","text":"Source code in <code>androguard/decompiler/decompiler.py</code> <pre><code>class DecompilerDAD:\n    def __init__(self, vm: DEX, vmx: Analysis) -&gt; None:\n        \"\"\"\n        Decompiler wrapper for DAD: **D**AD is **A** **D**ecompiler\n        DAD is the androguard internal decompiler.\n\n        This Method does not use the :class:`~androguard.decompiler.decompile.DvMachine` but\n        creates :class:`~androguard.decompiler.decompile.DvClass` and\n        :class:`~androguard.decompiler.decompile.DvMethod` on demand.\n\n        :param androguard.core.bytecodes.DEX vm: `DEX` object\n        :param androguard.core.analysis.analysis.Analysis vmx: `Analysis` object\n        \"\"\"\n        self.vm = vm\n        self.vmx = vmx\n\n    def get_source_method(self, m: MethodAnalysis) -&gt; str:\n        mx = self.vmx.get_method(m)\n        z = decompile.DvMethod(mx)\n        z.process()\n        return z.get_source()\n\n    def get_ast_method(self, m: MethodAnalysis) -&gt; dict:\n        mx = self.vmx.get_method(m)\n        z = decompile.DvMethod(mx)\n        z.process(doAST=True)\n        return z.get_ast()\n\n    def display_source(self, m: MethodAnalysis) -&gt; None:\n        result = self.get_source_method(m)\n\n        lexer = get_lexer_by_name(\"java\", stripall=True)\n        formatter = TerminalFormatter()\n        result = highlight(result, lexer, formatter)\n        print(result)\n\n    def get_source_class(self, _class: ClassDefItem) -&gt; str:\n        c = decompile.DvClass(_class, self.vmx)\n        c.process()\n        return c.get_source()\n\n    def get_ast_class(self, _class: ClassDefItem) -&gt; dict:\n        c = decompile.DvClass(_class, self.vmx)\n        c.process(doAST=True)\n        return c.get_ast()\n\n    def get_source_class_ext(\n        self, _class: ClassDefItem\n    ) -&gt; list[tuple[str, list]]:\n        c = decompile.DvClass(_class, self.vmx)\n        c.process()\n\n        result = c.get_source_ext()\n\n        return result\n\n    def display_all(self, _class: ClassDefItem) -&gt; None:\n        result = self.get_source_class(_class)\n\n        lexer = get_lexer_by_name(\"java\", stripall=True)\n        formatter = TerminalFormatter()\n        result = highlight(result, lexer, formatter)\n        print(result)\n</code></pre>"},{"location":"reference/androguard/decompiler/decompiler.html#androguard.decompiler.decompiler.DecompilerDAD.__init__","title":"<code>__init__(vm, vmx)</code>","text":"<p>Decompiler wrapper for DAD: DAD is A Decompiler DAD is the androguard internal decompiler.</p> <p>This Method does not use the :class:<code>~androguard.decompiler.decompile.DvMachine</code> but creates :class:<code>~androguard.decompiler.decompile.DvClass</code> and :class:<code>~androguard.decompiler.decompile.DvMethod</code> on demand.</p> <p>Parameters:</p> Name Type Description Default <code>vm</code> <code>androguard.core.bytecodes.DEX</code> <p><code>DEX</code> object</p> required <code>vmx</code> <code>androguard.core.analysis.analysis.Analysis</code> <p><code>Analysis</code> object</p> required Source code in <code>androguard/decompiler/decompiler.py</code> <pre><code>def __init__(self, vm: DEX, vmx: Analysis) -&gt; None:\n    \"\"\"\n    Decompiler wrapper for DAD: **D**AD is **A** **D**ecompiler\n    DAD is the androguard internal decompiler.\n\n    This Method does not use the :class:`~androguard.decompiler.decompile.DvMachine` but\n    creates :class:`~androguard.decompiler.decompile.DvClass` and\n    :class:`~androguard.decompiler.decompile.DvMethod` on demand.\n\n    :param androguard.core.bytecodes.DEX vm: `DEX` object\n    :param androguard.core.analysis.analysis.Analysis vmx: `Analysis` object\n    \"\"\"\n    self.vm = vm\n    self.vmx = vmx\n</code></pre>"},{"location":"reference/androguard/decompiler/graph.html","title":"graph","text":""},{"location":"reference/androguard/decompiler/graph.html#androguard.decompiler.graph.Graph","title":"<code>Graph</code>","text":"<p>Stores a CFG (Control Flow Graph), which is a directed graph.</p> <p>The CFG defines an entry node :py:attr:<code>entry</code>, a single exit node :py:attr:<code>exit</code>, a list of nodes :py:attr:<code>nodes</code> and a list of edges :py:attr:<code>edges</code>.</p> Source code in <code>androguard/decompiler/graph.py</code> <pre><code>class Graph:\n    \"\"\"\n    Stores a CFG (Control Flow Graph), which is a directed graph.\n\n    The CFG defines an entry node :py:attr:`entry`, a single exit node :py:attr:`exit`, a list of nodes\n    :py:attr:`nodes` and a list of edges :py:attr:`edges`.\n    \"\"\"\n\n    def __init__(self):\n        self.entry = None\n        self.exit = None\n        self.nodes = list()\n        self.edges = defaultdict(list)\n\n        self.rpo = []\n        self.catch_edges = defaultdict(list)\n        self.reverse_edges = defaultdict(list)\n        self.reverse_catch_edges = defaultdict(list)\n        self.loc_to_ins = None\n        self.loc_to_node = None\n\n    def sucs(self, node):\n        return self.edges.get(node, [])\n\n    def all_sucs(self, node):\n        return self.edges.get(node, []) + self.catch_edges.get(node, [])\n\n    def preds(self, node):\n        return [n for n in self.reverse_edges.get(node, []) if not n.in_catch]\n\n    def all_preds(self, node):\n        return self.reverse_edges.get(node, []) + self.reverse_catch_edges.get(\n            node, []\n        )\n\n    def add_node(self, node):\n        \"\"\"\n        Adds the given node to the graph, without connecting it to anyhting else.\n\n        :param androguard.decompiler.node.Node node: node to add\n        \"\"\"\n        self.nodes.append(node)\n\n    def add_edge(self, e1, e2):\n        lsucs = self.edges[e1]\n        if e2 not in lsucs:\n            lsucs.append(e2)\n        lpreds = self.reverse_edges[e2]\n        if e1 not in lpreds:\n            lpreds.append(e1)\n\n    def add_catch_edge(self, e1, e2):\n        # Ensure nodes always inherit non-empty catch types from each other.\n        active_type = e1.catch_type or e2.catch_type\n        e1.set_catch_type(active_type)\n        e2.set_catch_type(active_type)\n        lsucs = self.catch_edges[e1]\n        if e2 not in lsucs:\n            lsucs.append(e2)\n        lpreds = self.reverse_catch_edges[e2]\n        if e1 not in lpreds:\n            lpreds.append(e1)\n\n    def remove_node(self, node):\n        \"\"\"\n        Remove the node from the graph, removes also all connections.\n\n        :param androguard.decompiler.node.Node node: the node to remove\n        \"\"\"\n        preds = self.reverse_edges.get(node, [])\n        for pred in preds:\n            self.edges[pred].remove(node)\n\n        succs = self.edges.get(node, [])\n        for suc in succs:\n            self.reverse_edges[suc].remove(node)\n\n        exc_preds = self.reverse_catch_edges.pop(node, [])\n        for pred in exc_preds:\n            self.catch_edges[pred].remove(node)\n\n        exc_succs = self.catch_edges.pop(node, [])\n        for suc in exc_succs:\n            self.reverse_catch_edges[suc].remove(node)\n\n        self.nodes.remove(node)\n        if node in self.rpo:\n            self.rpo.remove(node)\n        del node\n\n    def number_ins(self):\n        self.loc_to_ins = {}\n        self.loc_to_node = {}\n        num = 0\n        for node in self.rpo:\n            start_node = num\n            num = node.number_ins(num)\n            end_node = num - 1\n            self.loc_to_ins.update(node.get_loc_with_ins())\n            self.loc_to_node[start_node, end_node] = node\n\n    def get_ins_from_loc(self, loc):\n        return self.loc_to_ins.get(loc)\n\n    def get_node_from_loc(self, loc):\n        for (start, end), node in self.loc_to_node.items():\n            if start &lt;= loc &lt;= end:\n                return node\n\n    def remove_ins(self, loc):\n        ins = self.get_ins_from_loc(loc)\n        self.get_node_from_loc(loc).remove_ins(loc, ins)\n        self.loc_to_ins.pop(loc)\n\n    def compute_rpo(self):\n        \"\"\"\n        Number the nodes in reverse post order.\n        An RPO traversal visit as many predecessors of a node as possible\n        before visiting the node itself.\n        \"\"\"\n        nb = len(self.nodes) + 1\n        for node in self.post_order():\n            node.num = nb - node.po\n        self.rpo = sorted(self.nodes, key=lambda n: n.num)\n\n    def post_order(self):\n        \"\"\"\n        Yields the :class`~androguard.decompiler.node.Node`s of the graph in post-order i.e we visit all the\n        children of a node before visiting the node itself.\n        \"\"\"\n\n        def _visit(n, cnt):\n            visited.add(n)\n            for suc in self.all_sucs(n):\n                if suc not in visited:\n                    for cnt, s in _visit(suc, cnt):\n                        yield cnt, s\n            n.po = cnt\n            yield cnt + 1, n\n\n        visited = set()\n        for _, node in _visit(self.entry, 1):\n            yield node\n\n    def draw(self, name, dname, draw_branches=True):\n        \"\"\"\n        Writes the current graph as a PNG file\n\n        :param str name: filename (without .png)\n        :param str dname: directory of the output png\n        :param draw_branches:\n        :return:\n        \"\"\"\n        import os\n\n        from pydot import Dot, Edge\n\n        g = Dot()\n        g.set_node_defaults(\n            color='lightgray',\n            style='filled',\n            shape='box',\n            fontname='Courier',\n            fontsize='10',\n        )\n        for node in sorted(self.nodes, key=lambda x: x.num):\n            if draw_branches and node.type.is_cond:\n                g.add_edge(Edge(str(node), str(node.true), color='green'))\n                g.add_edge(Edge(str(node), str(node.false), color='red'))\n            else:\n                for suc in self.sucs(node):\n                    g.add_edge(Edge(str(node), str(suc), color='blue'))\n            for except_node in self.catch_edges.get(node, []):\n                g.add_edge(\n                    Edge(\n                        str(node),\n                        str(except_node),\n                        color='black',\n                        style='dashed',\n                    )\n                )\n\n        g.write(os.path.join(dname, '%s.png' % name), format='png')\n\n    def immediate_dominators(self):\n        return dom_lt(self)\n\n    def __len__(self):\n        return len(self.nodes)\n\n    def __repr__(self):\n        return str(self.nodes)\n\n    def __iter__(self):\n        for node in self.nodes:\n            yield node\n</code></pre>"},{"location":"reference/androguard/decompiler/graph.html#androguard.decompiler.graph.Graph.add_node","title":"<code>add_node(node)</code>","text":"<p>Adds the given node to the graph, without connecting it to anyhting else.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>androguard.decompiler.node.Node</code> <p>node to add</p> required Source code in <code>androguard/decompiler/graph.py</code> <pre><code>def add_node(self, node):\n    \"\"\"\n    Adds the given node to the graph, without connecting it to anyhting else.\n\n    :param androguard.decompiler.node.Node node: node to add\n    \"\"\"\n    self.nodes.append(node)\n</code></pre>"},{"location":"reference/androguard/decompiler/graph.html#androguard.decompiler.graph.Graph.compute_rpo","title":"<code>compute_rpo()</code>","text":"<p>Number the nodes in reverse post order. An RPO traversal visit as many predecessors of a node as possible before visiting the node itself.</p> Source code in <code>androguard/decompiler/graph.py</code> <pre><code>def compute_rpo(self):\n    \"\"\"\n    Number the nodes in reverse post order.\n    An RPO traversal visit as many predecessors of a node as possible\n    before visiting the node itself.\n    \"\"\"\n    nb = len(self.nodes) + 1\n    for node in self.post_order():\n        node.num = nb - node.po\n    self.rpo = sorted(self.nodes, key=lambda n: n.num)\n</code></pre>"},{"location":"reference/androguard/decompiler/graph.html#androguard.decompiler.graph.Graph.draw","title":"<code>draw(name, dname, draw_branches=True)</code>","text":"<p>Writes the current graph as a PNG file</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>filename (without .png)</p> required <code>dname</code> <code>str</code> <p>directory of the output png</p> required <code>draw_branches</code> <code>True</code> <p>Returns:</p> Type Description Source code in <code>androguard/decompiler/graph.py</code> <pre><code>def draw(self, name, dname, draw_branches=True):\n    \"\"\"\n    Writes the current graph as a PNG file\n\n    :param str name: filename (without .png)\n    :param str dname: directory of the output png\n    :param draw_branches:\n    :return:\n    \"\"\"\n    import os\n\n    from pydot import Dot, Edge\n\n    g = Dot()\n    g.set_node_defaults(\n        color='lightgray',\n        style='filled',\n        shape='box',\n        fontname='Courier',\n        fontsize='10',\n    )\n    for node in sorted(self.nodes, key=lambda x: x.num):\n        if draw_branches and node.type.is_cond:\n            g.add_edge(Edge(str(node), str(node.true), color='green'))\n            g.add_edge(Edge(str(node), str(node.false), color='red'))\n        else:\n            for suc in self.sucs(node):\n                g.add_edge(Edge(str(node), str(suc), color='blue'))\n        for except_node in self.catch_edges.get(node, []):\n            g.add_edge(\n                Edge(\n                    str(node),\n                    str(except_node),\n                    color='black',\n                    style='dashed',\n                )\n            )\n\n    g.write(os.path.join(dname, '%s.png' % name), format='png')\n</code></pre>"},{"location":"reference/androguard/decompiler/graph.html#androguard.decompiler.graph.Graph.post_order","title":"<code>post_order()</code>","text":"<p>Yields the :class<code>~androguard.decompiler.node.Node</code>s of the graph in post-order i.e we visit all the children of a node before visiting the node itself.</p> Source code in <code>androguard/decompiler/graph.py</code> <pre><code>def post_order(self):\n    \"\"\"\n    Yields the :class`~androguard.decompiler.node.Node`s of the graph in post-order i.e we visit all the\n    children of a node before visiting the node itself.\n    \"\"\"\n\n    def _visit(n, cnt):\n        visited.add(n)\n        for suc in self.all_sucs(n):\n            if suc not in visited:\n                for cnt, s in _visit(suc, cnt):\n                    yield cnt, s\n        n.po = cnt\n        yield cnt + 1, n\n\n    visited = set()\n    for _, node in _visit(self.entry, 1):\n        yield node\n</code></pre>"},{"location":"reference/androguard/decompiler/graph.html#androguard.decompiler.graph.Graph.remove_node","title":"<code>remove_node(node)</code>","text":"<p>Remove the node from the graph, removes also all connections.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>androguard.decompiler.node.Node</code> <p>the node to remove</p> required Source code in <code>androguard/decompiler/graph.py</code> <pre><code>def remove_node(self, node):\n    \"\"\"\n    Remove the node from the graph, removes also all connections.\n\n    :param androguard.decompiler.node.Node node: the node to remove\n    \"\"\"\n    preds = self.reverse_edges.get(node, [])\n    for pred in preds:\n        self.edges[pred].remove(node)\n\n    succs = self.edges.get(node, [])\n    for suc in succs:\n        self.reverse_edges[suc].remove(node)\n\n    exc_preds = self.reverse_catch_edges.pop(node, [])\n    for pred in exc_preds:\n        self.catch_edges[pred].remove(node)\n\n    exc_succs = self.catch_edges.pop(node, [])\n    for suc in exc_succs:\n        self.reverse_catch_edges[suc].remove(node)\n\n    self.nodes.remove(node)\n    if node in self.rpo:\n        self.rpo.remove(node)\n    del node\n</code></pre>"},{"location":"reference/androguard/decompiler/graph.html#androguard.decompiler.graph.bfs","title":"<code>bfs(start)</code>","text":"<p>Breadth first search</p> <p>Yields all nodes found from the starting point</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <p>start node</p> required Source code in <code>androguard/decompiler/graph.py</code> <pre><code>def bfs(start):\n    \"\"\"\n    Breadth first search\n\n    Yields all nodes found from the starting point\n\n    :param start: start node\n    \"\"\"\n    to_visit = [start]\n    visited = {start}\n    while to_visit:\n        node = to_visit.pop(0)\n        yield node\n        if node.exception_analysis:\n            for _, _, exception in node.exception_analysis.exceptions:\n                if exception not in visited:\n                    to_visit.append(exception)\n                    visited.add(exception)\n        for _, _, child in node.childs:\n            if child not in visited:\n                to_visit.append(child)\n                visited.add(child)\n</code></pre>"},{"location":"reference/androguard/decompiler/graph.html#androguard.decompiler.graph.construct","title":"<code>construct(start_block, vmap, exceptions)</code>","text":"<p>Constructs a CFG</p> <p>Parameters:</p> Name Type Description Default <code>start_block</code> <code>androguard.core.analysis.analysis.DEXBasicBlock</code> <p>The startpoint</p> required <code>vmap</code> <p>variable mapping</p> required <code>exceptions</code> <p>list of androguard.core.analysis.analysis.ExceptionAnalysis</p> required Source code in <code>androguard/decompiler/graph.py</code> <pre><code>def construct(start_block, vmap, exceptions):\n    \"\"\"\n    Constructs a CFG\n\n    :param androguard.core.analysis.analysis.DEXBasicBlock start_block: The startpoint\n    :param vmap: variable mapping\n    :param exceptions: list of androguard.core.analysis.analysis.ExceptionAnalysis\n\n    :rtype: Graph\n    \"\"\"\n    bfs_blocks = bfs(start_block)\n\n    graph = Graph()\n    gen_ret = GenInvokeRetName()\n\n    # Construction of a mapping of basic blocks into Nodes\n    block_to_node = {}\n\n    exceptions_start_block = []\n    for exception in exceptions:\n        for _, _, block in exception.exceptions:\n            exceptions_start_block.append(block)\n\n    for block in bfs_blocks:\n        node = make_node(graph, block, block_to_node, vmap, gen_ret)\n        graph.add_node(node)\n\n    graph.entry = block_to_node[start_block]\n    del block_to_node, bfs_blocks\n\n    graph.compute_rpo()\n    graph.number_ins()\n\n    for node in graph.rpo:\n        preds = [pred for pred in graph.all_preds(node) if pred.num &lt; node.num]\n        if preds and all(pred.in_catch for pred in preds):\n            node.in_catch = True\n\n    # FIXME: We have seen samples in the wild which have multiple exit nodes!\n    #        This seems to be not necessarily a obfuscation method, but rather some\n    #        speciality with certain compilers!\n    # Create a list of Node which are 'return' node\n    # There should be one and only one node of this type\n    # If this is not the case, try to continue anyway by setting the exit node\n    # to the one which has the greatest RPO number (not necessarily the case)\n    lexit_nodes = [node for node in graph if node.type.is_return]\n\n    if len(lexit_nodes) &gt; 1:\n        # Not sure that this case is possible...\n        logger.error('Multiple exit nodes found !')\n        graph.exit = graph.rpo[-1]\n    elif len(lexit_nodes) &lt; 1:\n        # A method can have no return if it has throw statement(s) or if its\n        # body is a while(1) whitout break/return.\n        logger.debug('No exit node found !')\n    else:\n        graph.exit = lexit_nodes[0]\n\n    return graph\n</code></pre>"},{"location":"reference/androguard/decompiler/graph.html#androguard.decompiler.graph.dom_lt","title":"<code>dom_lt(graph)</code>","text":"<p>Dominator algorithm from Lengauer-Tarjan</p> Source code in <code>androguard/decompiler/graph.py</code> <pre><code>def dom_lt(graph):\n    \"\"\"Dominator algorithm from Lengauer-Tarjan\"\"\"\n\n    def _dfs(v, n):\n        semi[v] = n = n + 1\n        vertex[n] = label[v] = v\n        ancestor[v] = 0\n        for w in graph.all_sucs(v):\n            if not semi[w]:\n                parent[w] = v\n                n = _dfs(w, n)\n            pred[w].add(v)\n        return n\n\n    def _compress(v):\n        u = ancestor[v]\n        if ancestor[u]:\n            _compress(u)\n            if semi[label[u]] &lt; semi[label[v]]:\n                label[v] = label[u]\n            ancestor[v] = ancestor[u]\n\n    def _eval(v):\n        if ancestor[v]:\n            _compress(v)\n            return label[v]\n        return v\n\n    def _link(v, w):\n        ancestor[w] = v\n\n    parent, ancestor, vertex = {}, {}, {}\n    label, dom = {}, {}\n    pred, bucket = defaultdict(set), defaultdict(set)\n\n    # Step 1:\n    semi = {v: 0 for v in graph.nodes}\n    n = _dfs(graph.entry, 0)\n    for i in range(n, 1, -1):\n        w = vertex[i]\n        # Step 2:\n        for v in pred[w]:\n            u = _eval(v)\n            y = semi[w] = min(semi[w], semi[u])\n        bucket[vertex[y]].add(w)\n        pw = parent[w]\n        _link(pw, w)\n        # Step 3:\n        bpw = bucket[pw]\n        while bpw:\n            v = bpw.pop()\n            u = _eval(v)\n            dom[v] = u if semi[u] &lt; semi[v] else pw\n    # Step 4:\n    for i in range(2, n + 1):\n        w = vertex[i]\n        dw = dom[w]\n        if dw != vertex[semi[w]]:\n            dom[w] = dom[dw]\n    dom[graph.entry] = None\n    return dom\n</code></pre>"},{"location":"reference/androguard/decompiler/graph.html#androguard.decompiler.graph.simplify","title":"<code>simplify(graph)</code>","text":"<p>Simplify the CFG by merging/deleting statement nodes when possible: If statement B follows statement A and if B has no other predecessor besides A, then we can merge A and B into a new statement node. We also remove nodes which do nothing except redirecting the control flow (nodes which only contains a goto).</p> Source code in <code>androguard/decompiler/graph.py</code> <pre><code>def simplify(graph):\n    \"\"\"\n    Simplify the CFG by merging/deleting statement nodes when possible:\n    If statement B follows statement A and if B has no other predecessor\n    besides A, then we can merge A and B into a new statement node.\n    We also remove nodes which do nothing except redirecting the control\n    flow (nodes which only contains a goto).\n    \"\"\"\n    redo = True\n    while redo:\n        redo = False\n        node_map = {}\n        to_update = set()\n        for node in graph.nodes[:]:\n            if node.type.is_stmt and node in graph:\n                sucs = graph.all_sucs(node)\n                if len(sucs) != 1:\n                    continue\n                suc = sucs[0]\n                if len(node.get_ins()) == 0:\n                    if any(\n                        pred.type.is_switch for pred in graph.all_preds(node)\n                    ):\n                        continue\n                    if node is suc:\n                        continue\n                    node_map[node] = suc\n\n                    for pred in graph.all_preds(node):\n                        pred.update_attribute_with(node_map)\n                        if node not in graph.sucs(pred):\n                            graph.add_catch_edge(pred, suc)\n                            continue\n                        graph.add_edge(pred, suc)\n                    redo = True\n                    if node is graph.entry:\n                        graph.entry = suc\n                    graph.remove_node(node)\n                elif (\n                    suc.type.is_stmt\n                    and len(graph.all_preds(suc)) == 1\n                    and not (suc in graph.catch_edges)\n                    and not ((node is suc) or (suc is graph.entry))\n                ):\n                    ins_to_merge = suc.get_ins()\n                    node.add_ins(ins_to_merge)\n                    for var in suc.var_to_declare:\n                        node.add_variable_declaration(var)\n                    new_suc = graph.sucs(suc)[0]\n                    if new_suc:\n                        graph.add_edge(node, new_suc)\n                    for exception_suc in graph.catch_edges.get(suc, []):\n                        graph.add_catch_edge(node, exception_suc)\n                    redo = True\n                    graph.remove_node(suc)\n            else:\n                to_update.add(node)\n        for node in to_update:\n            node.update_attribute_with(node_map)\n</code></pre>"},{"location":"reference/androguard/decompiler/graph.html#androguard.decompiler.graph.split_if_nodes","title":"<code>split_if_nodes(graph)</code>","text":"<p>Split IfNodes in two nodes, the first node is the header node, the second one is only composed of the jump condition.</p> Source code in <code>androguard/decompiler/graph.py</code> <pre><code>def split_if_nodes(graph):\n    \"\"\"\n    Split IfNodes in two nodes, the first node is the header node, the\n    second one is only composed of the jump condition.\n    \"\"\"\n    node_map = {n: n for n in graph}\n    to_update = set()\n    for node in graph.nodes[:]:\n        if node.type.is_cond:\n            if len(node.get_ins()) &gt; 1:\n                pre_ins = node.get_ins()[:-1]\n                last_ins = node.get_ins()[-1]\n                pre_node = StatementBlock('%s-pre' % node.name, pre_ins)\n                cond_node = CondBlock('%s-cond' % node.name, [last_ins])\n                node_map[node] = pre_node\n                node_map[pre_node] = pre_node\n                node_map[cond_node] = cond_node\n\n                pre_node.copy_from(node)\n                cond_node.copy_from(node)\n                for var in node.var_to_declare:\n                    pre_node.add_variable_declaration(var)\n                pre_node.type.is_stmt = True\n                cond_node.true = node.true\n                cond_node.false = node.false\n\n                for pred in graph.all_preds(node):\n                    pred_node = node_map[pred]\n                    # Verify that the link is not an exception link\n                    if node not in graph.sucs(pred):\n                        graph.add_catch_edge(pred_node, pre_node)\n                        continue\n                    if pred is node:\n                        pred_node = cond_node\n                    if pred.type.is_cond:  # and not (pred is node):\n                        if pred.true is node:\n                            pred_node.true = pre_node\n                        if pred.false is node:\n                            pred_node.false = pre_node\n                    graph.add_edge(pred_node, pre_node)\n                for suc in graph.sucs(node):\n                    graph.add_edge(cond_node, node_map[suc])\n\n                # We link all the exceptions to the pre node instead of the\n                # condition node, which should not trigger any of them.\n                for suc in graph.catch_edges.get(node, []):\n                    graph.add_catch_edge(pre_node, node_map[suc])\n\n                if node is graph.entry:\n                    graph.entry = pre_node\n\n                graph.add_node(pre_node)\n                graph.add_node(cond_node)\n                graph.add_edge(pre_node, cond_node)\n                pre_node.update_attribute_with(node_map)\n                cond_node.update_attribute_with(node_map)\n                graph.remove_node(node)\n        else:\n            to_update.add(node)\n    for node in to_update:\n        node.update_attribute_with(node_map)\n</code></pre>"},{"location":"reference/androguard/decompiler/instruction.html","title":"instruction","text":""},{"location":"reference/androguard/decompiler/instruction.html#androguard.decompiler.instruction.Constant","title":"<code>Constant</code>","text":"<p>               Bases: <code>IRForm</code></p> Source code in <code>androguard/decompiler/instruction.py</code> <pre><code>class Constant(IRForm):\n    def __init__(self, value, atype, int_value=None, descriptor=None):\n        \"\"\"\n\n        :param value:\n        :param atype: the type of the constant as described in https://source.android.com/devices/tech/dalvik/dex-format.html#typedescriptor\n        :param int_value:\n        :param descriptor:\n        \"\"\"\n        self.v = 'c%s' % value\n        self.cst = value\n        if int_value is None:\n            self.cst2 = value\n        else:\n            self.cst2 = int_value\n        self.type = atype\n\n        self.clsdesc = descriptor\n\n    def get_used_vars(self):\n        return []\n\n    def is_const(self):\n        return True\n\n    def get_int_value(self):\n        return self.cst2\n\n    def get_type(self):\n        return self.type\n\n    def visit(self, visitor):\n        if self.type == 'Z':\n            if self.cst == 0:\n                return visitor.visit_constant('false')\n            else:\n                return visitor.visit_constant('true')\n        elif self.type == 'Ljava/lang/Class;':\n            return visitor.visit_base_class(self.cst, data=self.cst)\n        elif self.type in 'IJB':\n            return visitor.visit_constant(self.cst2)\n        else:\n            return visitor.visit_constant(self.cst)\n\n    def __str__(self):\n        return 'CST_%s' % repr(self.cst)\n</code></pre>"},{"location":"reference/androguard/decompiler/instruction.html#androguard.decompiler.instruction.Constant.__init__","title":"<code>__init__(value, atype, int_value=None, descriptor=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>value</code> required <code>atype</code> <p>the type of the constant as described in https://source.android.com/devices/tech/dalvik/dex-format.html#typedescriptor</p> required <code>int_value</code> <code>None</code> <code>descriptor</code> <code>None</code> Source code in <code>androguard/decompiler/instruction.py</code> <pre><code>def __init__(self, value, atype, int_value=None, descriptor=None):\n    \"\"\"\n\n    :param value:\n    :param atype: the type of the constant as described in https://source.android.com/devices/tech/dalvik/dex-format.html#typedescriptor\n    :param int_value:\n    :param descriptor:\n    \"\"\"\n    self.v = 'c%s' % value\n    self.cst = value\n    if int_value is None:\n        self.cst2 = value\n    else:\n        self.cst2 = int_value\n    self.type = atype\n\n    self.clsdesc = descriptor\n</code></pre>"},{"location":"reference/androguard/decompiler/node.html","title":"node","text":""},{"location":"reference/androguard/decompiler/opcode_ins.html","title":"opcode_ins","text":""},{"location":"reference/androguard/decompiler/util.html","title":"util","text":""},{"location":"reference/androguard/decompiler/util.html#androguard.decompiler.util.build_path","title":"<code>build_path(graph, node1, node2, path=None)</code>","text":"<p>Build the path from node1 to node2. The path is composed of all the nodes between node1 and node2, node1 excluded. Although if there is a loop starting from node1, it will be included in the path.</p> Source code in <code>androguard/decompiler/util.py</code> <pre><code>def build_path(graph, node1, node2, path=None):\n    \"\"\"\n    Build the path from node1 to node2.\n    The path is composed of all the nodes between node1 and node2,\n    node1 excluded. Although if there is a loop starting from node1, it will be\n    included in the path.\n    \"\"\"\n    if path is None:\n        path = []\n    if node1 is node2:\n        return path\n    path.append(node2)\n    for pred in graph.all_preds(node2):\n        if pred in path:\n            continue\n        build_path(graph, node1, pred, path)\n    return path\n</code></pre>"},{"location":"reference/androguard/decompiler/util.html#androguard.decompiler.util.create_png","title":"<code>create_png(cls_name, meth_name, graph, dir_name='graphs2')</code>","text":"<p>Creates a PNG from a given :class:<code>~androguard.decompiler.graph.Graph</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cls_name</code> <code>str</code> <p>name of the class</p> required <code>meth_name</code> <code>str</code> <p>name of the method</p> required <code>graph</code> <code>androguard.decompiler.graph.Graph</code> required <code>dir_name</code> <code>str</code> <p>output directory</p> <code>'graphs2'</code> Source code in <code>androguard/decompiler/util.py</code> <pre><code>def create_png(\n    cls_name: str, meth_name: str, graph: Graph, dir_name: str = 'graphs2'\n) -&gt; None:\n    \"\"\"\n    Creates a PNG from a given :class:`~androguard.decompiler.graph.Graph`.\n\n    :param str cls_name: name of the class\n    :param str meth_name: name of the method\n    :param androguard.decompiler.graph.Graph graph:\n    :param str dir_name: output directory\n    \"\"\"\n    m_name = ''.join(x for x in meth_name if x.isalnum())\n    name = ''.join((cls_name.split('/')[-1][:-1], '#', m_name))\n    graph.draw(name, dir_name)\n</code></pre>"},{"location":"reference/androguard/decompiler/util.html#androguard.decompiler.util.get_params_type","title":"<code>get_params_type(descriptor)</code>","text":"<p>Return the parameters type of a descriptor (e.g (IC)V)</p> Source code in <code>androguard/decompiler/util.py</code> <pre><code>def get_params_type(descriptor: str) -&gt; list[str]:\n    \"\"\"\n    Return the parameters type of a descriptor (e.g (IC)V)\n    \"\"\"\n    params = descriptor.split(')')[0][1:].split()\n    if params:\n        return [param for param in params]\n    return []\n</code></pre>"},{"location":"reference/androguard/decompiler/util.html#androguard.decompiler.util.get_type","title":"<code>get_type(atype, size=None)</code>","text":"<p>Retrieve the java type of a descriptor (e.g : I)</p> Source code in <code>androguard/decompiler/util.py</code> <pre><code>def get_type(atype: str, size: int = None) -&gt; str:\n    \"\"\"\n    Retrieve the java type of a descriptor (e.g : I)\n    \"\"\"\n    res = TYPE_DESCRIPTOR.get(atype)\n    if res is None:\n        if atype[0] == 'L':\n            if atype.startswith('Ljava/lang'):\n                res = atype[1:-1].lstrip('java/lang/').replace('/', '.')\n            else:\n                res = atype[1:-1].replace('/', '.')\n        elif atype[0] == '[':\n            if size is None:\n                res = '%s[]' % get_type(atype[1:])\n            else:\n                res = '{}[{}]'.format(get_type(atype[1:]), size)\n        else:\n            res = atype\n            logger.debug('Unknown descriptor: \"%s\".', atype)\n    return res\n</code></pre>"},{"location":"reference/androguard/decompiler/util.html#androguard.decompiler.util.get_type_size","title":"<code>get_type_size(param)</code>","text":"<p>Return the number of register needed by the type @param</p> Source code in <code>androguard/decompiler/util.py</code> <pre><code>def get_type_size(param):\n    \"\"\"\n    Return the number of register needed by the type @param\n    \"\"\"\n    return TYPE_LEN.get(param, 1)\n</code></pre>"},{"location":"reference/androguard/decompiler/util.html#androguard.decompiler.util.merge_inner","title":"<code>merge_inner(clsdict)</code>","text":"<p>Merge the inner class(es) of a class: e.g class A { ... } class A$foo{ ... } class A$bar{ ... } ==&gt; class A { class foo{...} class bar{...} ... }</p> Source code in <code>androguard/decompiler/util.py</code> <pre><code>def merge_inner(clsdict):\n    \"\"\"\n    Merge the inner class(es) of a class:\n    e.g class A { ... } class A$foo{ ... } class A$bar{ ... }\n    ==&gt; class A { class foo{...} class bar{...} ... }\n    \"\"\"\n    samelist = False\n    done = {}\n    while not samelist:\n        samelist = True\n        classlist = list(clsdict.keys())\n        for classname in classlist:\n            parts_name = classname.rsplit('$', 1)\n            if len(parts_name) &gt; 1:\n                mainclass, innerclass = parts_name\n                innerclass = innerclass[:-1]  # remove ';' of the name\n                mainclass += ';'\n                if mainclass in clsdict:\n                    clsdict[mainclass].add_subclass(\n                        innerclass, clsdict[classname]\n                    )\n                    clsdict[classname].name = innerclass\n                    done[classname] = clsdict[classname]\n                    del clsdict[classname]\n                    samelist = False\n                elif mainclass in done:\n                    cls = done[mainclass]\n                    cls.add_subclass(innerclass, clsdict[classname])\n                    clsdict[classname].name = innerclass\n                    done[classname] = done[mainclass]\n                    del clsdict[classname]\n                    samelist = False\n</code></pre>"},{"location":"reference/androguard/decompiler/writer.html","title":"writer","text":""},{"location":"reference/androguard/decompiler/writer.html#androguard.decompiler.writer.Writer","title":"<code>Writer</code>","text":"<p>Transforms a method into Java code.</p> Source code in <code>androguard/decompiler/writer.py</code> <pre><code>class Writer:\n    \"\"\"\n    Transforms a method into Java code.\n\n    \"\"\"\n\n    def __init__(self, graph, method):\n        self.graph = graph\n        self.method = method\n        self.visited_nodes = set()\n        self.ind = 4\n        self.buffer = []\n        self.buffer2 = []\n        self.loop_follow = [None]\n        self.if_follow = [None]\n        self.switch_follow = [None]\n        self.latch_node = [None]\n        self.try_follow = [None]\n        self.next_case = None\n        self.skip = False\n        self.need_break = True\n\n    def __str__(self):\n        return ''.join([str(i) for i in self.buffer])\n\n    def str_ext(self) -&gt; list[tuple]:\n        return self.buffer2\n\n    def inc_ind(self, i=1):\n        self.ind += 4 * i\n\n    def dec_ind(self, i=1):\n        self.ind -= 4 * i\n\n    def space(self):\n        if self.skip:\n            self.skip = False\n            return ''\n        return ' ' * self.ind\n\n    def write_ind(self):\n        if self.skip:\n            self.skip = False\n        else:\n            self.write(self.space())\n            self.write_ext(('INDENTATION', self.space()))\n\n    def write(self, s, data=None):\n        self.buffer.append(s)\n        # old method, still used\n        # TODO: clean?\n        if data:\n            self.buffer2.append((data, s))\n\n    # at minimum, we have t as a tuple of the form:\n    # (TYPE_STR, MY_STR) such as ('THIS', 'this')\n    # where the 2nd field is the actual generated source code\n    # We can have more fields, for example:\n    # ('METHOD', 'sendToServer', 'this -&gt; sendToServer', &lt;androguard.decompiler.instruction.ThisParam&gt;)\n    def write_ext(self, t):\n        if not isinstance(t, tuple):\n            raise \"Error in write_ext: %s not a tuple\" % str(t)\n        self.buffer2.append(t)\n\n    def end_ins(self):\n        self.write(';\\n')\n        self.write_ext(('END_INSTRUCTION', ';\\n'))\n\n    def write_ind_visit_end(self, lhs, s, rhs=None, data=None):\n        self.write_ind()\n        lhs.visit(self)\n        self.write(s)\n        self.write_ext(('TODO_4343', s, data))\n        if rhs is not None:\n            rhs.visit(self)\n        self.end_ins()\n\n    # TODO: prefer this class as write_ind_visit_end that should be deprecated\n    # at the end\n    def write_ind_visit_end_ext(\n        self,\n        lhs,\n        before,\n        s,\n        after,\n        rhs=None,\n        data=None,\n        subsection='UNKNOWN_SUBSECTION',\n    ):\n        self.write_ind()\n        lhs.visit(self)\n        self.write(before + s + after)\n        self.write_ext(('BEFORE', before))\n        self.write_ext((subsection, s, data))\n        self.write_ext(('AFTER', after))\n        if rhs is not None:\n            rhs.visit(self)\n        self.end_ins()\n\n    def write_inplace_if_possible(self, lhs, rhs):\n        if isinstance(rhs, BinaryExpression) and lhs == rhs.var_map[rhs.arg1]:\n            exp_rhs = rhs.var_map[rhs.arg2]\n            if (\n                rhs.op in '+-'\n                and isinstance(exp_rhs, Constant)\n                and exp_rhs.get_int_value() == 1\n            ):\n                return self.write_ind_visit_end(lhs, rhs.op * 2, data=rhs)\n            return self.write_ind_visit_end(\n                lhs, ' %s= ' % rhs.op, exp_rhs, data=rhs\n            )\n        return self.write_ind_visit_end(lhs, ' = ', rhs, data=rhs)\n\n    def visit_ins(self, ins):\n        ins.visit(self)\n\n    def write_method(self):\n        acc = []\n        access = self.method.access\n        self.constructor = False\n        for modifier in access:\n            if modifier == 'constructor':\n                self.constructor = True\n                continue\n            acc.append(modifier)\n        self.write('\\n%s' % self.space())\n        self.write_ext(('NEWLINE', '\\n%s' % (self.space())))\n        if acc:\n            self.write('%s ' % ' '.join(acc))\n            self.write_ext(('PROTOTYPE_ACCESS', '%s ' % ' '.join(acc)))\n        if self.constructor:\n            name = get_type(self.method.cls_name).split('.')[-1]\n            self.write(name)\n            self.write_ext(('NAME_METHOD_PROTOTYPE', '%s' % name, self.method))\n        else:\n            self.write(\n                '{} {}'.format(get_type(self.method.type), self.method.name)\n            )\n            self.write_ext(\n                ('PROTOTYPE_TYPE', '%s' % get_type(self.method.type))\n            )\n            self.write_ext(('SPACE', ' '))\n            self.write_ext(\n                ('NAME_METHOD_PROTOTYPE', '%s' % self.method.name, self.method)\n            )\n        params = self.method.lparams\n        if 'static' not in access:\n            params = params[1:]\n        proto = ''\n        self.write_ext(('PARENTHESIS_START', '('))\n        if self.method.params_type:\n            proto = ', '.join(\n                [\n                    '{} p{}'.format(get_type(p_type), param)\n                    for p_type, param in zip(self.method.params_type, params)\n                ]\n            )\n            first = True\n            for p_type, param in zip(self.method.params_type, params):\n                if not first:\n                    self.write_ext(('COMMA', ', '))\n                else:\n                    first = False\n                self.write_ext(('ARG_TYPE', '%s' % get_type(p_type)))\n                self.write_ext(('SPACE', ' '))\n                self.write_ext(\n                    ('NAME_ARG', 'p%s' % param, p_type, self.method)\n                )\n        self.write_ext(('PARENTHESIS_END', ')'))\n        self.write('(%s)' % proto)\n        if self.graph is None:\n            self.write(';\\n')\n            self.write_ext(('METHOD_END_NO_CONTENT', ';\\n'))\n            return\n        self.write('\\n%s{\\n' % self.space())\n        self.write_ext(('METHOD_START', '\\n%s{\\n' % self.space()))\n        self.inc_ind()\n        self.visit_node(self.graph.entry)\n        self.dec_ind()\n        self.write('%s}\\n' % self.space())\n        self.write_ext(('METHOD_END', '%s}\\n' % self.space()))\n\n    def visit_node(self, node):\n        if node in (\n            self.if_follow[-1],\n            self.switch_follow[-1],\n            self.loop_follow[-1],\n            self.latch_node[-1],\n            self.try_follow[-1],\n        ):\n            return\n        if not node.type.is_return and node in self.visited_nodes:\n            return\n        self.visited_nodes.add(node)\n        for var in node.var_to_declare:\n            var.visit_decl(self)\n            var.declared = True\n        node.visit(self)\n\n    def visit_loop_node(self, loop):\n        follow = loop.follow['loop']\n        if follow is None and not loop.looptype.is_endless:\n            logger.error('Loop has no follow !')\n        if loop.looptype.is_pretest:\n            if loop.true is follow:\n                loop.neg()\n                loop.true, loop.false = loop.false, loop.true\n            self.write('%swhile (' % self.space())\n            self.write_ext(('WHILE', '%swhile (' % self.space()))\n            loop.visit_cond(self)\n            self.write(') {\\n')\n            self.write_ext(('WHILE_START', ') {\\n'))\n        elif loop.looptype.is_posttest:\n            self.write('%sdo {\\n' % self.space())\n            self.write_ext(('DO', '%sdo {\\n' % self.space()))\n            self.latch_node.append(loop.latch)\n        elif loop.looptype.is_endless:\n            self.write('%swhile(true) {\\n' % self.space())\n            self.write_ext(('WHILE_TRUE', '%swhile(true) {\\n' % self.space()))\n        self.inc_ind()\n        self.loop_follow.append(follow)\n        if loop.looptype.is_pretest:\n            self.visit_node(loop.true)\n        else:\n            self.visit_node(loop.cond)\n        self.loop_follow.pop()\n        self.dec_ind()\n        if loop.looptype.is_pretest:\n            self.write('%s}\\n' % self.space())\n            self.write_ext(('END_PRETEST', '%s}\\n' % self.space()))\n        elif loop.looptype.is_posttest:\n            self.latch_node.pop()\n            self.write('%s} while(' % self.space())\n            self.write_ext(('WHILE_POSTTEST', '%s} while(' % self.space()))\n            loop.latch.visit_cond(self)\n            self.write(');\\n')\n            self.write_ext(('POSTTEST_END', ');\\n'))\n        else:\n            self.inc_ind()\n            self.visit_node(loop.latch)\n            self.dec_ind()\n            self.write('%s}\\n' % self.space())\n            self.write_ext(('END_LOOP', '%s}\\n' % self.space()))\n        if follow is not None:\n            self.visit_node(follow)\n\n    def visit_cond_node(self, cond):\n        follow = cond.follow['if']\n        if cond.false is cond.true:\n            self.write(\n                '%s// Both branches of the condition point to the same'\n                ' code.\\n' % self.space()\n            )\n            self.write_ext(\n                (\n                    'COMMENT_ERROR_MSG',\n                    '%s// Both branches of the condition point to the same'\n                    ' code.\\n' % self.space(),\n                )\n            )\n            self.write('%s// if (' % self.space())\n            self.write_ext(('COMMENT_IF', '%s// if (' % self.space()))\n            cond.visit_cond(self)\n            self.write(') {\\n')\n            self.write_ext(('COMMENT_COND_END', ') {\\n'))\n            self.inc_ind()\n            self.visit_node(cond.true)\n            self.dec_ind()\n            self.write('%s// }\\n' % self.space(), data=\"COMMENT_IF_COND_END\")\n            return\n        if cond.false is self.loop_follow[-1]:\n            cond.neg()\n            cond.true, cond.false = cond.false, cond.true\n        if self.loop_follow[-1] in (cond.true, cond.false):\n            self.write('%sif (' % self.space(), data=\"IF_2\")\n            cond.visit_cond(self)\n            self.write(') {\\n', data=\"IF_TRUE_2\")\n            self.inc_ind()\n            self.write('%sbreak;\\n' % self.space(), data=\"BREAK\")\n            self.dec_ind()\n            self.write('%s}\\n' % self.space(), data=\"IF_END_2\")\n            self.visit_node(cond.false)\n        elif follow is not None:\n            if (\n                cond.true in (follow, self.next_case)\n                or cond.num &gt; cond.true.num\n            ):\n                # or cond.true.num &gt; cond.false.num:\n                cond.neg()\n                cond.true, cond.false = cond.false, cond.true\n            self.if_follow.append(follow)\n            if cond.true:  # in self.visited_nodes:\n                self.write('%sif (' % self.space(), data=\"IF\")\n                cond.visit_cond(self)\n                self.write(') {\\n', data=\"IF_TRUE\")\n                self.inc_ind()\n                self.visit_node(cond.true)\n                self.dec_ind()\n            is_else = not (follow in (cond.true, cond.false))\n            if is_else and not cond.false in self.visited_nodes:\n                self.write('%s} else {\\n' % self.space(), data=\"IF_FALSE\")\n                self.inc_ind()\n                self.visit_node(cond.false)\n                self.dec_ind()\n            self.if_follow.pop()\n            self.write('%s}\\n' % self.space(), data=\"IF_END\")\n            self.visit_node(follow)\n        else:\n            self.write('%sif (' % self.space(), data=\"IF_3\")\n            cond.visit_cond(self)\n            self.write(') {\\n', data=\"IF_COND_3\")\n            self.inc_ind()\n            self.visit_node(cond.true)\n            self.dec_ind()\n            self.write('%s} else {\\n' % self.space(), data=\"ELSE_3\")\n            self.inc_ind()\n            self.visit_node(cond.false)\n            self.dec_ind()\n            self.write('%s}\\n' % self.space(), data=\"IF_END_3\")\n\n    def visit_short_circuit_condition(self, nnot, aand, cond1, cond2):\n        if nnot:\n            cond1.neg()\n        self.write('(', data=\"TODO24\")\n        cond1.visit_cond(self)\n        self.write(') %s (' % ['||', '&amp;&amp;'][aand], data=\"TODO25\")\n        cond2.visit_cond(self)\n        self.write(')', data=\"TODO26\")\n\n    def visit_switch_node(self, switch):\n        lins = switch.get_ins()\n        for ins in lins[:-1]:\n            self.visit_ins(ins)\n        switch_ins = switch.get_ins()[-1]\n        self.write('%sswitch (' % self.space(), data=\"SWITCH\")\n        self.visit_ins(switch_ins)\n        self.write(') {\\n', data=\"SWITCH_END\")\n        follow = switch.follow['switch']\n        cases = switch.cases\n        self.switch_follow.append(follow)\n        default = switch.default\n        for i, node in enumerate(cases):\n            if node in self.visited_nodes:\n                continue\n            self.inc_ind()\n            for case in switch.node_to_case[node]:\n                self.write(\n                    '%scase %d:\\n' % (self.space(), case), data=\"CASE_XX\"\n                )\n            if i + 1 &lt; len(cases):\n                self.next_case = cases[i + 1]\n            else:\n                self.next_case = None\n            if node is default:\n                self.write('%sdefault:\\n' % self.space(), data=\"CASE_DEFAULT\")\n                default = None\n            self.inc_ind()\n            self.visit_node(node)\n            if self.need_break:\n                self.write('%sbreak;\\n' % self.space(), data=\"CASE_BREAK\")\n            else:\n                self.need_break = True\n            self.dec_ind(2)\n        if default not in (None, follow):\n            self.inc_ind()\n            self.write('%sdefault:\\n' % self.space(), data=\"CASE_DEFAULT_2\")\n            self.inc_ind()\n            self.visit_node(default)\n            self.dec_ind(2)\n        self.write('%s}\\n' % self.space(), data=\"CASE_END\")\n        self.switch_follow.pop()\n        self.visit_node(follow)\n\n    def visit_statement_node(self, stmt):\n        sucs = self.graph.sucs(stmt)\n        for ins in stmt.get_ins():\n            self.visit_ins(ins)\n        if len(sucs) == 1:\n            if sucs[0] is self.loop_follow[-1]:\n                self.write('%sbreak;\\n' % self.space(), data=\"BREAK_2\")\n            elif sucs[0] is self.next_case:\n                self.need_break = False\n            else:\n                self.visit_node(sucs[0])\n\n    def visit_try_node(self, try_node):\n        self.write('%stry {\\n' % self.space(), data=\"TRY_START\")\n        self.inc_ind()\n        self.try_follow.append(try_node.follow)\n        self.visit_node(try_node.try_start)\n        self.dec_ind()\n        self.write('%s}' % self.space(), data=\"TRY_START_END\")\n        for catch in try_node.catch:\n            self.visit_node(catch)\n        self.write('\\n', data=\"NEWLINE_END_TRY\")\n        self.visit_node(self.try_follow.pop())\n\n    def visit_catch_node(self, catch_node):\n        self.write(' catch (', data=\"CATCH\")\n        catch_node.visit_exception(self)\n        self.write(') {\\n', data=\"CATCH_START\")\n        self.inc_ind()\n        self.visit_node(catch_node.catch_start)\n        self.dec_ind()\n        self.write('%s}' % self.space(), data=\"CATCH_END\")\n\n    def visit_return_node(self, ret):\n        self.need_break = False\n        for ins in ret.get_ins():\n            self.visit_ins(ins)\n\n    def visit_throw_node(self, throw):\n        for ins in throw.get_ins():\n            self.visit_ins(ins)\n\n    def visit_decl(self, var):\n        if not var.declared:\n            var_type = var.get_type() or 'unknownType'\n            self.write(\n                '{}{} v{}'.format(self.space(), get_type(var_type), var.name),\n                data=\"DECLARATION\",\n            )\n            self.end_ins()\n\n    def visit_constant(self, cst):\n        if isinstance(cst, str):\n            return self.write(string(cst), data=\"CONSTANT_STRING\")\n        self.write(\n            '%r' % cst, data=\"CONSTANT_INTEGER\"\n        )  # INTEGER or also others?\n\n    def visit_base_class(self, cls, data=None):\n        self.write(cls)\n        self.write_ext(('NAME_BASE_CLASS', cls, data))\n\n    def visit_variable(self, var):\n        var_type = var.get_type() or 'unknownType'\n        if not var.declared:\n            self.write('%s ' % get_type(var_type))\n            self.write_ext(\n                ('VARIABLE_TYPE', '%s' % get_type(var_type), var_type)\n            )\n            self.write_ext(('SPACE', ' '))\n            var.declared = True\n        self.write('v%s' % var.name)\n        self.write_ext(('NAME_VARIABLE', 'v%s' % var.name, var, var_type))\n\n    def visit_param(self, param, data=None):\n        self.write('p%s' % param)\n        self.write_ext(('NAME_PARAM', 'p%s' % param, data))\n\n    def visit_this(self):\n        self.write('this', data=\"THIS\")\n\n    def visit_super(self):\n        self.write('super')\n\n    def visit_assign(self, lhs, rhs):\n        if lhs is not None:\n            return self.write_inplace_if_possible(lhs, rhs)\n        self.write_ind()\n        rhs.visit(self)\n        if not self.skip:\n            self.end_ins()\n\n    def visit_move_result(self, lhs, rhs):\n        self.write_ind_visit_end(lhs, ' = ', rhs)\n\n    def visit_move(self, lhs, rhs):\n        if lhs is not rhs:\n            self.write_inplace_if_possible(lhs, rhs)\n\n    def visit_astore(self, array, index, rhs, data=None):\n        self.write_ind()\n        array.visit(self)\n        self.write('[', data=(\"ASTORE_START\", data))\n        index.visit(self)\n        self.write('] = ', data=\"ASTORE_END\")\n        rhs.visit(self)\n        self.end_ins()\n\n    def visit_put_static(self, cls, name, rhs):\n        self.write_ind()\n        self.write('{}.{} = '.format(cls, name), data=\"STATIC_PUT\")\n        rhs.visit(self)\n        self.end_ins()\n\n    def visit_put_instance(self, lhs, name, rhs, data=None):\n        self.write_ind_visit_end_ext(\n            lhs,\n            '.',\n            '%s' % name,\n            ' = ',\n            rhs,\n            data=data,\n            subsection='NAME_CLASS_ASSIGNMENT',\n        )\n\n    def visit_new(self, atype, data=None):\n        self.write('new %s' % get_type(atype))\n        self.write_ext(('NEW', 'new '))\n        self.write_ext(\n            ('NAME_CLASS_NEW', '%s' % get_type(atype), data.type, data)\n        )\n\n    def visit_invoke(self, name, base, ptype, rtype, args, invokeInstr):\n        if isinstance(base, ThisParam):\n            if name == '&lt;init&gt;':\n                if self.constructor and len(args) == 0:\n                    self.skip = True\n                    return\n                if (\n                    invokeInstr\n                    and base.type[1:-1].replace('/', '.') != invokeInstr.cls\n                ):\n                    base.super = True\n        base.visit(self)\n        if name != '&lt;init&gt;':\n            if isinstance(base, BaseClass):\n                call_name = \"{} -&gt; {}\".format(base.cls, name)\n            elif isinstance(base, InstanceExpression):\n                call_name = \"{} -&gt; {}\".format(base.ftype, name)\n            elif hasattr(base, \"base\") and hasattr(base, \"var_map\"):\n                base2base = base\n                while True:\n                    base2base = base2base.var_map[base2base.base]\n                    if isinstance(base2base, NewInstance):\n                        call_name = \"{} -&gt; {}\".format(base2base.type, name)\n                        break\n                    elif hasattr(base2base, \"base\") and hasattr(\n                        base2base, \"var_map\"\n                    ):\n                        continue\n                    else:\n                        call_name = \"UNKNOWN_TODO\"\n                        break\n            elif isinstance(base, ThisParam):\n                call_name = \"this -&gt; %s\" % name\n            elif isinstance(base, Variable):\n                call_name = \"{} -&gt; {}\".format(base.type, name)\n            else:\n                call_name = \"UNKNOWN_TODO2\"\n            self.write('.%s' % name)\n            self.write_ext(('INVOKE', '.'))\n            self.write_ext(\n                (\n                    'NAME_METHOD_INVOKE',\n                    '%s' % name,\n                    call_name,\n                    ptype,\n                    rtype,\n                    base,\n                    invokeInstr,\n                )\n            )\n        self.write('(', data=\"PARAM_START\")\n        comma = False\n        for arg in args:\n            if comma:\n                self.write(', ', data=\"PARAM_SEPARATOR\")\n            comma = True\n            arg.visit(self)\n        self.write(')', data=\"PARAM_END\")\n\n    def visit_return_void(self):\n        self.write_ind()\n        self.write('return', data=\"RETURN\")\n        self.end_ins()\n\n    def visit_return(self, arg):\n        self.write_ind()\n        self.write('return ', data=\"RETURN\")\n        arg.visit(self)\n        self.end_ins()\n\n    def visit_nop(self):\n        pass\n\n    def visit_switch(self, arg):\n        arg.visit(self)\n\n    def visit_check_cast(self, arg, atype):\n        self.write('((%s) ' % atype, data=\"CHECKCAST\")\n        arg.visit(self)\n        self.write(')')\n\n    def visit_aload(self, array, index):\n        array.visit(self)\n        self.write('[', data=\"ALOAD_START\")\n        index.visit(self)\n        self.write(']', data=\"ALOAD_END\")\n\n    def visit_alength(self, array):\n        array.visit(self)\n        self.write('.length', data=\"ARRAY_LENGTH\")\n\n    def visit_new_array(self, atype, size):\n        self.write('new %s[' % get_type(atype[1:]), data=\"NEW_ARRAY\")\n        size.visit(self)\n        self.write(']', data=\"NEW_ARRAY_END\")\n\n    def visit_filled_new_array(self, atype, size, args):\n        self.write('new %s {' % get_type(atype), data=\"NEW_ARRAY_FILLED\")\n        for idx, arg in enumerate(args):\n            arg.visit(self)\n            if idx + 1 &lt; len(args):\n                self.write(', ', data=\"COMMA\")\n        self.write('})', data=\"NEW_ARRAY_FILLED_END\")\n\n    def visit_fill_array(self, array, value):\n        self.write_ind()\n        array.visit(self)\n        self.write(' = {', data=\"ARRAY_FILLED\")\n        data = value.get_data()\n        tab = []\n        elem_size = value.element_width\n\n        # Set type depending on size of elements\n        data_types = {1: 'b', 2: 'h', 4: 'i', 8: 'd'}\n\n        if elem_size in data_types:\n            elem_id = data_types[elem_size]\n        else:\n            # FIXME for other types we just assume bytes...\n            logger.warning(\n                \"Unknown element size {} for array. Assume bytes.\".format(\n                    elem_size\n                )\n            )\n            elem_id = 'b'\n            elem_size = 1\n\n        for i in range(0, value.size * elem_size, elem_size):\n            tab.append('%s' % unpack(elem_id, data[i : i + elem_size])[0])\n        self.write(', '.join(tab), data=\"COMMA\")\n        self.write('}', data=\"ARRAY_FILLED_END\")\n        self.end_ins()\n\n    def visit_move_exception(self, var, data=None):\n        var.declared = True\n        var_type = var.get_type() or 'unknownType'\n        self.write('{} v{}'.format(get_type(var_type), var.name))\n        self.write_ext(\n            ('EXCEPTION_TYPE', '%s' % get_type(var_type), data.type)\n        )\n        self.write_ext(('SPACE', ' '))\n        self.write_ext(\n            ('NAME_CLASS_EXCEPTION', 'v%s' % var.value(), data.type, data)\n        )\n\n    def visit_monitor_enter(self, ref):\n        self.write_ind()\n        self.write('synchronized(', data=\"SYNCHRONIZED\")\n        ref.visit(self)\n        self.write(') {\\n', data=\"SYNCHRONIZED_END\")\n        self.inc_ind()\n\n    def visit_monitor_exit(self, ref):\n        self.dec_ind()\n        self.write_ind()\n        self.write('}\\n', data=\"MONITOR_EXIT\")\n\n    def visit_throw(self, ref):\n        self.write_ind()\n        self.write('throw ', data=\"THROW\")\n        ref.visit(self)\n        self.end_ins()\n\n    def visit_binary_expression(self, op, arg1, arg2):\n        self.write('(', data=\"BINARY_EXPRESSION_START\")\n        arg1.visit(self)\n        self.write(' %s ' % op, data=\"TODO58\")\n        arg2.visit(self)\n        self.write(')', data=\"BINARY_EXPRESSION_END\")\n\n    def visit_unary_expression(self, op, arg):\n        self.write('(%s ' % op, data=\"UNARY_EXPRESSION_START\")\n        arg.visit(self)\n        self.write(')', data=\"UNARY_EXPRESSION_END\")\n\n    def visit_cast(self, op, arg):\n        self.write('(%s ' % op, data=\"CAST_START\")\n        arg.visit(self)\n        self.write(')', data=\"CAST_END\")\n\n    def visit_cond_expression(self, op, arg1, arg2):\n        arg1.visit(self)\n        self.write(' %s ' % op, data=\"COND_EXPRESSION\")\n        arg2.visit(self)\n\n    def visit_condz_expression(self, op, arg):\n        if isinstance(arg, BinaryCompExpression):\n            arg.op = op\n            return arg.visit(self)\n        atype = str(arg.get_type())\n        if atype == 'Z':\n            if op == Op.EQUAL:\n                self.write('!', data=\"NEGATE\")\n            arg.visit(self)\n        else:\n            arg.visit(self)\n            try:\n                atype = atype.string\n            except AttributeError:\n                pass\n            if atype in 'VBSCIJFD':\n                self.write(' %s 0' % op, data=\"TODO64\")\n            else:\n                self.write(' %s null' % op, data=\"TODO65\")\n\n    def visit_get_instance(self, arg, name, data=None):\n        arg.visit(self)\n        self.write('.%s' % name)\n        self.write_ext(('GET_INSTANCE', '.'))\n        self.write_ext(('NAME_CLASS_INSTANCE', '%s' % name, data))\n\n    def visit_get_static(self, cls, name):\n        self.write('{}.{}'.format(cls, name), data=\"GET_STATIC\")\n</code></pre>"},{"location":"reference/androguard/decompiler/writer.html#androguard.decompiler.writer.string","title":"<code>string(s)</code>","text":"<p>Convert a string to a escaped ASCII representation including quotation marks</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <p>a string</p> required <p>Returns:</p> Type Description <p>ASCII escaped string</p> Source code in <code>androguard/decompiler/writer.py</code> <pre><code>def string(s):\n    \"\"\"\n    Convert a string to a escaped ASCII representation including quotation marks\n    :param s: a string\n    :return: ASCII escaped string\n    \"\"\"\n    ret = ['\"']\n    for c in s:\n        if ' ' &lt;= c &lt; '\\x7f':\n            if c == \"'\" or c == '\"' or c == '\\\\':\n                ret.append('\\\\')\n            ret.append(c)\n            continue\n        elif c &lt;= '\\x7f':\n            if c in ('\\r', '\\n', '\\t'):\n                # unicode-escape produces bytes\n                ret.append(c.encode('unicode-escape').decode(\"ascii\"))\n                continue\n        i = ord(c)\n        ret.append('\\\\u')\n        ret.append('%x' % (i &gt;&gt; 12))\n        ret.append('%x' % ((i &gt;&gt; 8) &amp; 0x0F))\n        ret.append('%x' % ((i &gt;&gt; 4) &amp; 0x0F))\n        ret.append('%x' % (i &amp; 0x0F))\n    ret.append('\"')\n    return ''.join(ret)\n</code></pre>"},{"location":"reference/androguard/pentest/index.html","title":"pentest","text":""},{"location":"reference/androguard/pentest/adb.html","title":"adb","text":""},{"location":"reference/androguard/ui/index.html","title":"ui","text":""},{"location":"reference/androguard/ui/index.html#androguard.ui.DummyControl","title":"<code>DummyControl</code>","text":"<p>               Bases: <code>UIControl</code></p> <p>A dummy control object that doesn't paint any content.</p> <p>Useful for filling a :class:<code>~prompt_toolkit.layout.Window</code>. (The <code>fragment</code> and <code>char</code> attributes of the <code>Window</code> class can be used to define the filling.)</p> Source code in <code>androguard/ui/__init__.py</code> <pre><code>class DummyControl(UIControl):\n    \"\"\"\n    A dummy control object that doesn't paint any content.\n\n    Useful for filling a :class:`~prompt_toolkit.layout.Window`. (The\n    `fragment` and `char` attributes of the `Window` class can be used to\n    define the filling.)\n    \"\"\"\n\n    def create_content(self, width: int, height: int) -&gt; UIContent:\n        def get_line(i: int) -&gt; StyleAndTextTuples:\n            return []\n\n        return UIContent(\n            get_line=get_line, line_count=100**100\n        )  # Something very big.\n\n    def is_focusable(self) -&gt; bool:\n        return True\n</code></pre>"},{"location":"reference/androguard/ui/data_types.html","title":"data_types","text":""},{"location":"reference/androguard/ui/data_types.html#androguard.ui.data_types.DisplayTransaction","title":"<code>DisplayTransaction</code>","text":"Source code in <code>androguard/ui/data_types.py</code> <pre><code>class DisplayTransaction:\n\n    def __init__(self, block: Message) -&gt; None:\n        self.block: Message = block\n        self.timestamp = (datetime.datetime.now().strftime('%H:%M:%S'),)\n\n    @property\n    def index(self) -&gt; int:\n        return self.block.index\n\n    @property\n    def unsupported_call(self) -&gt; bool:\n        return ''  # self.block.unsupported_call\n\n    @property\n    def to_method(self) -&gt; str:\n        return self.block.to_method\n\n    @property\n    def from_method(self) -&gt; str:\n        return self.block.from_method\n\n    @property\n    def params(self) -&gt; str:\n        return self.block.params\n\n    @property\n    def ret_value(self) -&gt; str:\n        return self.block.ret_value\n\n    @property\n    def fields(self):  # -&gt; Field | None:\n        return None  # self.block.root_field\n\n    @property\n    def direction_indicator(self) -&gt; str:\n        return '\\u21D0'\n\n        if self.block.direction == Direction.IN:\n            return '\\u21D0' if self.block.oneway else '\\u21D2'\n        elif self.block.direction == Direction.OUT:\n            return '\\u21CF'\n        else:\n            return ''\n\n    def style(self) -&gt; str:\n        if type(self.block) is MessageEvent:\n            style = \"class:transaction.oneway\"\n        elif type(self.block) is MessageSystem:\n            style = \"class:transaction.response\"\n        else:\n            style = \"class:transaction.default\"\n        return style\n\n        if self.unsupported_call:\n            style = \"class:transaction.unsupported\"\n        elif self.block.errors:\n            style = \"class:transaction.error\"\n        elif self.block.unsupported_call:\n            style = \"class:transaction.no_aidl\"\n        elif self.block.direction == Direction.IN:\n            style = (\n                \"class:transaction.oneway\"\n                if self.block.oneway\n                else \"class:transaction.request\"\n            )\n        elif self.block.direction == Direction.OUT:\n            style = \"class:transaction.response\"\n        else:\n            style = \"class:transaction.default\"\n        return style\n\n    def type(self) -&gt; str:\n        \"\"\"Gets the type of the Block as a simple short string for use in pattern matching\"\"\"\n        return \"oneway\"\n\n        if self.unsupported_call:\n            type_name = \"unsupported type\"\n        elif self.block.errors:\n            type_name = \"error\"\n        elif self.block.direction == Direction.IN:\n            # TODO: Should this be \"oneway\" or \"async call\"?\n            type_name = \"oneway\" if self.block.oneway else \"call\"\n        elif self.block.direction == Direction.OUT:\n            type_name = \"return\"\n        else:\n            type_name = \"unknown\"  # Should be impossible\n\n        return type_name\n</code></pre>"},{"location":"reference/androguard/ui/data_types.html#androguard.ui.data_types.DisplayTransaction.type","title":"<code>type()</code>","text":"<p>Gets the type of the Block as a simple short string for use in pattern matching</p> Source code in <code>androguard/ui/data_types.py</code> <pre><code>def type(self) -&gt; str:\n    \"\"\"Gets the type of the Block as a simple short string for use in pattern matching\"\"\"\n    return \"oneway\"\n\n    if self.unsupported_call:\n        type_name = \"unsupported type\"\n    elif self.block.errors:\n        type_name = \"error\"\n    elif self.block.direction == Direction.IN:\n        # TODO: Should this be \"oneway\" or \"async call\"?\n        type_name = \"oneway\" if self.block.oneway else \"call\"\n    elif self.block.direction == Direction.OUT:\n        type_name = \"return\"\n    else:\n        type_name = \"unknown\"  # Should be impossible\n\n    return type_name\n</code></pre>"},{"location":"reference/androguard/ui/filter.html","title":"filter","text":""},{"location":"reference/androguard/ui/filter.html#androguard.ui.filter.Filter","title":"<code>Filter</code>","text":"<p>CLASS Filter     Brief - Class that represents a single filter     Description -         It holds and interface, method and list of types to check against         It also holds the function which checks if a block passes the filter</p> Source code in <code>androguard/ui/filter.py</code> <pre><code>class Filter:\n    \"\"\"\n    CLASS Filter\n        Brief - Class that represents a single filter\n        Description -\n            It holds and interface, method and list of types to check against\n            It also holds the function which checks if a block passes the filter\n    \"\"\"\n\n    def __init__(\n        self,\n        interface: Optional[str] = None,\n        method: Optional[str] = None,\n        types: Optional[list[str]] = None,\n        include: bool = True,\n    ):\n        self.interface = interface\n        self.method = method\n        self.types = (\n            types or []\n        )  # List of associated types of the filter (call, return, etc)\n        self.inclusive = include\n\n    def passes(self):\n        \"\"\"\n        FUNCTION passes\n            Brief - Returns whether a block should be displayed\n            Description -\n                Returns TRUE if the block should be shown\n                Returns FALSE if the block should no be shown\n\n                The code checks if the filter passes the checks, and then tailors the output to the filter_mode\n                The type is either Inclusive (\"Incl\") or Exclusive (\"Excl\")\n        \"\"\"\n        # matches = (\n        #    (not self.types or block.type() in self.types) and\n        #    (not self.interface or self.interface in block.interface) and\n        #    (not self.method or self.method in block.method)\n        # )\n        # return not matches ^ self.inclusive\n        return False\n\n    def toggle_inclusivity(self):\n        self.inclusive = not self.inclusive\n\n    def __str__(self):\n        interface = self.interface or \"*\"\n        method = self.method or \"*\"\n        types = \"|\".join(self.types) if self.types else \"*\"\n\n        return f\"interface={interface}, method={method}, types={types}\"\n</code></pre>"},{"location":"reference/androguard/ui/filter.html#androguard.ui.filter.Filter.passes","title":"<code>passes()</code>","text":"<p>FUNCTION passes     Brief - Returns whether a block should be displayed     Description -         Returns TRUE if the block should be shown         Returns FALSE if the block should no be shown</p> <pre><code>    The code checks if the filter passes the checks, and then tailors the output to the filter_mode\n    The type is either Inclusive (\"Incl\") or Exclusive (\"Excl\")\n</code></pre> Source code in <code>androguard/ui/filter.py</code> <pre><code>def passes(self):\n    \"\"\"\n    FUNCTION passes\n        Brief - Returns whether a block should be displayed\n        Description -\n            Returns TRUE if the block should be shown\n            Returns FALSE if the block should no be shown\n\n            The code checks if the filter passes the checks, and then tailors the output to the filter_mode\n            The type is either Inclusive (\"Incl\") or Exclusive (\"Excl\")\n    \"\"\"\n    # matches = (\n    #    (not self.types or block.type() in self.types) and\n    #    (not self.interface or self.interface in block.interface) and\n    #    (not self.method or self.method in block.method)\n    # )\n    # return not matches ^ self.inclusive\n    return False\n</code></pre>"},{"location":"reference/androguard/ui/filter.html#androguard.ui.filter.FilterSet","title":"<code>FilterSet</code>","text":"<p>               Bases: <code>UserList[_T]</code></p> Source code in <code>androguard/ui/filter.py</code> <pre><code>class FilterSet(UserList[_T]):\n\n    def passes(self, interface=None, method=None, call_type=None):\n        \"\"\"Return True if all filters in the set pass, False otherwise.\"\"\"\n        return all([f.passes(interface, method, call_type) for f in self.data])\n</code></pre>"},{"location":"reference/androguard/ui/filter.html#androguard.ui.filter.FilterSet.passes","title":"<code>passes(interface=None, method=None, call_type=None)</code>","text":"<p>Return True if all filters in the set pass, False otherwise.</p> Source code in <code>androguard/ui/filter.py</code> <pre><code>def passes(self, interface=None, method=None, call_type=None):\n    \"\"\"Return True if all filters in the set pass, False otherwise.\"\"\"\n    return all([f.passes(interface, method, call_type) for f in self.data])\n</code></pre>"},{"location":"reference/androguard/ui/selection.html","title":"selection","text":""},{"location":"reference/androguard/ui/table.html","title":"table","text":""},{"location":"reference/androguard/ui/table.html#androguard.ui.table.AsciiBorder","title":"<code>AsciiBorder</code>","text":"<p>Box drawing characters. (ASCII)</p> Source code in <code>androguard/ui/table.py</code> <pre><code>class AsciiBorder:\n    \"Box drawing characters. (ASCII)\"\n    HORIZONTAL = '-'\n    VERTICAL = '|'\n\n    TOP_LEFT = '+'\n    TOP_RIGHT = '+'\n    BOTTOM_LEFT = '+'\n    BOTTOM_RIGHT = '+'\n\n    LEFT_T = '+'\n    RIGHT_T = '+'\n    TOP_T = '+'\n    BOTTOM_T = '+'\n\n    INTERSECT = '+'\n</code></pre>"},{"location":"reference/androguard/ui/table.html#androguard.ui.table.DoubleBorder","title":"<code>DoubleBorder</code>","text":"<p>Box drawing characters. (Thin)</p> Source code in <code>androguard/ui/table.py</code> <pre><code>class DoubleBorder:\n    \"Box drawing characters. (Thin)\"\n    HORIZONTAL = '\\u2550'\n    VERTICAL = '\\u2551'\n\n    TOP_LEFT = '\\u2554'\n    TOP_RIGHT = '\\u2557'\n    BOTTOM_LEFT = '\\u255a'\n    BOTTOM_RIGHT = '\\u255d'\n\n    LEFT_T = '\\u2560'\n    RIGHT_T = '\\u2563'\n    TOP_T = '\\u2566'\n    BOTTOM_T = '\\u2569'\n\n    INTERSECT = '\\u256c'\n</code></pre>"},{"location":"reference/androguard/ui/table.html#androguard.ui.table.RoundedBorder","title":"<code>RoundedBorder</code>","text":"<p>               Bases: <code>ThinBorder</code></p> <p>Box drawing characters. (Rounded)</p> Source code in <code>androguard/ui/table.py</code> <pre><code>class RoundedBorder(ThinBorder):\n    \"Box drawing characters. (Rounded)\"\n    TOP_LEFT = '\\u256d'\n    TOP_RIGHT = '\\u256e'\n    BOTTOM_LEFT = '\\u2570'\n    BOTTOM_RIGHT = '\\u256f'\n</code></pre>"},{"location":"reference/androguard/ui/table.html#androguard.ui.table.SpaceBorder","title":"<code>SpaceBorder</code>","text":"<p>Box drawing characters. (Spaces)</p> Source code in <code>androguard/ui/table.py</code> <pre><code>class SpaceBorder:\n    \"Box drawing characters. (Spaces)\"\n    HORIZONTAL = ' '\n    VERTICAL = ' '\n\n    TOP_LEFT = ' '\n    TOP_RIGHT = ' '\n    BOTTOM_LEFT = ' '\n    BOTTOM_RIGHT = ' '\n\n    LEFT_T = ' '\n    RIGHT_T = ' '\n    TOP_T = ' '\n    BOTTOM_T = ' '\n\n    INTERSECT = ' '\n</code></pre>"},{"location":"reference/androguard/ui/table.html#androguard.ui.table.Table","title":"<code>Table</code>","text":"<p>               Bases: <code>HSplit</code></p> Source code in <code>androguard/ui/table.py</code> <pre><code>class Table(HSplit):\n\n    def __init__(\n        self,\n        table,\n        borders: AnyBorderStyle = ThinBorder,\n        column_width=None,\n        column_widths=[],\n        window_too_small=None,\n        align=VerticalAlign.JUSTIFY,\n        padding=0,\n        padding_char=None,\n        padding_style='',\n        width=None,\n        height=None,\n        z_index=None,\n        modal=False,\n        key_bindings=None,\n        style='',\n        selected_style='',\n    ):\n        self.borders = borders\n        self.column_width = column_width\n        self.column_widths = column_widths\n        self.selected_style = selected_style\n\n        # ensure the table is iterable (has rows)\n        if not isinstance(table, list):\n            table = [table]\n\n        children = [\n            _Row(row=row, table=self, borders=borders, height=1)\n            for row in table\n        ]\n\n        super().__init__(\n            children=children,\n            window_too_small=window_too_small,\n            align=align,\n            padding=padding,\n            padding_char=padding_char,\n            padding_style=padding_style,\n            width=width,\n            height=height,\n            z_index=z_index,\n            modal=modal,\n            key_bindings=key_bindings,\n            style=style,\n        )\n        self.row_cache = SimpleCache(maxsize=30)\n\n    # def do_update(self, rows):\n    #     self.children.clear()\n    #     self.children.extend(_Row(row=row, table=self, borders=self.borders, height=1, style=\"#000000 bg:#ffffff\") for row in rows)\n\n    def add_row(self, row, style, cache_id):\n        r = self.row_cache.get(\n            cache_id,\n            lambda: _Row(\n                row=row,\n                table=self,\n                borders=self.borders,\n                height=1,\n                style=style,\n            ),\n        )\n        self.children.append(r)\n\n    @property\n    def columns(self):\n        return max(row.raw_columns for row in self.children)\n\n    @property\n    def _all_children(self):\n        \"\"\"\n        List of child objects, including padding &amp; borders.\n        \"\"\"\n\n        def get():\n            result = []\n\n            # Padding top.\n            if self.align in (VerticalAlign.CENTER, VerticalAlign.BOTTOM):\n                result.append(Window(width=D(preferred=0)))\n\n            # Border top is first inserted in children loop.\n\n            # The children with padding.\n            prev = None\n            for child in self.children:\n                # result.append(_Border(\n                #     prev=prev,\n                #     next=child,\n                #     table=self,\n                #     borders=self.borders))\n                result.append(child)\n                prev = child\n\n            # Border bottom.\n            # result.append(_Border(prev=prev, next=None, table=self, borders=self.borders))\n\n            # Padding bottom.\n            if self.align in (VerticalAlign.CENTER, VerticalAlign.TOP):\n                result.append(Window(width=D(preferred=0)))\n\n            return result\n\n        return self._children_cache.get(tuple(self.children), get)\n\n    def preferred_dimensions(self, width):\n        dimensions = [[]] * self.columns\n        for row in self.children:\n            assert isinstance(row, _Row)\n            j = 0\n            for cell in row.children:\n                assert isinstance(cell, _Cell)\n\n                if cell.merge != 1:\n                    dimensions[j].append(cell.preferred_width(width))\n\n                j += cell.merge\n\n        for i, c in enumerate(dimensions):\n            yield D.exact(1)\n\n            try:\n                w = self.column_widths[i]\n            except IndexError:\n                w = self.column_width\n            if w is None:  # fitted\n                yield max_layout_dimensions(c)\n            else:  # fixed or weighted\n                yield to_dimension(w)\n        yield D.exact(1)\n</code></pre>"},{"location":"reference/androguard/ui/table.html#androguard.ui.table.ThickBorder","title":"<code>ThickBorder</code>","text":"<p>Box drawing characters. (Thick)</p> Source code in <code>androguard/ui/table.py</code> <pre><code>class ThickBorder:\n    \"Box drawing characters. (Thick)\"\n    HORIZONTAL = '\\u2501'\n    VERTICAL = '\\u2503'\n\n    TOP_LEFT = '\\u250f'\n    TOP_RIGHT = '\\u2513'\n    BOTTOM_LEFT = '\\u2517'\n    BOTTOM_RIGHT = '\\u251b'\n\n    LEFT_T = '\\u2523'\n    RIGHT_T = '\\u252b'\n    TOP_T = '\\u2533'\n    BOTTOM_T = '\\u253b'\n\n    INTERSECT = '\\u254b'\n</code></pre>"},{"location":"reference/androguard/ui/table.html#androguard.ui.table.ThinBorder","title":"<code>ThinBorder</code>","text":"<p>Box drawing characters. (Thin)</p> Source code in <code>androguard/ui/table.py</code> <pre><code>class ThinBorder:\n    \"Box drawing characters. (Thin)\"\n    HORIZONTAL = '\\u2500'\n    VERTICAL = '\\u2502'\n\n    TOP_LEFT = '\\u250c'\n    TOP_RIGHT = '\\u2510'\n    BOTTOM_LEFT = '\\u2514'\n    BOTTOM_RIGHT = '\\u2518'\n\n    LEFT_T = '\\u251c'\n    RIGHT_T = '\\u2524'\n    TOP_T = '\\u252c'\n    BOTTOM_T = '\\u2534'\n\n    INTERSECT = '\\u253c'\n</code></pre>"},{"location":"reference/androguard/ui/util.html","title":"util","text":""},{"location":"reference/androguard/ui/util.html#androguard.ui.util.clamp","title":"<code>clamp(range_min, range_max, value)</code>","text":"<p>Return value if its is within range_min and range_max else return the nearest bound</p> Source code in <code>androguard/ui/util.py</code> <pre><code>def clamp(range_min: int, range_max: int, value: int) -&gt; int:\n    \"\"\"Return value if its is within range_min and range_max else return the nearest bound\"\"\"\n    return max(min(range_max, value), range_min)\n</code></pre>"},{"location":"reference/androguard/ui/widget/index.html","title":"widget","text":""},{"location":"reference/androguard/ui/widget/details.html","title":"details","text":""},{"location":"reference/androguard/ui/widget/filters.html","title":"filters","text":""},{"location":"reference/androguard/ui/widget/frame.html","title":"frame","text":""},{"location":"reference/androguard/ui/widget/frame.html#androguard.ui.widget.frame.SelectableFrame","title":"<code>SelectableFrame</code>","text":"<p>Draw a border around any container, optionally with a title text.</p> <p>Changing the title and body of the frame is possible at runtime by assigning to the <code>body</code> and <code>title</code> attributes of this class.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>AnyContainer</code> <p>Another container object.</p> required <code>title</code> <code>AnyFormattedText</code> <p>Text to be displayed in the top of the frame (can be formatted text).</p> <code>''</code> <code>style</code> <code>str</code> <p>Style string to be applied to this widget.</p> <code>''</code> Source code in <code>androguard/ui/widget/frame.py</code> <pre><code>class SelectableFrame:\n    \"\"\"\n    Draw a border around any container, optionally with a title text.\n\n    Changing the title and body of the frame is possible at runtime by\n    assigning to the `body` and `title` attributes of this class.\n\n    :param body: Another container object.\n    :param title: Text to be displayed in the top of the frame (can be formatted text).\n    :param style: Style string to be applied to this widget.\n    \"\"\"\n\n    def __init__(\n        self,\n        body: AnyContainer,\n        title: AnyFormattedText = \"\",\n        style: str = \"\",\n        width: AnyDimension = None,\n        height: AnyDimension = None,\n        key_bindings: Optional[KeyBindings] = None,\n        modal: bool = False,\n        activated: bool = False,\n    ) -&gt; None:\n        self.title = title\n        self.body = body\n        self.activated = activated\n\n        def get_style() -&gt; str:\n            if self.activated:\n                return \"class:frame.border.selected\"\n            else:\n                return \"class:frame.border\"\n\n        fill = partial(Window, style=get_style)\n        style = \"class:frame \" + style\n\n        top_row_with_title = VSplit(\n            [\n                fill(width=1, height=1, char=Border.TOP_LEFT),\n                fill(char=Border.HORIZONTAL),\n                fill(width=1, height=1, char=\"|\"),\n                # Notice: we use `Template` here, because `self.title` can be an\n                # `HTML` object for instance.\n                Label(\n                    lambda: Template(\" {} \").format(self.title),\n                    style=\"class:frame.label\",\n                    dont_extend_width=True,\n                ),\n                fill(width=1, height=1, char=\"|\"),\n                fill(char=Border.HORIZONTAL),\n                fill(width=1, height=1, char=Border.TOP_RIGHT),\n            ],\n            height=1,\n        )\n\n        top_row_without_title = VSplit(\n            [\n                fill(width=1, height=1, char=Border.TOP_LEFT),\n                fill(char=Border.HORIZONTAL),\n                fill(width=1, height=1, char=Border.TOP_RIGHT),\n            ],\n            height=1,\n        )\n\n        @Condition\n        def has_title() -&gt; bool:\n            return bool(self.title)\n\n        self.container = HSplit(\n            [\n                ConditionalContainer(\n                    content=top_row_with_title, filter=has_title\n                ),\n                ConditionalContainer(\n                    content=top_row_without_title, filter=~has_title\n                ),\n                VSplit(\n                    [\n                        fill(width=1, char=Border.VERTICAL),\n                        DynamicContainer(self.body),\n                        fill(width=1, char=Border.VERTICAL),\n                        # Padding is required to make sure that if the content is\n                        # too small, the right frame border is still aligned.\n                    ],\n                    padding=0,\n                ),\n                VSplit(\n                    [\n                        fill(width=1, height=1, char=Border.BOTTOM_LEFT),\n                        fill(char=Border.HORIZONTAL),\n                        fill(width=1, height=1, char=Border.BOTTOM_RIGHT),\n                    ],\n                    # specifying height here will increase the rendering speed.\n                    height=1,\n                ),\n            ],\n            width=width,\n            height=height,\n            style=style,\n            key_bindings=key_bindings,\n            modal=modal,\n        )\n\n    def __pt_container__(self) -&gt; Container:\n        return self.container\n</code></pre>"},{"location":"reference/androguard/ui/widget/help.html","title":"help","text":""},{"location":"reference/androguard/ui/widget/toolbar.html","title":"toolbar","text":""},{"location":"reference/androguard/ui/widget/transactions.html","title":"transactions","text":""}]}